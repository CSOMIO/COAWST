1) Extensions and improvements to unstructured mesh implementation:
   *) Handling holes in an unstructured grid is improved,
   *) Creating data structures for elements and edges is more faster,
   *) Prevention of interpolation over an obstacle is also included.
2) The stopping criterion based on the curvature of Hm0 is extended
   with the curvature of Tm01.
3) Each term of the action balance equation, i.e. time derivative of
   wave action, xy-propagation, theta-propagation, sigma-propagation,
   wind input, quadruplets, whitecapping, surf breaking, friction and
   triads, can be outputted by means of the TABLE and BLOCK commands.
   Moreover, the so-called work done by the radiation stress (a rest
   term in the energy(!) balance equation) can be plotted as well.
4) Bug fixes:
   *) interpolation near an obstacle for spectra is corrected,
   *) interpolation near a dry point is corrected,
   *) small correction in output in case of MPI parallel runs.

--- getcmpl	2008-05-25 14:59:38.000000000 +0200
+++ getcmpl	2008-10-15 11:57:40.000000000 +0200
@@ -1,5 +1,5 @@
 #!/bin/sh
-for cmpl in ifort ifc efc pgf90 lf95 gfortran g95; do
+for cmpl in ifort ifc efc pgf90 xlf90 lf95 gfortran g95; do
     IFS="${IFS= 	}"; ifssav="$IFS"; IFS="${IFS}:"
     for dir in $PATH; do
         test -z "$dir" && dir=.
--- gsunstruc.eps	1970-01-01 01:00:00.000000000 +0100
+++ gsunstruc.eps	2008-10-15 11:57:40.000000000 +0200
@@ -0,0 +1,656 @@
+%!PS-Adobe-2.0 EPSF-2.0
+%%Title: gsunstruc.fig
+%%Creator: fig2dev Version 3.2 Patchlevel 4
+%%CreationDate: Fri Feb 29 17:17:22 2008
+%%For: mzijlema@vlm117 (Marcel Zijlema)
+%%BoundingBox: 0 0 587 314
+%%Magnification: 1.0000
+%%EndComments
+/MyAppDict 100 dict dup begin def
+/$F2psDict 200 dict def
+$F2psDict begin
+$F2psDict /mtrx matrix put
+/col-1 {0 setgray} bind def
+/col0 {0.000 0.000 0.000 srgb} bind def
+/col1 {0.000 0.000 1.000 srgb} bind def
+/col2 {0.000 1.000 0.000 srgb} bind def
+/col3 {0.000 1.000 1.000 srgb} bind def
+/col4 {1.000 0.000 0.000 srgb} bind def
+/col5 {1.000 0.000 1.000 srgb} bind def
+/col6 {1.000 1.000 0.000 srgb} bind def
+/col7 {1.000 1.000 1.000 srgb} bind def
+/col8 {0.000 0.000 0.560 srgb} bind def
+/col9 {0.000 0.000 0.690 srgb} bind def
+/col10 {0.000 0.000 0.820 srgb} bind def
+/col11 {0.530 0.810 1.000 srgb} bind def
+/col12 {0.000 0.560 0.000 srgb} bind def
+/col13 {0.000 0.690 0.000 srgb} bind def
+/col14 {0.000 0.820 0.000 srgb} bind def
+/col15 {0.000 0.560 0.560 srgb} bind def
+/col16 {0.000 0.690 0.690 srgb} bind def
+/col17 {0.000 0.820 0.820 srgb} bind def
+/col18 {0.560 0.000 0.000 srgb} bind def
+/col19 {0.690 0.000 0.000 srgb} bind def
+/col20 {0.820 0.000 0.000 srgb} bind def
+/col21 {0.560 0.000 0.560 srgb} bind def
+/col22 {0.690 0.000 0.690 srgb} bind def
+/col23 {0.820 0.000 0.820 srgb} bind def
+/col24 {0.500 0.190 0.000 srgb} bind def
+/col25 {0.630 0.250 0.000 srgb} bind def
+/col26 {0.750 0.380 0.000 srgb} bind def
+/col27 {1.000 0.500 0.500 srgb} bind def
+/col28 {1.000 0.630 0.630 srgb} bind def
+/col29 {1.000 0.750 0.750 srgb} bind def
+/col30 {1.000 0.880 0.880 srgb} bind def
+/col31 {1.000 0.840 0.000 srgb} bind def
+
+end
+save
+newpath 0 314 moveto 0 0 lineto 587 0 lineto 587 314 lineto closepath clip newpath
+-92.6 415.8 translate
+1 -1 scale
+
+% This junk string is used by the show operators
+/PATsstr 1 string def
+/PATawidthshow { 	% cx cy cchar rx ry string
+  % Loop over each character in the string
+  {  % cx cy cchar rx ry char
+    % Show the character
+    dup				% cx cy cchar rx ry char char
+    PATsstr dup 0 4 -1 roll put	% cx cy cchar rx ry char (char)
+    false charpath		% cx cy cchar rx ry char
+    /clip load PATdraw
+    % Move past the character (charpath modified the
+    % current point)
+    currentpoint			% cx cy cchar rx ry char x y
+    newpath
+    moveto			% cx cy cchar rx ry char
+    % Reposition by cx,cy if the character in the string is cchar
+    3 index eq {			% cx cy cchar rx ry
+      4 index 4 index rmoveto
+    } if
+    % Reposition all characters by rx ry
+    2 copy rmoveto		% cx cy cchar rx ry
+  } forall
+  pop pop pop pop pop		% -
+  currentpoint
+  newpath
+  moveto
+} bind def
+/PATcg {
+  7 dict dup begin
+    /lw currentlinewidth def
+    /lc currentlinecap def
+    /lj currentlinejoin def
+    /ml currentmiterlimit def
+    /ds [ currentdash ] def
+    /cc [ currentrgbcolor ] def
+    /cm matrix currentmatrix def
+  end
+} bind def
+% PATdraw - calculates the boundaries of the object and
+% fills it with the current pattern
+/PATdraw {			% proc
+  save exch
+    PATpcalc			% proc nw nh px py
+    5 -1 roll exec		% nw nh px py
+    newpath
+    PATfill			% -
+  restore
+} bind def
+% PATfill - performs the tiling for the shape
+/PATfill { % nw nh px py PATfill -
+  PATDict /CurrentPattern get dup begin
+    setfont
+    % Set the coordinate system to Pattern Space
+    PatternGState PATsg
+    % Set the color for uncolored pattezns
+    PaintType 2 eq { PATDict /PColor get PATsc } if
+    % Create the string for showing
+    3 index string		% nw nh px py str
+    % Loop for each of the pattern sources
+    0 1 Multi 1 sub {		% nw nh px py str source
+	% Move to the starting location
+	3 index 3 index		% nw nh px py str source px py
+	moveto			% nw nh px py str source
+	% For multiple sources, set the appropriate color
+	Multi 1 ne { dup PC exch get PATsc } if
+	% Set the appropriate string for the source
+	0 1 7 index 1 sub { 2 index exch 2 index put } for pop
+	% Loop over the number of vertical cells
+	3 index 		% nw nh px py str nh
+	{			% nw nh px py str
+	  currentpoint		% nw nh px py str cx cy
+	  2 index oldshow	% nw nh px py str cx cy
+	  YStep add moveto	% nw nh px py str
+	} repeat		% nw nh px py str
+    } for
+    5 { pop } repeat
+  end
+} bind def
+
+% PATkshow - kshow with the current pattezn
+/PATkshow {			% proc string
+  exch bind			% string proc
+  1 index 0 get			% string proc char
+  % Loop over all but the last character in the string
+  0 1 4 index length 2 sub {
+				% string proc char idx
+    % Find the n+1th character in the string
+    3 index exch 1 add get	% string proc char char+1
+    exch 2 copy			% strinq proc char+1 char char+1 char
+    % Now show the nth character
+    PATsstr dup 0 4 -1 roll put	% string proc chr+1 chr chr+1 (chr)
+    false charpath		% string proc char+1 char char+1
+    /clip load PATdraw
+    % Move past the character (charpath modified the current point)
+    currentpoint newpath moveto
+    % Execute the user proc (should consume char and char+1)
+    mark 3 1 roll		% string proc char+1 mark char char+1
+    4 index exec		% string proc char+1 mark...
+    cleartomark			% string proc char+1
+  } for
+  % Now display the last character
+  PATsstr dup 0 4 -1 roll put	% string proc (char+1)
+  false charpath		% string proc
+  /clip load PATdraw
+  neewath
+  pop pop			% -
+} bind def
+% PATmp - the makepattern equivalent
+/PATmp {			% patdict patmtx PATmp patinstance
+  exch dup length 7 add		% We will add 6 new entries plus 1 FID
+  dict copy			% Create a new dictionary
+  begin
+    % Matrix to install when painting the pattern
+    TilingType PATtcalc
+    /PatternGState PATcg def
+    PatternGState /cm 3 -1 roll put
+    % Check for multi pattern sources (Level 1 fast color patterns)
+    currentdict /Multi known not { /Multi 1 def } if
+    % Font dictionary definitions
+    /FontType 3 def
+    % Create a dummy encoding vector
+    /Encoding 256 array def
+    3 string 0 1 255 {
+      Encoding exch dup 3 index cvs cvn put } for pop
+    /FontMatrix matrix def
+    /FontBBox BBox def
+    /BuildChar {
+	mark 3 1 roll		% mark dict char
+	exch begin
+	Multi 1 ne {PaintData exch get}{pop} ifelse  % mark [paintdata]
+	  PaintType 2 eq Multi 1 ne or
+	  { XStep 0 FontBBox aload pop setcachedevice }
+	  { XStep 0 setcharwidth } ifelse
+	  currentdict		% mark [paintdata] dict
+	  /PaintProc load	% mark [paintdata] dict paintproc
+	end
+	gsave
+	  false PATredef exec true PATredef
+	grestore
+	cleartomark		% -
+    } bind def
+    currentdict
+  end				% newdict
+  /foo exch			% /foo newlict
+  definefont			% newfont
+} bind def
+% PATpcalc - calculates the starting point and width/height
+% of the tile fill for the shape
+/PATpcalc {	% - PATpcalc nw nh px py
+  PATDict /CurrentPattern get begin
+    gsave
+	% Set up the coordinate system to Pattern Space
+	% and lock down pattern
+	PatternGState /cm get setmatrix
+	BBox aload pop pop pop translate
+	% Determine the bounding box of the shape
+	pathbbox			% llx lly urx ury
+    grestore
+    % Determine (nw, nh) the # of cells to paint width and height
+    PatHeight div ceiling		% llx lly urx qh
+    4 1 roll				% qh llx lly urx
+    PatWidth div ceiling		% qh llx lly qw
+    4 1 roll				% qw qh llx lly
+    PatHeight div floor			% qw qh llx ph
+    4 1 roll				% ph qw qh llx
+    PatWidth div floor			% ph qw qh pw
+    4 1 roll				% pw ph qw qh
+    2 index sub cvi abs			% pw ph qs qh-ph
+    exch 3 index sub cvi abs exch	% pw ph nw=qw-pw nh=qh-ph
+    % Determine the starting point of the pattern fill
+    %(px, py)
+    4 2 roll				% nw nh pw ph
+    PatHeight mul			% nw nh pw py
+    exch				% nw nh py pw
+    PatWidth mul exch			% nw nh px py
+  end
+} bind def
+
+% Save the original routines so that we can use them later on
+/oldfill	/fill load def
+/oldeofill	/eofill load def
+/oldstroke	/stroke load def
+/oldshow	/show load def
+/oldashow	/ashow load def
+/oldwidthshow	/widthshow load def
+/oldawidthshow	/awidthshow load def
+/oldkshow	/kshow load def
+
+% These defs are necessary so that subsequent procs don't bind in
+% the originals
+/fill	   { oldfill } bind def
+/eofill	   { oldeofill } bind def
+/stroke	   { oldstroke } bind def
+/show	   { oldshow } bind def
+/ashow	   { oldashow } bind def
+/widthshow { oldwidthshow } bind def
+/awidthshow { oldawidthshow } bind def
+/kshow 	   { oldkshow } bind def
+/PATredef {
+  MyAppDict begin
+    {
+    /fill { /clip load PATdraw newpath } bind def
+    /eofill { /eoclip load PATdraw newpath } bind def
+    /stroke { PATstroke } bind def
+    /show { 0 0 null 0 0 6 -1 roll PATawidthshow } bind def
+    /ashow { 0 0 null 6 3 roll PATawidthshow }
+    bind def
+    /widthshow { 0 0 3 -1 roll PATawidthshow }
+    bind def
+    /awidthshow { PATawidthshow } bind def
+    /kshow { PATkshow } bind def
+  } {
+    /fill   { oldfill } bind def
+    /eofill { oldeofill } bind def
+    /stroke { oldstroke } bind def
+    /show   { oldshow } bind def
+    /ashow  { oldashow } bind def
+    /widthshow { oldwidthshow } bind def
+    /awidthshow { oldawidthshow } bind def
+    /kshow  { oldkshow } bind def
+    } ifelse
+  end
+} bind def
+false PATredef
+% Conditionally define setcmykcolor if not available
+/setcmykcolor where { pop } {
+  /setcmykcolor {
+    1 sub 4 1 roll
+    3 {
+	3 index add neg dup 0 lt { pop 0 } if 3 1 roll
+    } repeat
+    setrgbcolor - pop
+  } bind def
+} ifelse
+/PATsc {		% colorarray
+  aload length		% c1 ... cn length
+    dup 1 eq { pop setgray } { 3 eq { setrgbcolor } { setcmykcolor
+  } ifelse } ifelse
+} bind def
+/PATsg {		% dict
+  begin
+    lw setlinewidth
+    lc setlinecap
+    lj setlinejoin
+    ml setmiterlimit
+    ds aload pop setdash
+    cc aload pop setrgbcolor
+    cm setmatrix
+  end
+} bind def
+
+/PATDict 3 dict def
+/PATsp {
+  true PATredef
+  PATDict begin
+    /CurrentPattern exch def
+    % If it's an uncolored pattern, save the color
+    CurrentPattern /PaintType get 2 eq {
+      /PColor exch def
+    } if
+    /CColor [ currentrgbcolor ] def
+  end
+} bind def
+% PATstroke - stroke with the current pattern
+/PATstroke {
+  countdictstack
+  save
+  mark
+  {
+    currentpoint strokepath moveto
+    PATpcalc				% proc nw nh px py
+    clip newpath PATfill
+    } stopped {
+	(*** PATstroke Warning: Path is too complex, stroking
+	  with gray) =
+    cleartomark
+    restore
+    countdictstack exch sub dup 0 gt
+	{ { end } repeat } { pop } ifelse
+    gsave 0.5 setgray oldstroke grestore
+  } { pop restore pop } ifelse
+  newpath
+} bind def
+/PATtcalc {		% modmtx tilingtype PATtcalc tilematrix
+  % Note: tiling types 2 and 3 are not supported
+  gsave
+    exch concat					% tilingtype
+    matrix currentmatrix exch			% cmtx tilingtype
+    % Tiling type 1 and 3: constant spacing
+    2 ne {
+	% Distort the pattern so that it occupies
+	% an integral number of device pixels
+	dup 4 get exch dup 5 get exch		% tx ty cmtx
+	XStep 0 dtransform
+	round exch round exch			% tx ty cmtx dx.x dx.y
+	XStep div exch XStep div exch		% tx ty cmtx a b
+	0 YStep dtransform
+	round exch round exch			% tx ty cmtx a b dy.x dy.y
+	YStep div exch YStep div exch		% tx ty cmtx a b c d
+	7 -3 roll astore			% { a b c d tx ty }
+    } if
+  grestore
+} bind def
+/PATusp {
+  false PATredef
+  PATDict begin
+    CColor PATsc
+  end
+} bind def
+
+% this is the pattern fill program from the Second edition Reference Manual
+% with changes to call the above pattern fill
+% left30
+11 dict begin
+/PaintType 1 def
+/PatternType 1 def
+/TilingType 1 def
+/BBox [0 0 1 1] def
+/XStep 1 def
+/YStep 1 def
+/PatWidth 1 def
+/PatHeight 1 def
+/Multi 2 def
+/PaintData [
+  { clippath } bind
+  { 32 16 true [ 32 0 0 -16 0 16 ]
+	{<c000c000300030000c000c000300030000c000c000300030
+	000c000c00030003c000c000300030000c000c0003000300
+	00c000c000300030000c000c00030003>}
+     imagemask } bind
+] def
+/PaintProc {
+	pop
+	exec fill
+} def
+currentdict
+end
+/P1 exch def
+
+/cp {closepath} bind def
+/ef {eofill} bind def
+/gr {grestore} bind def
+/gs {gsave} bind def
+/sa {save} bind def
+/rs {restore} bind def
+/l {lineto} bind def
+/m {moveto} bind def
+/rm {rmoveto} bind def
+/n {newpath} bind def
+/s {stroke} bind def
+/sh {show} bind def
+/slc {setlinecap} bind def
+/slj {setlinejoin} bind def
+/slw {setlinewidth} bind def
+/srgb {setrgbcolor} bind def
+/rot {rotate} bind def
+/sc {scale} bind def
+/sd {setdash} bind def
+/ff {findfont} bind def
+/sf {setfont} bind def
+/scf {scalefont} bind def
+/sw {stringwidth} bind def
+/tr {translate} bind def
+/tnt {dup dup currentrgbcolor
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add srgb}
+  bind def
+/shd {dup dup currentrgbcolor 4 -2 roll mul 4 -2 roll mul
+  4 -2 roll mul srgb} bind def
+ /DrawEllipse {
+	/endangle exch def
+	/startangle exch def
+	/yrad exch def
+	/xrad exch def
+	/y exch def
+	/x exch def
+	/savematrix mtrx currentmatrix def
+	x y tr xrad yrad sc 0 0 1 startangle endangle arc
+	closepath
+	savematrix setmatrix
+	} def
+
+/$F2psBegin {$F2psDict begin /$F2psEnteredState save def} def
+/$F2psEnd {$F2psEnteredState restore end} def
+
+$F2psBegin
+10 setmiterlimit
+0 slj 0 slc
+ 0.06299 0.06299 sc
+%
+% Fig objects follow
+%
+% 
+% here starts figure with depth 50
+% Arc
+15.000 slw
+n 9395.2 3602.6 1105.1 -23.3 34.6 arc
+gs 0.50 setgray ef gr gs col0 s gr
+
+% Arc
+n 4073.7 3210.8 317.9 -83.4 -166.2 arcn
+gs col0 s gr
+
+% Arc
+n 9307.0 3750.0 317.2 96.7 13.7 arcn
+gs col0 s gr
+
+% Arc
+n 9142.7 3686.4 501.7 -24.3 -71.7 arcn
+gs col0 s gr
+
+% Arc
+n 9133.4 3670.3 570.8 -22.7 -74.6 arcn
+gs col0 s gr
+
+% Arc
+n 4291.0 3230.0 570.2 157.3 105.4 arcn
+gs col0 s gr
+
+% Arc
+n 4246.0 3290.0 570.2 157.3 105.4 arcn
+gs col0 s gr
+
+% Ellipse
+7.500 slw
+n 4125 3345 85 85 0 360 DrawEllipse gs 0.50 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 3465 4260 85 85 0 360 DrawEllipse gs col0 s gr
+
+% Ellipse
+n 5760 2940 85 85 0 360 DrawEllipse gs col0 s gr
+
+% Ellipse
+n 3480 1710 85 85 0 360 DrawEllipse gs col0 s gr
+
+% Ellipse
+n 4305 4950 85 85 0 360 DrawEllipse gs col0 s gr
+
+% Ellipse
+n 2040 4065 82 82 0 360 DrawEllipse gs /PC [[0.00 0.00 0.00] [0.00 0.00 0.00]] def
+15.00 15.00 sc P1 [16 0 0 -8 130.53 265.53] PATmp PATsp ef gr PATusp gs col0 s gr
+
+% Ellipse
+n 2430 2355 82 82 0 360 DrawEllipse gs /PC [[0.00 0.00 0.00] [0.00 0.00 0.00]] def
+15.00 15.00 sc P1 [16 0 0 -8 156.53 151.53] PATmp PATsp ef gr PATusp gs col0 s gr
+
+% Ellipse
+n 9255 3592 1222 1222 0 360 DrawEllipse gs col0 s gr
+
+% Ellipse
+n 4500 5685 85 85 0 360 DrawEllipse gs col0 s gr
+
+% Ellipse
+n 4500 6060 85 85 0 360 DrawEllipse gs 0.50 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 4485 6435 82 82 0 360 DrawEllipse gs /PC [[0.00 0.00 0.00] [0.00 0.00 0.00]] def
+15.00 15.00 sc P1 [16 0 0 -8 293.53 423.53] PATmp PATsp ef gr PATusp gs col0 s gr
+
+% Polyline
+n 2430 2385 m
+ 4095 3330 l gs col0 s gr 
+% Polyline
+n 2420 2386 m
+ 2045 4081 l gs col0 s gr 
+% Polyline
+n 4125 3330 m 3480 1680 l 2430 2370 l
+ 2415 2385 l gs col0 s gr 
+% Polyline
+n 4125 3360 m 5805 2940 l 3510 1695 l
+ 3480 1695 l gs col0 s gr 
+% Polyline
+n 3480 4245 m
+ 2040 4080 l gs col0 s gr 
+% Polyline
+15.000 slw
+gs  clippath
+3388 2999 m 3447 2894 l 3195 2754 l 3376 2924 l 3137 2859 l cp
+eoclip
+n 2760 2580 m
+ 3405 2940 l gs /PC [[0.00 0.00 0.00] [0.00 0.00 0.00]] def
+15.00 15.00 sc P1 [16 0 0 -8 184.00 172.00] PATmp PATsp ef gr PATusp gs col0 s gr gr
+
+% arrowhead
+n 3137 2859 m 3376 2924 l 3195 2754 l  col0 s
+% Polyline
+gs  clippath
+3469 3636 m 3428 3523 l 3158 3623 l 3404 3596 l 3199 3735 l cp
+eoclip
+n 2625 3885 m
+ 3435 3585 l gs /PC [[0.00 0.00 0.00] [0.00 0.00 0.00]] def
+15.00 15.00 sc P1 [16 0 0 -8 175.00 239.00] PATmp PATsp ef gr PATusp gs col0 s gr gr
+
+% arrowhead
+n 3199 3735 m 3404 3596 l 3158 3623 l  col0 s
+% Polyline
+7.500 slw
+n 9270 2175 m
+ 9270 5040 l gs /PC [[0.00 0.00 0.00] [0.00 0.00 0.00]] def
+15.00 15.00 sc P1 [16 0 0 -8 618.00 145.00] PATmp PATsp ef gr PATusp gs col0 s gr 
+% Polyline
+15.000 slw
+n 9280 3644 m 10300 4214 l
+ 10270 4199 l gs col0 s gr 
+% Polyline
+n 9258 3616 m 10398 3151 l
+ 10368 3181 l gs col0 s gr 
+% Polyline
+0.000 slw
+n 9270 3615 m 10410 3150 l 10305 4215 l
+ 9270 3630 l gs 0.50 setgray ef gr 
+% Polyline
+7.500 slw
+n 9285 3630 m
+ 7830 3630 l gs col0 s gr 
+% Polyline
+n 10485 3660 m 10650 3660 l
+ 10650 3675 l gs col0 s gr 
+% Polyline
+n 2047 4098 m
+ 4102 3348 l gs col0 s gr 
+% Polyline
+n 4156 3335 m 4336 4955 l
+ 5806 2930 l gs col0 s gr 
+% Polyline
+ [60] 0 sd
+n 4116 1695 m
+ 4131 5220 l gs col0 s gr  [] 0 sd
+% Polyline
+n 4152 3378 m 3492 4233 l
+ 4347 4968 l gs col0 s gr 
+% Polyline
+gs  clippath
+2130 5085 m 2130 5025 l 1979 5025 l 2099 5055 l 1979 5085 l cp
+eoclip
+n 1515 5055 m
+ 2115 5055 l gs col0 s gr gr
+
+% arrowhead
+n 1979 5085 m 2099 5055 l 1979 5025 l 1979 5085 l  cp gs 0.00 setgray ef gr  col0 s
+% Polyline
+gs  clippath
+1545 4440 m 1485 4440 l 1485 4591 l 1515 4471 l 1545 4591 l cp
+eoclip
+n 1515 5055 m
+ 1515 4455 l gs col0 s gr gr
+
+% arrowhead
+n 1545 4591 m 1515 4471 l 1485 4591 l 1545 4591 l  cp gs 0.00 setgray ef gr  col0 s
+/Times-Roman ff 300.00 scf sf
+4200 3255 m
+gs 1 -1 sc (1) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+2145 2475 m
+gs 1 -1 sc (2) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+1830 4395 m
+gs 1 -1 sc (3) col0 sh gr
+/Times-Bold ff 375.00 scf sf
+2925 2595 m
+gs 1 -1 sc (e) col0 sh gr
+/Times-Bold ff 225.00 scf sf
+3075 2685 m
+gs 1 -1 sc (\(1\)) col0 sh gr
+/Times-Bold ff 225.00 scf sf
+2820 3675 m
+gs 1 -1 sc (\(2\)) col0 sh gr
+/Times-Bold ff 375.00 scf sf
+2685 3585 m
+gs 1 -1 sc (e) col0 sh gr
+/Symbol ff 300.00 scf sf
+10515 3195 m
+gs 1 -1 sc (q) col0 sh gr
+/Symbol ff 300.00 scf sf
+10440 4440 m
+gs 1 -1 sc (q) col0 sh gr
+/Times-Roman ff 225.00 scf sf
+10665 3270 m
+gs 1 -1 sc (2) col0 sh gr
+/Times-Roman ff 225.00 scf sf
+10590 4530 m
+gs 1 -1 sc (1) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+2145 5115 m
+gs 1 -1 sc (x) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+1470 4395 m
+gs 1 -1 sc (y) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+4710 5775 m
+gs 1 -1 sc (= not updated) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+4725 6150 m
+gs 1 -1 sc (= to be updated) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+4725 6525 m
+gs 1 -1 sc (= updated) col0 sh gr
+% here ends figure;
+$F2psEnd
+rs
+end
+showpage
--- Makefile	2008-05-25 14:59:38.000000000 +0200
+++ Makefile	2008-10-15 11:57:40.000000000 +0200
@@ -10,7 +10,7 @@
 #
 # To remove compiled objects and modules: type "make clean"
 #
-# To remove compiled objects, modules and executable: type "make allclean"
+# To remove compiled objects, modules and executable: type "make clobber"
 #
 # To compile the SWAN documentation type "make doc"
 #
@@ -92,12 +92,12 @@
 help:
 	@echo "This Makefile supports the following:"
 	@echo "make config    -- makes machine-dependent macros include file"
-	@echo "make ser       -- makes the Serial $(SWAN_EXE) executable"
+	@echo "make ser       -- makes the serial $(SWAN_EXE) executable"
 	@echo "make omp       -- makes the OpenMP $(SWAN_EXE) executable"
 	@echo "make mpi       -- makes the    MPI $(SWAN_EXE) executable"
 	@echo "make doc       -- makes the SWAN documentation (PDF)"
 	@echo "make clean     -- removes compiled objects and modules"
-	@echo "make allclean  -- removes compiled objects, modules and $(SWAN_EXE)"
+	@echo "make clobber   -- removes compiled objects, modules and $(SWAN_EXE)"
 	@echo "make cleandoc  -- removes all SWAN documents"
 
 config:
@@ -161,6 +161,9 @@
 clean:
 	$(RM) *.$(EXTO) *.mod
 
+clobber:
+	$(RM) *.$(EXTO) *.mod *.f *.F *.F90 *.for *.f90 $(SWAN_EXE) $(HCAT_EXE)
+
 allclean:
 	$(RM) *.$(EXTO) *.mod *.f *.F *.F90 *.for *.f90 $(SWAN_EXE) $(HCAT_EXE)
 
--- Makefile.latex	2008-05-25 14:59:38.000000000 +0200
+++ Makefile.latex	2008-10-15 11:57:40.000000000 +0200
@@ -55,4 +55,6 @@
 	$(RM) $(TARGET).pdf
 	rm -rf $(TARGET)
 
+clobber: cleantex cleandvi cleanps cleanpdf cleanhtml
+
 allclean: cleantex cleandvi cleanps cleanpdf cleanhtml
--- ocpmix.ftn	2008-05-25 14:59:50.000000000 +0200
+++ ocpmix.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -1008,32 +1008,32 @@
 !       unformatted read
         SELECT CASE(IDLA)
         CASE(1)
-          DO IY=MYA, 1, -1                                               40.02
-            READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                   40.02
-     &      (ARR(IX,IY), IX=1,MXA)                                       40.02
-          ENDDO                                                          40.02
-        CASE(2)                                                          40.02
-          READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                     40.02
-     &    ((ARR(IX,IY), IX=1,MXA), IY=MYA,1,-1)                          40.02
-        CASE(3)                                                          40.02
-          DO IY=1, MYA                                                   40.02
-            READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                   40.02
-     &      (ARR(IX,IY), IX=1,MXA)                                       40.02
-          ENDDO                                                          40.02
-        CASE(4)                                                          40.02
-          READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                     40.02
-     &    ((ARR(IX,IY), IX=1,MXA), IY=1,MYA)                             40.02
-        CASE(5)                                                          40.02
-          DO IX=1, MXA                                                   40.02
-            READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                   40.02
-     &      (ARR(IX,IY), IY=1,MYA)                                       40.02
-          ENDDO                                                          40.02
-        CASE(6)                                                          40.02
-          READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                     40.02
-     &    ((ARR(IX,IY), IY=1,MYA), IX=1,MXA)                             40.02
-        END SELECT                                                       40.02
+          DO IY=MYA, 1, -1                                                40.02
+            READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                    40.02
+     &      (ARR(IX,IY), IX=1,MXA)                                        40.02
+          ENDDO                                                           40.02
+        CASE(2)                                                           40.02
+          READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                      40.02
+     &    ((ARR(IX,IY), IX=1,MXA), IY=MYA,1,-1)                           40.02
+        CASE(3)                                                           40.02
+          DO IY=1, MYA                                                    40.02
+            READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                    40.02
+     &      (ARR(IX,IY), IX=1,MXA)                                        40.02
+          ENDDO                                                           40.02
+        CASE(4)                                                           40.02
+          READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                      40.02
+     &    ((ARR(IX,IY), IX=1,MXA), IY=1,MYA)                              40.02
+        CASE(5)                                                           40.02
+          DO IX=1, MXA                                                    40.02
+            READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                    40.02
+     &      (ARR(IX,IY), IY=1,MYA)                                        40.02
+          ENDDO                                                           40.02
+        CASE(6)                                                           40.02
+          READ (NDSD, END=910, ERR=920, IOSTAT=IERR)                      40.02
+     &    ((ARR(IX,IY), IY=1,MYA), IX=1,MXA)                              40.02
+        END SELECT                                                        40.02
       ENDIF
-      GOTO 900                                                           40.02
+      GOTO 900                                                            40.02
 !
 !     *** End of data file, in case SERIES next file is opened
 !     *** unit = NDSD is closed before the next one is opened
@@ -1378,8 +1378,8 @@
   13         FORMAT('-',I3.3)                                             40.30
           END IF                                                          40.30
 !
-          IERRF = 17                                                          40.13
-          OPEN (UNIT=IERRF, FILE=ERRFNM, FORM='FORMATTED')                    40.13
+          IERRF = 17                                                      40.13
+          OPEN (UNIT=IERRF, FILE=ERRFNM, FORM='FORMATTED')                40.13
         ENDIF
         WRITE (IERRF,14) ERRM, STRING
   14    FORMAT (A, ': ',A)
@@ -1391,7 +1391,7 @@
 !
 !*****************************************************************
 !                                                                *
-      LOGICAL FUNCTION STPNOW()                                             30.82
+      LOGICAL FUNCTION STPNOW()                                           30.82
 !                                                                *
 !*****************************************************************
 !
@@ -1989,8 +1989,8 @@
 !
 !  3. Method (updated...)
 !
-!     Checks whether ABS(REAL1-REAL2) .LE. TINY(REAL1) or whether this        40.04
-!     difference is .LE. then EPS (= EPSILON(REAL1)*ABS(REAL1-REAL2) )        40.04
+!     Checks whether ABS(REAL1-REAL2) .LE. TINY(REAL1) or whether this    40.04
+!     difference is .LE. then EPS (= EPSILON(REAL1)*ABS(REAL1-REAL2) )    40.04
 !
 !  4. Argument variables
 !
@@ -2041,13 +2041,13 @@
       CALL STRACE(IENT,'EQREAL')
       EQREAL = .FALSE.
 !
-      EPS = EPSILON(REAL1)*ABS(REAL1-REAL2)                                  40.04
-      IF (EPS ==0) EPS = TINY(REAL1)                                         40.04
-      IF (ABS(REAL1-REAL2) .GT. TINY(REAL1)) THEN                            40.04
-        IF (ABS(REAL1-REAL2) .LT. EPS) EQREAL = .TRUE.                       40.04
-      ELSE                                                                   40.04
-        EQREAL = .TRUE.                                                      40.04
-      ENDIF                                                                  40.04
+      EPS = EPSILON(REAL1)*ABS(REAL1-REAL2)                               40.04
+      IF (EPS ==0) EPS = TINY(REAL1)                                      40.04
+      IF (ABS(REAL1-REAL2) .GT. TINY(REAL1)) THEN                         40.04
+        IF (ABS(REAL1-REAL2) .LT. EPS) EQREAL = .TRUE.                    40.04
+      ELSE                                                                40.04
+        EQREAL = .TRUE.                                                   40.04
+      ENDIF                                                               40.04
       RETURN
 !     end of subroutine EQREAL
       END
@@ -2117,13 +2117,13 @@
 !
 !     NUMITM : input    max number of data items in array
 !
-      INTEGER, INTENT(IN) :: NUMITM                                        40.03
+      INTEGER, INTENT(IN) :: NUMITM                                       40.03
 !
 !     DATITM : output   array of data items
 !     RELINE : input    string (read from an input file)
 !
-      CHARACTER (LEN=*), INTENT(OUT) :: DATITM(NUMITM)                     40.03
-      CHARACTER (LEN=*), INTENT(IN) ::  RELINE                             40.03
+      CHARACTER (LEN=*), INTENT(OUT) :: DATITM(NUMITM)                    40.03
+      CHARACTER (LEN=*), INTENT(IN) ::  RELINE                            40.03
 !
 !  5. PARAMETER VARIABLES
 !
@@ -2413,14 +2413,14 @@
 !
 !     IARRAY : output   an integer array
 !     LENARR : input    length of array IARRAY
-!     IERR   : output   error status: 0=no error, 9=end-of-file            30.81
+!     IERR   : output   error status: 0=no error, 9=end-of-file           30.81
 !
-      INTEGER   IARRAY(*), LENARR, IENT,                                30.72
-     &          IERR                                                    30.81
+      INTEGER   IARRAY(*), LENARR, IENT,                                  30.72
+     &          IERR                                                      30.81
 !
 !     STRING : i/o      a character string
-!     MOVE   : input    if MOVE=TO_, STRING is copied to IARRAY   30.81
-!                               if MOVE=FROM_, STRING is copied from IARRAY   30.81
+!     MOVE   : input    if MOVE=TO_, STRING is copied to IARRAY           30.81
+!                       if MOVE=FROM_, STRING is copied from IARRAY       30.81
 !
       CHARACTER MOVE *1, STRING *(*)
 !
--- platform.pl	2008-05-25 14:59:38.000000000 +0200
+++ platform.pl	2008-10-15 11:57:40.000000000 +0200
@@ -69,7 +69,7 @@
   print OUTFILE "EXTO = o\n";
   print OUTFILE "MAKE = make\n";
   print OUTFILE "RM = rm -f\n";
-  print OUTFILE "swch = -unix -timg\n";
+  print OUTFILE "swch = -unix -f95 -timg\n";
 }
 elsif ($os =~ /OSF1/i) {
   print OUTFILE "##############################################################################\n";
@@ -104,7 +104,9 @@
   print OUTFILE "F90_MPI = mpf90\n";
   print OUTFILE "FLAGS_OPT = -xO3 -xtarget=native -fsimple=1 -depend -libmil -xlibmopt -xlic_lib=sunperf\n";
   print OUTFILE "FLAGS_MSC = -w -silent\n";
+  print OUTFILE "FLAGS_SER =\n";
   print OUTFILE "FLAGS_OMP = -openmp\n";
+  print OUTFILE "FLAGS_MPI =\n";
   print OUTFILE "INCS_SER = \n";
   print OUTFILE "INCS_OMP = \n";
   print OUTFILE "INCS_MPI =\n";
@@ -119,7 +121,7 @@
 }
 elsif ($os =~ /HP-UX/i) {
   print OUTFILE "##############################################################################\n";
-  print OUTFILE "# RISC_HPUX:		PA-RISC with HP-UX 11 using HP Fortran compiler.\n";
+  print OUTFILE "# RISC_HPUX:		PA-RISC with HP-UX 11 using HP compiler.\n";
   print OUTFILE "##############################################################################\n";
   print OUTFILE "F90_SER = f90\n";
   print OUTFILE "F90_OMP = f90\n";
@@ -367,7 +369,7 @@
 }
 elsif ($os =~ /Darwin/i) {
   print OUTFILE "##############################################################################\n";
-  print OUTFILE "# MAC_IBM:		MAC OS X Apple with IBM Fortran Compiler.\n";
+  print OUTFILE "# MAC_IBM:		MAC OS X Apple with IBM Compiler.\n";
   print OUTFILE "##############################################################################\n";
   print OUTFILE "F90_SER = xlf90\n";
   print OUTFILE "F90_OMP =\n";
@@ -387,7 +389,7 @@
   print OUTFILE "EXTO = o\n";
   print OUTFILE "MAKE = make\n";
   print OUTFILE "RM = rm -f\n";
-  print OUTFILE "swch = -unix -timg\n";
+  print OUTFILE "swch = -unix -f95 -timg\n";
 }
 else
 {
--- plotgrid.m	2008-05-25 14:59:38.000000000 +0200
+++ plotgrid.m	2008-10-15 11:57:40.000000000 +0200
@@ -21,11 +21,13 @@
 elefile=[basename '.ele'];
 fid = fopen(nodefile);                        % load TRIANGLE vertex based connectivity file
 [nnode] = fscanf(fid,'%i',[1 4]);             % get number of nodes
-data = fscanf(fid,'%f',[4 nnode(1)])';        % get data
+ncol = 3+nnode(3)+nnode(4);                   % specify number of columns in nodefile
+data = fscanf(fid,'%f',[ncol nnode(1)])';     % get data
 x=data(:,2); y=data(:,3);                     % get coordinates
 fid = fopen(elefile);                         % load TRIANGLE element based connectivity file
 [nelem] = fscanf(fid,'%i',[1 3]);             % get number of triangles
-tri = fscanf(fid,'%i',[4 nelem(1)])';         % get connectivity table
+ncol = 4+nelem(3);                            % specify number of columns in elefile
+tri = fscanf(fid,'%i',[ncol nelem(1)])';      % get connectivity table
 trimesh(tri(:,2:4),x,y, zeros(size(x)), ...   % make grid using trimesh
                   'EdgeColor', 'k', ...
                   'FaceColor', 'none', ...
--- plotunswan.m	2008-05-25 14:59:38.000000000 +0200
+++ plotunswan.m	2008-10-15 11:57:40.000000000 +0200
@@ -23,13 +23,14 @@
    error('Wrong number of arguments. See "help plotunswan"')
 end
 
-eval(['load ' matfile]);              % load binary file containing SWAN results
-                                      % obtained using BLOCK command with COMPGRID-set
+eval(['load ' matfile]);                 % load binary file containing SWAN results
+                                         % obtained using BLOCK command with COMPGRID-set
 elefile=[basename '.ele'];
-fid = fopen(elefile);                 % load TRIANGLE element based connectivity file
-[nelem] = fscanf(fid,'%i',[1 3]);     % get number of triangles
-tri = fscanf(fid,'%i',[4 nelem(1)])'; % get connectivity table
-z=eval([wavepar]);                    % get wave parameter
-trisurf(tri(:,2:4),Xp,Yp,z)           % make plot using trisurf
-view(0,90);shading interp;            % make 2D view and smooth plot
-colormap(jet);colorbar;axis equal     % include colorbar and equal axes
+fid = fopen(elefile);                    % load TRIANGLE element based connectivity file
+[nelem] = fscanf(fid,'%i',[1 3]);        % get number of triangles
+ncol = 4+nelem(3);                       % specify number of columns in elefile
+tri = fscanf(fid,'%i',[ncol nelem(1)])'; % get connectivity table
+z=eval([wavepar]);                       % get wave parameter
+trisurf(tri(:,2:4),Xp,Yp,z)              % make plot using trisurf
+view(0,90);shading interp;               % make 2D view and smooth plot
+colormap(jet);colorbar;axis equal        % include colorbar and equal axes
--- SwanBpntlist.ftn90	2008-05-25 14:59:40.000000000 +0200
+++ SwanBpntlist.ftn90	2008-10-15 11:57:41.000000000 +0200
@@ -32,14 +32,27 @@
 !   Authors
 !
 !   40.80: Marcel Zijlema
+!   40.92: Marcel Zijlema
 !
 !   Updates
 !
 !   40.80, April 2008: New subroutine
+!   40.92,  June 2008: changes with respect to boundary polygons
 !
 !   Purpose
 !
-!   Makes list of boundary points in ascending order (counterclockwise)
+!   Makes list of boundary vertices in ascending order
+!   - counterclockwise in case of sea/mainland boundaries
+!   - clockwise in case of island boundaries
+!
+!   Method
+!
+!   The grid contains a number of boundary polygons
+!   They are by definition closed
+!   The first boundary polygon refers to sea/mainland boundary and the other polygons refers to island boundaries
+!
+!   The vertices which define the sea/mainland boundary are inserted in the counterclockwise direction
+!   The vertices which define the island boundary are inserted in the clockwise direction
 !
 !   Modules used
 !
@@ -52,26 +65,37 @@
 !
 !   Local variables
 !
-    integer                         :: icell      ! cell index
-    integer, save                   :: ient = 0   ! number of entries in this subroutine
-    integer                         :: iface      ! face index
-    integer                         :: istat      ! indicate status of allocation
-    integer                         :: j          ! loop counter
-    integer                         :: k          ! counter
-    integer, dimension(1)           :: kx         ! location of minimum value in array of x-coordinates of boundary vertices
-    integer, dimension(1)           :: ky         ! location of minimum value in array of y-coordinates of boundary vertices
-    integer, dimension(3)           :: v          ! vertices in present cell
-    integer                         :: v1         ! first vertex of present face
-    integer                         :: v2         ! second vertex of present face
-    integer                         :: vc         ! considered vertex
-    integer                         :: vn         ! next vertex with respect to considered vertex (counterclockwise)
-    !
-    real                            :: d1         ! distance of a point to origin
-    real                            :: d2         ! distance of another point to origin
-    !
-    type(celltype), dimension(:), pointer :: cell ! datastructure for cells with their attributes
-    type(facetype), dimension(:), pointer :: face ! datastructure for faces with their attributes
-    type(verttype), dimension(:), pointer :: vert ! datastructure for vertices with their attributes
+    integer                            :: icell      ! cell index
+    integer, save                      :: ient = 0   ! number of entries in this subroutine
+    integer                            :: iface      ! face index
+    integer                            :: istat      ! indicate status of allocation
+    integer                            :: j          ! loop counter
+    integer                            :: k          ! counter
+    integer, dimension(1)              :: kx         ! location of minimum value in array of x-coordinates of boundary vertices
+    integer, dimension(1)              :: ky         ! location of minimum value in array of y-coordinates of boundary vertices
+    integer                            :: m          ! loop counter
+    integer                            :: maxnbp     ! maximum number of boundary vertices in set of polygons
+    integer                            :: nbptot     ! total number of boundary vertices
+    integer                            :: nptemp     ! auxiliary integer to store number of points temporarily
+    integer, dimension(3)              :: v          ! vertices in present cell
+    integer                            :: v1         ! first vertex of present face
+    integer                            :: v2         ! second vertex of present face
+    integer                            :: vc         ! considered vertex
+    integer                            :: vcf        ! first considered vertex of a boundary polygon
+    integer                            :: vn         ! next vertex with respect to considered vertex (counterclockwise)
+    !
+    integer, dimension(:), allocatable :: blistot    ! list of all boundary vertices in ascending order
+    !
+    real                               :: d1         ! distance of a point to origin
+    real                               :: d2         ! distance of another point to origin
+    !
+    character(80)                      :: msgstr     ! string to pass message
+    !
+    logical                            :: firstvert  ! indicate whether considered vertex is first vertex of boundary polygon
+    !
+    type(celltype), dimension(:), pointer :: cell    ! datastructure for cells with their attributes
+    type(facetype), dimension(:), pointer :: face    ! datastructure for faces with their attributes
+    type(verttype), dimension(:), pointer :: vert    ! datastructure for vertices with their attributes
 !
 !   Structure
 !
@@ -81,6 +105,10 @@
 !
     if (ltrace) call strace (ient,'SwanBpntlist')
     !
+    ! if list of boundary vertices is already filled, return
+    !
+    if (allocated(blist)) return
+    !
     ! point to vertex, cell and face objects
     !
     vert => gridobject%vert_grid
@@ -88,19 +116,17 @@
     face => gridobject%face_grid
     !
     vert(:)%atti(BINDX) = 0
+    vert(:)%atti(BPOL)  = 0
+    nbpt                = 0
     !
-    ! determine total number of boundary points
+    ! determine total number of boundary vertices
     !
-    nbpt = count(mask=vert(:)%atti(VMARKER)==1)
+    nbptot = count(mask=vert(:)%atti(VMARKER)==1)
     !
-    if(.not.allocated(blist)) allocate (blist(nbpt), stat = istat)
-    if ( istat /= 0 ) then
-       call msgerr ( 4, 'Allocation problem in SwanBpntlist: array blist ' )
-       return
-    endif
-    blist = 0
+    allocate(blistot(nbptot))
+    blistot = 0
     !
-    ! determine first boundary point nearest to the origin
+    ! determine first boundary vertex nearest to the origin
     !
     kx = minloc(vert(:)%attr(VERTX), vert(:)%atti(VMARKER)==1)
     ky = minloc(vert(:)%attr(VERTY), vert(:)%atti(VMARKER)==1)
@@ -122,12 +148,17 @@
        !
     endif
     !
-    ! store first boundary point
+    ! store first boundary vertex
     !
-    blist(1)             = vc
-    vert(vc)%atti(BINDX) = 1
+    vcf                 = vc
+    blistot(1)          = vc
+    nbpol               = 1
+    firstvert           = .true.
+    vert(vc)%atti(BPOL) = nbpol
     !
-    ! store next subsequent boundary points in counterclockwise manner
+    nptemp = 0
+    !
+    ! store next subsequent boundary vertices in ascending order
     !
     k     = 1
     iface = 1
@@ -136,7 +167,7 @@
        !
        if ( face(iface)%atti(FMARKER) == 1 ) then
           !
-          if ( k == 1 ) then
+          if ( firstvert ) then
              !
              icell = face(iface)%atti(FACEC1)
              !
@@ -155,6 +186,7 @@
              enddo
              !
              if ( vn == 0 .or. vert(vn)%atti(VMARKER) /= 1 ) goto 10
+             firstvert = .false.
              !
           endif
           !
@@ -163,25 +195,50 @@
           !
           if ( v1 == vc ) then
              !
-             if ( any( v2 == blist ) ) goto 10
+             if ( v2 == vcf ) vc = vcf
+             if ( any( v2 == blistot ) ) goto 10
              !
              k = k + 1
-             blist(k)             = v2
-             vert(v2)%atti(BINDX) = k
+             blistot(k)          = v2
+             vert(v2)%atti(BPOL) = nbpol
              vc = v2
              !
           elseif ( v2 == vc ) then
              !
-             if ( any( v1 == blist ) ) goto 10
+             if ( v1 == vcf ) vc = vcf
+             if ( any( v1 == blistot ) ) goto 10
              !
              k = k + 1
-             blist(k)             = v1
-             vert(v1)%atti(BINDX) = k
+             blistot(k)          = v1
+             vert(v1)%atti(BPOL) = nbpol
              vc = v1
              !
+          elseif ( vc == vcf ) then        ! end of considered boundary polygon is found
+             !
+             if ( any( v1 == blistot ) .and. any( v2 == blistot ) ) goto 10
+             !
+             ! store number of boundary vertices for present polygon
+             !
+             nbpt(nbpol) = k - nptemp
+             nptemp = k
+             !
+             ! take first vertex of next boundary polygon
+             !
+             vc                  = v1
+             vcf                 = vc
+             k = k + 1
+             blistot(k)          = vc
+             nbpol               = nbpol + 1
+             firstvert           = .true.
+             vert(vc)%atti(BPOL) = nbpol
+             !
+             ! give error if more than 100 boundary polygons are found
+             !
+             if ( nbpol > 100 ) call msgerr ( 2, ' More than 100 boundary polygons are found in grid' )
+             !
           endif
           !
-          if ( k == nbpt ) exit faceloop
+          if ( k == nbptot ) exit faceloop
           !
        endif
        !
@@ -191,4 +248,49 @@
        !
     enddo faceloop
     !
+    ! store number of boundary vertices for last polygon
+    !
+    nbpt(nbpol) = nbptot - nptemp
+    !
+    ! check if list contains boundary vertices only
+    !
+    do j = 1, nbptot
+       !
+       vc = blistot(j)
+       if (vert(vc)%atti(VMARKER) /= 1) then
+          write (msgstr, '(a,i4,a)') ' Vertex with index ',vc,' in boundary list is not a valid boundary point'
+          call msgerr( 2, trim(msgstr) )
+       endif
+       !
+    enddo
+    !
+    ! determine maximum number of boundary vertices in set of polygons and allocate blist
+    !
+    maxnbp = maxval(nbpt)
+    !
+    if(.not.allocated(blist)) allocate (blist(maxnbp,nbpol), stat = istat)
+    if ( istat /= 0 ) then
+       call msgerr ( 4, 'Allocation problem in SwanBpntlist: array blist ' )
+       return
+    endif
+    blist = 0
+    !
+    ! fill blist in appropriate manner
+    !
+    k = 0
+    !
+    do j = 1, nbpol
+       !
+       do m = 1, nbpt(j)
+          vc                   = blistot(k+m)
+          blist(m,j)           = vc
+          vert(vc)%atti(BINDX) = m
+       enddo
+       !
+       k = k + nbpt(j)
+       !
+    enddo
+    !
+    deallocate(blistot)
+    !
 end subroutine SwanBpntlist
--- SwanCheckGrid.ftn90	2008-05-25 14:59:40.000000000 +0200
+++ SwanCheckGrid.ftn90	2008-10-15 11:57:41.000000000 +0200
@@ -112,7 +112,7 @@
     !
     badvertex = .false.
     do i = 1, nverts
-       if ( vcount(i) < 4 .and. vmark(i) == 0 ) badvertex = .true.
+       if ( vcount(i) > 0 .and. vcount(i) < 4 .and. vmark(i) == 0 ) badvertex = .true.
        if ( vcount(i) > 10 ) badvertex = .true.
     enddo
     !
--- swancom1.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swancom1.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -388,8 +388,11 @@
 !     PTRIAD    1D    Coefficient for the triad interaction model
 !     PWCAP     1D    Coefficient for the white capping model
 !     PWIND     1D    Coefficient for the wind growth model
+!     SACC0     2D    Represents the mean wave frequency at iter-2
 !     SACC1     2D    Represents the mean wave frequency at iter-1
 !     SACC2     2D    Represents the mean wave frequency at iter
+!     TMDIFC    2D    Represent Tm(iter) - Tm(iter-2) meant for
+!                     computation of curvature of Tm
 !     PWTAIL    1D    coefficients for tail of spectrum
 !     IDCMIN    1D    frequency dependent counter in directional space
 !                     no current <---> current
@@ -814,6 +817,7 @@
 
       REAL, DIMENSION(:), ALLOCATABLE :: HSAC1,HSAC2,SACC1,SACC2          40.22
       REAL, DIMENSION(:), ALLOCATABLE :: HSAC0,HSDIFC                     40.41
+      REAL, DIMENSION(:), ALLOCATABLE :: SACC0,TMDIFC                     40.93
 
       REAL, DIMENSION(:,:), ALLOCATABLE :: SETPDA                         40.41 40.22
 
@@ -878,11 +882,16 @@
       JMAT5 = 5                                                           40.22
       JMAT6 = 6                                                           40.22
       JDIS0 = 7                                                           40.22
-      MSWMATR = 7                                                         40.67
-      JDIS1 = MSWMATR+MDISP                                               40.67 40.22
-      JLEK1 = MSWMATR+2*MDISP                                             40.67 40.22
-      JAOLD = MSWMATR+2*MDISP+1                                           40.67 40.22
-      MSWMATR = MSWMATR+2*MDISP+1                                         40.67 40.61 40.22
+      JDIS1 = JDIS0+MDISP                                                 40.67 40.22
+      JGEN0 = JDIS1+MDISP                                                 40.85
+      JGEN1 = JGEN0+MGENR                                                 40.85
+      JRED0 = JGEN1+MGENR                                                 40.85
+      JRED1 = JRED0+MREDS                                                 40.85
+      JTRA0 = JRED1+MREDS                                                 40.85
+      JTRA1 = JTRA0+MTRNP                                                 40.85
+      JAOLD = JTRA1+MTRNP                                                 40.85 40.67 40.22
+      JLEK1 = JAOLD+1                                                     40.67 40.22
+      MSWMATR = JLEK1                                                     40.85 40.67 40.61 40.22
       JABIN = 1                                                           40.22
       JABLK = 2                                                           40.22
       MLSWMAT = 2                                                         40.22
@@ -912,6 +921,8 @@
       ALLOCATE(SACC2(MCGRD))                                              40.22
       ALLOCATE(HSAC0(MCGRD))                                              40.41
       ALLOCATE(HSDIFC(MCGRD))                                             40.41
+      ALLOCATE(SACC0(MCGRD))                                              40.93
+      ALLOCATE(TMDIFC(MCGRD))                                             40.93
 !
       ALLOCATE(ISLMIN(MCGRD))                                             40.23
       ALLOCATE(NFLIM(MCGRD))                                              40.23
@@ -971,6 +982,8 @@
       SACC2 = 0.                                                          40.31
       HSAC0 = 0.                                                          40.41
       HSDIFC= 0.                                                          40.41
+      SACC0 = 0.                                                          40.93
+      TMDIFC= 0.                                                          40.93
       IF ( IQUAD.GE.3 ) MEMNL4 = 0.                                       40.41 40.31
       IF ( LSETUP.GT.0 ) SETPDA = 0.                                      40.31
 
@@ -1188,7 +1201,8 @@
 !       initialise local (thread private) counter for SIP solver          40.31
         INOCNT = 0                                                        40.31
 !
-!       initialise Dissipation and Leak to 0 for each iteration
+!       initialise propagation, generation, dissipation, redistribution,  40.85
+!       leak and radiation stress for each iteration
 !       this is done in parallel within OpenMP environment                40.31
 !
         DO IP = I1GRD,I2GRD                                               40.31
@@ -1197,6 +1211,16 @@
           COMPDA(IP,JDSXB) = 0.                                           40.61
           COMPDA(IP,JDSXS) = 0.                                           40.61
           COMPDA(IP,JDSXW) = 0.                                           40.61
+          COMPDA(IP,JGENR) = 0.                                           40.85
+          COMPDA(IP,JGSXW) = 0.                                           40.85
+          COMPDA(IP,JREDS) = 0.                                           40.85
+          COMPDA(IP,JRSXQ) = 0.                                           40.85
+          COMPDA(IP,JRSXT) = 0.                                           40.85
+          COMPDA(IP,JTRAN) = 0.                                           40.85
+          COMPDA(IP,JTSXG) = 0.                                           40.85
+          COMPDA(IP,JTSXT) = 0.                                           40.85
+          COMPDA(IP,JTSXS) = 0.                                           40.85
+          COMPDA(IP,JRADS) = 0.                                           40.85
           COMPDA(IP,JQB  ) = 0.                                           40.67
         ENDDO
 !
@@ -1835,10 +1859,11 @@
      &             I1MYC           ,I2MYC                            )    40.31
         ELSE IF (PNUMS(21).EQ.1.) THEN                                    40.41
            CALL SWSTPC ( HSAC0         ,HSAC1           ,HSAC2 ,          40.41
-     &                   SACC1         ,SACC2           ,HSDIFC,          40.41
+     &                   SACC0         ,SACC1           ,SACC2 ,          40.93 40.41
+     &                   HSDIFC        ,TMDIFC          ,                 40.93 40.41
      &                   COMPDA(1,JDHS),COMPDA(1,JDTM)  ,                 40.41
      &                   COMPDA(1,JDP2),ACCUR           ,                 40.41
-     &                   I1MYC         ,I2MYC )                           40.41
+     &                   I1MYC         ,I2MYC           )                 40.93
         END IF                                                            40.41
 !TIMG        CALL SWTSTO(102)                                                  40.23
 !
@@ -1975,6 +2000,8 @@
       DEALLOCATE(SACC2)                                                   40.22
       DEALLOCATE(HSAC0)                                                   40.41
       DEALLOCATE(HSDIFC)                                                  40.41
+      DEALLOCATE(SACC0)                                                   40.93
+      DEALLOCATE(TMDIFC)                                                  40.93
       DEALLOCATE(ISLMIN)                                                  40.23
       DEALLOCATE(NFLIM)                                                   40.23
       DEALLOCATE(NRSCAL)                                                  40.23
@@ -2930,6 +2957,8 @@
      &  WWSWG               ,CGO                 ,COMPDA(1,JUSTAR)    ,
      &  COMPDA(1,JZEL)      ,SPCDIR              ,ANYWND              ,
      &  SWMATR(1,1,JDIS0)   ,SWMATR(1,1,JDIS1)   ,
+     &  SWMATR(1,1,JGEN0)   ,SWMATR(1,1,JGEN1)   ,                        40.85
+     &  SWMATR(1,1,JRED0)   ,SWMATR(1,1,JRED1)   ,                        40.85
      &  XIS                 ,COMPDA(1,JFRC2)     ,IT                  ,   40.00
      &  COMPDA(1,JURSEL)    ,LSWMAT(1,1,JABIN)   ,REFLSO                  40.41 40.03
      &                                                                )   30.21
@@ -2953,7 +2982,7 @@
      &         XCGRID            ,YCGRID            ,                     40.41
      &         ITER              ,KGRPNT            ,OBREDF            ,  40.41
      &         CAX1              ,CAY1              ,SPCDIR            ,  33.08
-     &         CGO                                                        33.08
+     &         CGO               ,SWMATR(1,1,JTRA0) ,SWMATR(1,1,JTRA1)    40.85 33.08
      &                                                                 )
 !TIMG        CALL SWTSTO(118)                                                  40.23
 !
@@ -3051,6 +3080,31 @@
           ENDDO
         END IF
 !
+!       calculate propagation, generation, dissipation, redistribution
+!       leak and radiation stress in present grid point
+!
+!TIMG        CALL SWTSTA(124)                                                  40.23
+        CALL ADDDIS (COMPDA(1,JDISS)    ,COMPDA(1,JLEAK)    ,
+     &               AC2                ,LSWMAT(1,1,JABIN)  ,             40.02
+     &               SWMATR(1,1,JDIS0)  ,SWMATR(1,1,JDIS1)  ,
+     &               SWMATR(1,1,JGEN0)  ,SWMATR(1,1,JGEN1)  ,             40.85
+     &               SWMATR(1,1,JRED0)  ,SWMATR(1,1,JRED1)  ,             40.85
+     &               SWMATR(1,1,JTRA0)  ,SWMATR(1,1,JTRA1)  ,             40.85
+     &               SWMATR(1,1,JMATL)  ,SWMATR(1,1,JMATU)  ,             40.85
+     &               SWMATR(1,1,JMAT5)  ,SWMATR(1,1,JMAT6)  ,             40.85
+     &               COMPDA(1,JDSXB)    ,                                 40.67 40.61
+     &               COMPDA(1,JDSXS)    ,                                 40.67 40.61
+     &               COMPDA(1,JDSXW)    ,                                 40.67 40.61
+     &               COMPDA(1,JGSXW)    ,COMPDA(1,JGENR)    ,             40.85
+     &               COMPDA(1,JRSXQ)    ,COMPDA(1,JRSXT)    ,             40.85
+     &               COMPDA(1,JREDS)    ,                                 40.85
+     &               COMPDA(1,JTSXG)    ,COMPDA(1,JTSXT)    ,             40.85
+     &               COMPDA(1,JTSXS)    ,COMPDA(1,JTRAN)    ,             40.85
+     &               SWMATR(1,1,JLEK1)  ,COMPDA(1,JRADS)    ,             40.85
+     &               SPCSIG                                               30.72
+     &                                                      )
+!TIMG        CALL SWTSTO(124)                                                  40.23
+!
 !       *** if negative action density occur rescale with a factor ***
 !       *** only the sector computed is rescaled !!                ***
 !
@@ -3103,19 +3157,7 @@
           ENDDO
         END IF
 !
-!       calculate Dissipation and Leak in all points
-!
  700    CONTINUE                                                          40.07
-!TIMG        CALL SWTSTA(124)                                                  40.23
-        CALL ADDDIS (COMPDA(1,JDISS)    ,COMPDA(1,JLEAK)    ,
-     &               AC2                ,LSWMAT(1,1,JABIN)  ,             40.02
-     &               SWMATR(1,1,JDIS0)  ,SWMATR(1,1,JDIS1)  ,
-     &               COMPDA(1,JDSXB)    ,                                 40.67 40.61
-     &               COMPDA(1,JDSXS)    ,                                 40.67 40.61
-     &               COMPDA(1,JDSXW)    ,                                 40.67 40.61
-     &               SWMATR(1,1,JLEK1)  ,SPCSIG                           30.72
-     &                                                      )
-!TIMG        CALL SWTSTO(124)                                                  40.23
 !
       END IF
 !
@@ -3271,7 +3313,7 @@
  8510 FORMAT(' The ',A9,                                                  40.41
      &       ' convention for wind and wave directions is used')          40.41
       IF (OPTG.EQ.5) THEN                                                 40.80
-        WRITE(PRINTF,8511) 'Narrow'                                       40.80
+        WRITE(PRINTF,8511) 'BSBT  '                                       40.80
       ELSEIF (PROPSC.EQ.3) THEN                                           40.80 40.41
         WRITE(PRINTF,8511) 'S&L   '                                       40.41
         ICMX = 10                                                         40.41
@@ -4144,7 +4186,7 @@
      &                   XCGRID     ,YCGRID     ,                         40.41
      &                   ITER       ,KGRPNT     ,OBREDF     ,             40.41
      &                   CAX1       ,CAY1       ,SPCDIR     ,             33.08
-     &                   CGO                                              33.08
+     &                   CGO        ,TRAC0      ,TRAC1                    40.85 33.08
      &                                                      )
 !
 !****************************************************************
@@ -4198,6 +4240,7 @@
 !     40.23: Marcel Zijlema
 !     40.28: Annette Kieftenburg
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -4221,6 +4264,7 @@
 !                     with other subroutines
 !     40.41, Aug. 04: call to SWTRCF removed because superfluous
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: add transport for output purposes
 !
 !  2. Purpose
 !
@@ -4367,7 +4411,9 @@
      &         LEAKC1(MDC,MSC)
       REAL  :: RDX(10)             ,RDY(10)             ,                 33.09 40.08
      &         OBREDF(MDC,MSC,2)   ,
-     &         SPCDIR(MDC,6)                                             33.08
+     &         SPCDIR(MDC,6)                                              33.08
+      REAL  :: TRAC0 (1:MDC,1:MSC,1:MTRNP)                                40.85
+      REAL  :: TRAC1 (1:MDC,1:MSC,1:MTRNP)                                40.85
 !
       LOGICAL  ANYBLK(MDC,MSC)     ,ANYBIN(MDC,MSC)
 !
@@ -4394,6 +4440,11 @@
         ENDDO
       ENDDO
 !
+!     *** set all transport coeff at 0 ***
+!
+      TRAC0(1:MDC,1:MSC,1:MTRNP) = 0.                                     40.85
+      TRAC1(1:MDC,1:MSC,1:MTRNP) = 0.                                     40.85
+!
 !TIMG      CALL SWTSTA(140)                                                    40.23
 !
 !     *** Call propagation module in X-Y space  ***
@@ -4402,16 +4453,17 @@
       IF (PROPSL.EQ.3) THEN    ! use S&L scheme
           CALL SANDL(ISSTOP   ,IDCMIN   ,IDCMAX   ,CGO     ,CAX    ,      33.09
      &               CAY      ,AC2      ,AC1      ,IMATRA  ,IMATDA ,      33.09
-     &               RDX      ,RDY      ,CAX1     ,CAY1    ,SPCDIR)       33.09
+     &               RDX      ,RDY      ,CAX1     ,CAY1    ,SPCDIR ,      33.09
+     &               TRAC0    ,TRAC1    )                                 40.85
       ELSE IF (PROPSL.EQ.2) THEN ! use SORDUP scheme                      33.10
          CALL SORDUP(ISSTOP   ,IDCMIN   ,IDCMAX   ,CAX      ,             33.10
      &               CAY      ,AC2      ,IMATRA   ,IMATDA   ,             33.10
-     &               RDX      ,RDY  )                                     33.10
+     &               RDX      ,RDY      ,TRAC0    ,TRAC1    )             40.85 33.10
       ELSE                     ! use BSBT scheme
          CALL STRSXY(ISSTOP   ,IDCMIN   ,IDCMAX   ,CAX      ,             40.00
      &               CAY      ,AC2      ,AC1      ,IMATRA   ,IMATDA   ,
      &                         RDX      ,RDY      ,                       40.00
-     &               OBREDF          )                                    40.00
+     &               OBREDF   ,TRAC0    ,TRAC1    )                       40.85 40.00
 !
       END IF                                                              33.08
 !TIMG      CALL SWTSTO(140)                                                    40.23
@@ -4451,7 +4503,7 @@
           CALL STRSSI (SPCSIG  ,
      &                 CAS     ,IMAT5L  ,IMATDA  ,IMAT6U  ,ANYBIN  ,
      &                 IMATRA  ,AC2     ,ISCMIN  ,ISCMAX  ,IDDLOW  ,
-     &                 IDDTOP                                      )      40.41 30.21
+     &                 IDDTOP  ,TRAC0   ,TRAC1                     )      40.85 40.41 30.21
 !
         ELSE IF ( INT(PNUMS(8)) .EQ. 2 ) THEN
 !
@@ -4477,7 +4529,7 @@
             CALL STRSD (DDIR    ,IDCMIN  ,
      &                  IDCMAX  ,CAD     ,IMATLA  ,IMATDA  ,IMATUA  ,
      &                  IMATRA  ,AC2     ,ISSTOP  ,
-     &                  ANYBIN  ,LEAKC1                             )     40.41 30.21
+     &                  ANYBIN  ,LEAKC1  ,TRAC0   ,TRAC1            )     40.85 40.41 30.21
          ELSE IF ( PROPFL.EQ.1 ) THEN                                     40.23
             CALL SWFLXD (CAD, IMATLA, IMATDA, IMATUA, IMATRA,             40.23
      &                   AC2, DDIR, ANYBIN, LEAKC1, IDCMIN,               40.23
@@ -5368,9 +5420,7 @@
       DO IS = 1, MSC
         DO ID = 1, MDC
           IMATRA(ID,IS) = 0.
-          IMATLA(ID,IS) = 0.
           IMATDA(ID,IS) = 0.
-          IMATUA(ID,IS) = 0.
         ENDDO
       ENDDO
 !
@@ -5701,9 +5751,7 @@
       DO IS = 1, MSC
         DO ID = 1, MDC
           IMATRA(ID,IS) = 0.
-          IMATLA(ID,IS) = 0.
           IMATDA(ID,IS) = 0.
-          IMATUA(ID,IS) = 0.
           ICOLU2(ID)    = 0.
         ENDDO
       ENDDO
@@ -5739,7 +5787,8 @@
      &                     MEMNL4     ,WWINT      ,WWAWG      ,
      &                     WWSWG      ,CGO        ,USTAR      ,
      &                     ZELEN      ,SPCDIR     ,ANYWND     ,
-     &                     DISSC0     ,DISSC1     ,
+     &                     DISSC0     ,DISSC1     ,GENC0      ,           40.85
+     &                     GENC1      ,REDC0      ,REDC1      ,           40.85
      &                     XIS        ,FRCOEF     ,IT         ,           30.00
      &                     URSELL     ,ANYBIN     ,REFLSO                 40.41 40.03
      &                                                        )           30.21
@@ -5802,6 +5851,7 @@
 !     40.41: Andre van der Westhuysen
 !     40.41: Marcel Zijlema
 !     40.61: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -5827,6 +5877,7 @@
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
 !     40.61, Sep. 06: introduction of all separate dissipation coefficients
 !                     for output purposes
+!     40.85, Aug. 08: add generation and redistribition for output purposes
 !
 !  2. Purpose
 !
@@ -6086,6 +6137,10 @@
       REAL  :: ZELEN(MCGRD)
       REAL  :: DISSC0(1:MDC,1:MSC,1:MDISP)                                40.67
       REAL  :: DISSC1(1:MDC,1:MSC,1:MDISP)                                40.67
+      REAL  :: GENC0 (1:MDC,1:MSC,1:MGENR)                                40.85
+      REAL  :: GENC1 (1:MDC,1:MSC,1:MGENR)                                40.85
+      REAL  :: REDC0 (1:MDC,1:MSC,1:MREDS)                                40.85
+      REAL  :: REDC1 (1:MDC,1:MSC,1:MREDS)                                40.85
       REAL  :: URSELL(MCGRD)                                              40.03
       REAL  :: FRCOEF(MCGRD)                                              20.68
       REAL  :: REFLSO(MDC,MSC)                                            40.41
@@ -6115,6 +6170,16 @@
       DISSC0(1:MDC,1:MSC,1:MDISP) = 0.                                    40.67
       DISSC1(1:MDC,1:MSC,1:MDISP) = 0.                                    40.67
 !
+!     *** set all generation coeff at 0 ***
+!
+      GENC0(1:MDC,1:MSC,1:MGENR) = 0.                                     40.85
+      GENC1(1:MDC,1:MSC,1:MGENR) = 0.                                     40.85
+!
+!     *** set all redistribution coeff at 0 ***
+!
+      REDC0(1:MDC,1:MSC,1:MREDS) = 0.                                     40.85
+      REDC1(1:MDC,1:MSC,1:MREDS) = 0.                                     40.85
+!
 !TIMG      CALL SWTSTA(130)                                                    40.23
       IF (IBOT .GE. 1) THEN
 !
@@ -6154,13 +6219,13 @@
      &  CALL SWIND0 (IDCMIN  ,IDCMAX  ,ISSTOP  ,
      &               SPCSIG  ,THETAW  ,ANYWND  ,
      &               UFRIC   ,FPM     ,PLWNDA  ,
-     &               IMATRA  ,SPCDIR  )
+     &               IMATRA  ,SPCDIR  ,GENC0   )
       ENDIF
 !
       IF ( IWIND .EQ. 1 .OR. IWIND .EQ. 2 ) THEN                          970220
 !
          CALL WNDPAR (ISSTOP,IDWMIN,IDWMAX,IDCMIN,IDCMAX,                 32.06
-     &                   DEP2  ,WIND10,                                   32.06
+     &                   DEP2  ,WIND10,GENC0,GENC1,                       40.85 32.06
      &                   THETAW,AC2   ,KWAVE ,IMATRA,IMATDA,              32.06
      &                   SPCSIG,CGO   ,ALIMW ,GROWW ,ETOTW ,              32.06
      &                   PLWNDA,PLWNDB,SPCDIR,ITER            )           32.06
@@ -6170,10 +6235,10 @@
 !
 !       *** Wind input according to Snyder et al (1981) ***
 !
-        CALL SWIND3 (SPCSIG  ,THETAW  ,IMATDA  ,
-     &               KWAVE   ,IMATRA  ,
+        CALL SWIND3 (SPCSIG  ,THETAW  ,
+     &               KWAVE   ,IMATRA  ,GENC0   ,
      &               IDCMIN  ,IDCMAX  ,AC2     ,UFRIC   ,
-     &               FPM     ,PLWNDB  ,ISSTOP  ,SPCDIR  ,ANYWND  )
+     &               FPM     ,PLWNDA  ,ISSTOP  ,SPCDIR  ,ANYWND  )
 !
       ELSE IF ( IWIND .EQ. 4 ) THEN
 !
@@ -6181,9 +6246,9 @@
 !
         CALL SWIND4  (IDWMIN  ,IDWMAX  ,
      &                SPCSIG  ,WIND10  ,THETAW  ,XIS     ,
-     &                DDIR    ,KWAVE   ,IMATRA  ,
+     &                DDIR    ,KWAVE   ,IMATRA  ,GENC0   ,
      &                IDCMIN  ,IDCMAX  ,AC2     ,UFRIC   ,
-     &                PLWNDB  ,ISSTOP  ,ITER    ,USTAR   ,ZELEN   ,
+     &                PLWNDA  ,ISSTOP  ,ITER    ,USTAR   ,ZELEN   ,
      &                SPCDIR  ,ANYWND  ,IT      )
 !
       ELSE IF ( IWIND .EQ. 5 ) THEN
@@ -6192,8 +6257,8 @@
 !
         CALL SWIND5 (SPCSIG  ,THETAW  ,ISSTOP  ,
      &               UFRIC   ,KWAVE   ,IMATRA  ,IDCMIN  ,
-     &               IDCMAX  ,AC2     ,ANYWND  ,PLWNDB  ,
-     &               SPCDIR                             )
+     &               IDCMAX  ,AC2     ,ANYWND  ,PLWNDA  ,
+     &               SPCDIR  ,GENC0                     )
 
       END IF
 !TIMG      CALL SWTSTO(132)                                                    40.23
@@ -6220,14 +6285,14 @@
         IF ( ICUR .EQ. 0 .AND. ITER .GE. 1 ) THEN
 !
             CALL SWLTA ( AC2   , DEP2  , CGO   , SPCSIG,                  40.55
-     &                   KWAVE , IMATRA, IMATDA,
+     &                   KWAVE , IMATRA, IMATDA, REDC0 , REDC1 ,          40.85
      &                   IDDLOW, IDDTOP, ISSTOP, IDCMIN, IDCMAX,
      &                   HS    , SMEBRK, PLTRI , URSELL )
 !
         ELSE IF ( ICUR .EQ. 1 .AND. ITER .GT. 1 ) THEN
 !
             CALL SWLTA ( AC2   , DEP2  , CGO   , SPCSIG,                  40.55
-     &                   KWAVE , IMATRA, IMATDA,
+     &                   KWAVE , IMATRA, IMATDA, REDC0 , REDC1 ,          40.85
      &                   IDDLOW, IDDTOP, ISSTOP, IDCMIN, IDCMAX,
      &                   HS    , SMEBRK, PLTRI , URSELL )
 !
@@ -6264,7 +6329,7 @@
      &                 FACHFR  ,ISSTOP  ,DAL1    ,DAL2    ,DAL3    ,
      &                 SFNL    ,DSNL    ,DEP2    ,AC2     ,IMATDA  ,
      &                 IMATRA  ,PLNL4S  ,PLNL4D                    ,      34.00
-     &                                            IDDLOW  ,IDDTOP  )      34.00
+     &                 IDDLOW  ,IDDTOP  ,REDC0   ,REDC1   )               40.85 34.00
 !
         ELSE IF ( IQUAD .EQ. 2) THEN
 !
@@ -6275,8 +6340,8 @@
      &                 WWAWG   ,UE      ,SA1     ,ISSTOP  ,               40.17
      &                 SA2     ,SPCSIG  ,SNLC1   ,DAL1    ,DAL2    ,      30.72
      &                 DAL3    ,SFNL    ,DEP2    ,AC2     ,KMESPC  ,
-     &                                            IMATDA  ,IMATRA  ,      40.23 34.00
-     &                 FACHFR  ,PLNL4S           ,IDCMIN  ,IDCMAX  )      34.00
+     &                          REDC0   ,REDC1   ,IMATDA  ,IMATRA  ,      40.85 40.23 34.00
+     &                 FACHFR  ,PLNL4S  ,         IDCMIN  ,IDCMAX  )      34.00
 !
         ELSE IF ( IQUAD .EQ. 3) THEN
 !
@@ -6312,7 +6377,7 @@
 !         *** that fall within a sweep and store in right hand vector ***
 !
           CALL FILNL3 (IDCMIN  ,IDCMAX  ,IMATRA  ,IMATDA  ,AC2     ,      40.23
-     &                 MEMNL4  ,PLNL4S  ,ISSTOP                    )      40.41
+     &                 MEMNL4  ,PLNL4S  ,ISSTOP  ,REDC0   ,REDC1   )      40.85 40.41
 
         ELSE IF (IQUAD .EQ. 4) THEN                                       40.17
 
@@ -6341,7 +6406,7 @@
 !         only once per iteration
 
           CALL FILNL3 (IDCMIN  ,IDCMAX  ,IMATRA  ,IMATDA  ,AC2     ,      40.23
-     &                 MEMNL4  ,PLNL4S  ,ISSTOP                    )      40.41
+     &                 MEMNL4  ,PLNL4S  ,ISSTOP  ,REDC0   ,REDC1   )      40.85 40.41
 !
         ELSE IF (IQUAD .EQ. 6) THEN                                       40.17
 
@@ -6434,7 +6499,7 @@
           ENDIF                                                           40.10
 
           CALL FILNL3 (IDCMIN  ,IDCMAX  ,IMATRA  ,IMATDA  ,AC2     ,      40.23
-     &                 MEMNL4  ,PLNL4S  ,ISSTOP                    )      40.41 40.10
+     &                 MEMNL4  ,PLNL4S  ,ISSTOP  ,REDC0   ,REDC1   )      40.85 40.41 40.10
 
           IF (ITEST.GE.30) THEN                                           40.10
             WRITE (PRTEST,*) '+SOURCE: ITER, IQUAD, SWPDIR: ',            40.10
@@ -6474,7 +6539,7 @@
 !         *** that fall within a sweep and store in right hand vector ***
 !
           CALL FILNL3 (IDCMIN  ,IDCMAX  ,IMATRA  ,IMATDA  ,AC2     ,
-     &                 MEMNL4  ,PLNL4S  ,ISSTOP                    )          40.41
+     &                 MEMNL4  ,PLNL4S  ,ISSTOP  ,REDC0   ,REDC1   )      40.85 40.41
 !
         ELSEIF ((IQUAD.EQ.51).OR.(IQUAD.EQ.52).OR.(IQUAD.EQ.53)) THEN     40.41
 !
@@ -6514,7 +6579,7 @@
           ENDIF                                                           40.41
 !
           CALL FILNL3 (IDCMIN  ,IDCMAX  ,IMATRA  ,IMATDA  ,AC2     ,      40.41
-     &                 MEMNL4  ,PLNL4S  ,ISSTOP                    )      40.41
+     &                 MEMNL4  ,PLNL4S  ,ISSTOP  ,REDC0   ,REDC1   )      40.85 40.41
 !
           IF (ITEST.GE.30) THEN                                           40.41
             WRITE (PRTEST,*) '+SOURCE: ITER, IQUAD, SWPDIR, IQERR: ',     40.41
@@ -7629,10 +7694,6 @@
 
       IMATDA = 0.
       IMATRA = 0.
-      IMATLA = 0.
-      IMATUA = 0.
-      IMAT5L = 0.
-      IMAT6U = 0.
 
       RETURN
       END
@@ -8267,9 +8328,9 @@
       END
 !****************************************************************
 !
-      SUBROUTINE SWSTPC ( HSACC0, HSACC1, HSACC2, SACC1 , SACC2,
-     &                    HSDIFC, DELHS , DELTM , DEP2  , ACCUR ,
-     &                    I1MYC , I2MYC )
+      SUBROUTINE SWSTPC ( HSACC0, HSACC1, HSACC2, SACC0 , SACC1,
+     &                    SACC2 , HSDIFC, TMDIFC, DELHS , DELTM,
+     &                    DEP2  , ACCUR , I1MYC , I2MYC )
 !
 !****************************************************************
 !
@@ -8315,23 +8376,25 @@
 !
 !     40.41: Andre van der Westhuysen
 !     40.41: Marcel Zijlema
+!     40.93: Andre van der Westhuysen
 !
 !  1. Updates
 !
 !     40.41, Jun. 04: New subroutine
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.93, Sep. 08: extended with curvature of Tm
 !
 !  2. Purpose
 !
 !     Check convergence based on the relative, absolute
-!     and curvature values of significant wave height
+!     and curvature values of wave height and period
 !
 !  4. Argument variables
 !
 !     ACCUR       indicates percentage of grid points in
 !                 which accuracy is reached
 !     DELHS       difference in Hs between last 2 iterations
-!     DELTM       difference in Tm01 between last 2 iterations
+!     DELTM       difference in Tm between last 2 iterations
 !     DEP2        depth
 !     HSACC0      significant wave height at iter-2
 !     HSACC1      significant wave height at iter-1
@@ -8340,8 +8403,11 @@
 !                 computation of curvature of Hs
 !     I1MYC       lower index for thread loop over y-grid row
 !     I2MYC       upper index for thread loop over y-grid row
+!     SACC0       mean wave frequency at iter-2
 !     SACC1       mean wave frequency at iter-1
 !     SACC2       mean wave frequency at iter
+!     TMDIFC      difference of Tm(i) - Tm(i-2) meant for
+!                 computation of curvature of Tm
 !
       INTEGER I1MYC, I2MYC
       REAL    ACCUR
@@ -8349,11 +8415,13 @@
      &        HSACC0(MCGRD)        ,
      &        HSACC1(MCGRD)        ,
      &        HSACC2(MCGRD)        ,
+     &        SACC0(MCGRD)         ,
      &        SACC1(MCGRD)         ,
      &        SACC2(MCGRD)         ,
      &        DELHS(MCGRD)         ,
      &        DELTM(MCGRD)         ,
-     &        HSDIFC(MCGRD)
+     &        HSDIFC(MCGRD)        ,
+     &        TMDIFC(MCGRD)
 !
 !  6. Local variables
 !
@@ -8378,7 +8446,10 @@
 !     IY1   :     lower index in y-direction
 !     IY2   :     upper index in y-direction
 !     LHEAD :     logical indicating to write header
-!     TMABS :     absolute value of Tm01
+!     TMABS :     absolute value of Tm
+!     TMCURV:     curvature value of Tm
+!     TMDIFO:     previous value of TMDIFC
+!     TMREL :     relative value of Tm
 !     TSTFL :     indicates whether grid point is a test point
 !     WETGRD:     number of wet grid points
 !     XMOM0 :     zeroth moment
@@ -8387,7 +8458,7 @@
       INTEGER ID, IS, IENT, II, INDX, IX, IY, IX1, IX2, IY1, IY2
       INTEGER IACCUR, WETGRD, IACCURt, WETGRDt, IARR(2)
       REAL    ACS2, ACS3, HSREL ,HSABS, HSCURV, HSDIFO, TMABS,
-     &        XMOM0, XMOM1
+     &        TMREL, TMCURV, TMDIFO, XMOM0, XMOM1
       LOGICAL LHEAD, TSTFL
 !
 !  7. Common blocks used
@@ -8417,7 +8488,7 @@
 !     store Hs and Tm as old values and count number of wet grid points
 !     compute new values of Hs and Tm
 !     calculate a set of accuracy parameters based on relative,
-!         absolute and curvature values of Hs and check accuracy
+!         absolute and curvature values of Hs, Tm and check accuracy
 !     global sum of IACCUR and WETGRD
 !     carry out reductions across all nodes
 !
@@ -8464,11 +8535,13 @@
             IF ( DEP2(INDX).GT.DEPMIN ) THEN
                HSACC0(INDX) = MAX( 1.E-20 , HSACC1(INDX) )
                HSACC1(INDX) = MAX( 1.E-20 , HSACC2(INDX) )
+               SACC0 (INDX) = MAX( 1.E-20 , SACC1 (INDX) )                40.93
                SACC1 (INDX) = MAX( 1.E-20 , SACC2 (INDX) )
                WETGRDt = WETGRDt + 1
             ELSE
                HSACC0(INDX) = 0.
                HSACC1(INDX) = 0.
+               SACC0 (INDX) = 0.                                          40.93
                SACC1 (INDX) = 0.
             END IF
          END DO
@@ -8536,11 +8609,16 @@
                HSABS = ABS ( HSACC2(INDX) - HSACC1(INDX) )
                HSREL = HSABS / HSACC2(INDX)
                TMABS = ABS ( (PI2/SACC2(INDX)) - (PI2/SACC1(INDX)) )
+               TMREL = TMABS / SACC2(INDX)                                40.93
 
                HSDIFO       = HSDIFC(INDX)
                HSDIFC(INDX) = 0.5*( HSACC2(INDX) - HSACC0(INDX) )
                HSCURV       = ABS(HSDIFC(INDX) - HSDIFO)/HSACC2(INDX)
 
+               TMDIFO       = TMDIFC(INDX)                                40.93
+               TMDIFC(INDX) = 0.5*( SACC2(INDX) - SACC0(INDX) )           40.93
+               TMCURV       = ABS(TMDIFC(INDX) - TMDIFO)/SACC2(INDX)      40.93
+
                DELHS(INDX) = HSABS
                IF (EQREAL(SACC1(INDX),1.E-20) .OR.
      &             EQREAL(SACC2(INDX),1.E-20) ) THEN
@@ -8549,21 +8627,26 @@
                   DELTM(INDX) = TMABS
                END IF
 
-!              --- add gridpoint in which wave height has reached
-!                  required accuracy
+!              --- add gridpoint in which wave height and period have
+!                  reached required accuracy
 
-               IF ( HSCURV.LE.PNUMS(15) .AND.
-     &             (HSREL.LE.PNUMS(1) .OR. HSABS.LE.PNUMS(2)) ) THEN
+               IF ( ( HSCURV.LE.PNUMS(15) .AND.
+     &               (HSREL.LE.PNUMS(1) .OR. HSABS.LE.PNUMS(2)) ) .AND.   40.93
+     &              ( TMCURV.LE.PNUMS(15) .AND.                           40.93
+     &               (TMREL.LE.PNUMS(1) .OR. TMABS.LE.PNUMS(2)) ) ) THEN  40.93
                   IACCURt = IACCURt + 1
                END IF
 
                IF (TSTFL) THEN
                   IF (LHEAD) WRITE(PRINTF,501)
                   WRITE(PRINTF,502) IX+MXF-2, IY+MYF-2, HSABS, HSREL,
-     &                              HSCURV
+     &                              HSCURV, TMABS, TMREL, TMCURV          40.93
  501              FORMAT(25X,'dHabs          ','dHrel          ',
-     &                       'Curvature ')
+     &                       'Curvature H    ',                           40.93
+     &                       'dTabs          ','dTrel          ',         40.93
+     &                       'Curvature T    ')                           40.93
  502              FORMAT(1X,SS,'(IX,IY)=(',I5,',',I5,')','  ',
+     &                   1PE13.6E2,'  ',1PE13.6E2,'  ',1PE13.6E2,'  ',    40.93
      &                   1PE13.6E2,'  ',1PE13.6E2,'  ',1PE13.6E2)
                   LHEAD=.FALSE.
                END IF
--- swancom2.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swancom2.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -1877,14 +1877,13 @@
 !
 !             *** nonlinear interactions ***
 !
-              TRIA = TRIA + ABS(PLTRI (ID,IS,IPTST) * SPCSIG(IS))         40.00
-!
+              TRIA = TRIA + ABS(PLTRI (ID,IS,IPTST)) * SPCSIG(IS)**2      40.85 40.00
 !
               IF ( IQUAD .EQ. 1) THEN
                 NL4  = NL4  + ABS(PLNL4D(ID,IS,IPTST) * SIG2AC +
-     &                            PLNL4S(ID,IS,IPTST) * SPCSIG(IS))       40.00
+     &                            PLNL4S(ID,IS,IPTST) * SPCSIG(IS)**2)    40.85 40.00
               ELSE
-                NL4  = NL4  + ABS(PLNL4S(ID,IS,IPTST) * SPCSIG(IS))       40.00
+                NL4  = NL4  + ABS(PLNL4S(ID,IS,IPTST)) * SPCSIG(IS)**2    40.85 40.00
               END IF
 !
   50        CONTINUE
--- swancom3.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swancom3.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -28,7 +28,7 @@
 !****************************************************************
 !
       SUBROUTINE WNDPAR (ISSTOP,IDWMIN,IDWMAX,IDCMIN,IDCMAX,              32.06
-     &                   DEP2  ,WIND10,                                   32.06
+     &                   DEP2  ,WIND10,GENC0 ,GENC1 ,                     40.85 32.06
      &                   THETAW,AC2   ,KWAVE ,IMATRA,IMATDA,              32.06
      &                   SPCSIG,CGO   ,ALIMW ,GROWW ,ETOTW ,              32.06
      &                   PLWNDA,PLWNDB,SPCDIR,ITER            )           32.06
@@ -80,6 +80,7 @@
 !     32.06: Roeland Ris
 !     40.00: Nico Booij (Nonstationary boundary conditions)
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -94,6 +95,7 @@
 !     30.82, June 99: Implicit none added; all variables declared
 !     40.41, Aug. 04: COS(THETA-THETAW) replaced by sumrule to make it cheaper
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store wind input for output purposes
 !
 !  2. Purpose
 !
@@ -328,6 +330,8 @@
       REAL  :: KWAVE(MSC,MICMAX)                                          40.22
       REAL  :: PLWNDA(MDC,MSC,NPTST)                                      40.00
       REAL  :: PLWNDB(MDC,MSC,NPTST)
+      REAL  :: GENC0(MDC,MSC,MGENR)                                       40.85
+      REAL  :: GENC1(MDC,MSC,MGENR)                                       40.85
       REAL  :: DEP2(MCGRD)
 !     Changed ICMAX to MICMAX, since MICMAX doesn't vary over gridpoint   40.22
       REAL  :: CGO(MSC,MICMAX)                                            40.22
@@ -495,12 +499,13 @@
           IMATDA(ID,IS) = IMATDA(ID,IS) - SWIND_IMP
           IF (TESTFL) PLWNDA(ID,IS,IPTST) = SWIND_EXP                     40.13
           IF (TESTFL) PLWNDB(ID,IS,IPTST) = SWIND_IMP                     40.13
-!
+          GENC0(ID,IS,1) = GENC0(ID,IS,1) + SWIND_EXP                     40.85
+          GENC1(ID,IS,1) = GENC1(ID,IS,1) + SWIND_IMP                     40.85
 !
 !         *** test output ***
 !
 !         Value of ITEST changed from 10 to 110 to reduce test output     40.13
-          IF ( TESTFL .AND. ITEST .GE. 110 ) THEN                        40.13
+          IF ( TESTFL .AND. ITEST .GE. 110 ) THEN                         40.13
             WRITE(PRINTF,2004) IS, ID, GROWW(ID,IS), ADUM, BDUM           40.13
  2004       FORMAT(' WNDPAR: IS ID GROWW ADUM BDUM     :',                40.13
      &             2I3,2X,L1,2X,2E12.4)
@@ -1312,7 +1317,7 @@
       SUBROUTINE SWIND0 (IDCMIN  ,IDCMAX  ,ISSTOP  ,
      &                   SPCSIG  ,THETAW  ,ANYWND  ,
      &                   UFRIC   ,FPM     ,PLWNDA  ,
-     &                   IMATRA  ,SPCDIR           )
+     &                   IMATRA  ,SPCDIR  ,GENC0   )
 !
 !****************************************************************
 !
@@ -1355,6 +1360,7 @@
 !     30.72: IJsbrand Haagsma
 !     30.82: IJsbrand Haagsma
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -1362,6 +1368,7 @@
 !     30.82, Oct. 98: Updated description of several variables
 !     40.41, Aug. 04: COS(THETA-THETAW) replaced by sumrule to make it cheaper
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store wind input for output purposes
 !
 !  2. PURPOSE
 !
@@ -1418,7 +1425,7 @@
 !        ---------
 !        FPM         Pierson Moskowitz frequecy (WAM)
 !        GRAV        Gravitatiuonal acceleration
-!        SWINEO      Coefficient stored in IMATDA
+!        SWINEO      Coefficient stored in IMATRA
 !        THETA       Spectral direction
 !        THETAW      Mean direction of the relative wind vector
 !        UFRIC       Wind friction velocity
@@ -1473,6 +1480,7 @@
 !
       REAL    IMATRA(MDC,MSC)      ,
      &        PLWNDA(MDC,MSC,NPTST)                                       40.00
+      REAL    GENC0(MDC,MSC,MGENR)                                        40.85
 !
       INTEGER IDCMIN(MSC)          ,
      &        IDCMAX(MSC)
@@ -1507,7 +1515,8 @@
             TEMP3  = ( UFRIC *  MAX( 0. , COSDIF))**4                     40.41
             SWINEA = MAX( 0. , TEMP2 * TEMP3 * FILTER )
             IMATRA(ID,IS) = IMATRA(ID,IS) + SWINEA
-            IF(TESTFL) PLWNDA(ID,IS,IPTST) = SWINEA                       40.00
+            IF(TESTFL) PLWNDA(ID,IS,IPTST) = SWINEA/SIGMA                 40.85 40.00
+            GENC0(ID,IS,1) = GENC0(ID,IS,1) + SWINEA/SIGMA                40.85
 !
 !           *** test output ***
 !
@@ -1544,10 +1553,10 @@
 !
 !****************************************************************
 !
-      SUBROUTINE SWIND3 (SPCSIG  ,THETAW  ,IMATDA  ,
-     &                   KWAVE   ,IMATRA  ,
+      SUBROUTINE SWIND3 (SPCSIG  ,THETAW  ,
+     &                   KWAVE   ,IMATRA  ,GENC0   ,
      &                   IDCMIN  ,IDCMAX  ,AC2     ,UFRIC   ,
-     &                   FPM     ,PLWNDB  ,ISSTOP  ,SPCDIR  ,ANYWND)
+     &                   FPM     ,PLWNDA  ,ISSTOP  ,SPCDIR  ,ANYWND)
 !
 !****************************************************************
 !
@@ -1590,6 +1599,7 @@
 !     30.72: IJsbrand Haagsma
 !     30.82: IJsbrand Haagsma
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -1597,6 +1607,7 @@
 !     30.82, Oct. 98: Updated description of several variables
 !     40.41, Aug. 04: COS(THETA-THETAW) replaced by sumrule to make it cheaper
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store wind input for output purposes
 !
 !  2. PURPOSE
 !
@@ -1666,7 +1677,6 @@
 !        KWAVE     2D    Wavenumber
 !        LOGSIG    1D    Logaritmic distribution of frequency
 !        IMATRA    2D    Coefficients of right hand side of matrix
-!        IMATDA    2D    Coefficients of diagonal of matrix
 !        PWIND     1D    Wind coefficients
 !        IDCMIN    1D    Frequency dependent counter
 !        IDCMAX    1D    Frequency dependent counter
@@ -1711,10 +1721,10 @@
      &         TEMP2 ,TEMP3 ,CINV
 !
       REAL    AC2(MDC,MSC,MCGRD)   ,
-     &        IMATDA(MDC,MSC)      ,
      &        IMATRA(MDC,MSC)      ,
      &        KWAVE(MSC,ICMAX)     ,
-     &        PLWNDB(MDC,MSC,NPTST)                                       40.00
+     &        PLWNDA(MDC,MSC,NPTST)                                       40.00
+      REAL  :: GENC0(MDC,MSC,MGENR)                                       40.85
 !
       INTEGER IDCMIN(MSC)          ,
      &        IDCMAX(MSC)
@@ -1744,7 +1754,8 @@
             SWINEB = MAX ( 0. , SWINEB * SIGMA )
 !
             IMATRA(ID,IS) = IMATRA(ID,IS) + SWINEB * AC2(ID,IS,KCGRD(1))
-            IF (TESTFL) PLWNDB(ID,IS,IPTST) = SWINEB                      40.00
+            IF (TESTFL) PLWNDA(ID,IS,IPTST) = SWINEB*AC2(ID,IS,KCGRD(1))  40.85 40.00
+            GENC0(ID,IS,1) = GENC0(ID,IS,1) + SWINEB*AC2(ID,IS,KCGRD(1))  40.85
 !
           END IF
         ENDDO
@@ -1760,7 +1771,7 @@
      &         '  IS ID1 ID2       Wind source term')
         DO IS = 1, MSC
           WRITE(PRTEST,6200) IS, IDCMIN(IS), IDCMAX(IS),
-     &    (PLWNDB(ID,IS,IPTST), ID=IDCMIN(IS), IDCMAX(IS))
+     &    (PLWNDA(ID,IS,IPTST), ID=IDCMIN(IS), IDCMAX(IS))
  6200     FORMAT(3I4, 600e12.4)
         ENDDO
         WRITE(PRTEST,*)
@@ -1774,9 +1785,9 @@
 !
       SUBROUTINE SWIND4 (IDWMIN  ,IDWMAX  ,
      &                   SPCSIG  ,WIND10  ,THETAW  ,XIS     ,
-     &                   DD      ,KWAVE   ,IMATRA  ,
+     &                   DD      ,KWAVE   ,IMATRA  ,GENC0   ,
      &                   IDCMIN  ,IDCMAX  ,AC2     ,UFRIC   ,
-     &                   PLWNDB  ,ISSTOP  ,ITER    ,USTAR   ,ZELEN   ,
+     &                   PLWNDA  ,ISSTOP  ,ITER    ,USTAR   ,ZELEN   ,
      &                   SPCDIR  ,ANYWND  ,IT               )
 !
 !******************************************************************
@@ -1824,6 +1835,7 @@
 !     40.31: Tim Campbell and John Cazes
 !     40.41: Marcel Zijlema
 !     40.61: Roop Lalbeharry
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -1834,6 +1846,7 @@
 !     40.41, Aug. 04: COS(THETA-THETAW) replaced by sumrule to make it cheaper
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
 !     40.61, Nov. 06: improvements to WAM4 based on WAM4.5
+!     40.85, Aug. 08: store wind input for output purposes
 !
 !  2. Purpose
 !
@@ -1886,7 +1899,7 @@
 !        ---------
 !        DD          Directional band width
 !        GRAV        Gravitational acceleration
-!        SWINEO      Coefficient stored in IMATDA
+!        SWINEO      Coefficient stored in IMATRA
 !        THETA       Spectral direction
 !        THETAW      Mean direction of the relative wind vector
 !        WIND10      Velocity of the relative wind vector
@@ -1897,7 +1910,6 @@
 !        ---------------------------------
 !        KWAVE     2D    Wavenumber
 !        IMATRA    2D    Coefficients of right hand side of matrix
-!        IMATDA    2D    Coefficients of diagonal of matrix
 !        PWIND     1D    Wind coefficients
 !        IDCMIN    1D    Frequency dependent counter
 !        IDCMAX    1D    Frequency dependent counter
@@ -1959,9 +1971,10 @@
       REAL    AC2(MDC,MSC,MCGRD)   ,                                      30.21
      &        IMATRA(MDC,MSC)      ,
      &        KWAVE(MSC,ICMAX)     ,
-     &        PLWNDB(MDC,MSC,NPTST),
+     &        PLWNDA(MDC,MSC,NPTST),
      &        USTAR(MCGRD)         ,
      &        ZELEN(MCGRD)
+      REAL    GENC0(MDC,MSC,MGENR)                                        40.85
 !
       INTEGER IDCMIN(MSC)          ,
      &        IDCMAX(MSC)
@@ -2277,7 +2290,8 @@
 !
             SWINEB = RHOAW * BETA * XFAC2 * COS2 * SIGMA
             IMATRA(ID,IS) = IMATRA(ID,IS) + SWINEB * AC2(ID,IS,KCGRD(1))  30.21
-            IF (TESTFL) PLWNDB(ID,IS,IPTST) = SWINEB                      40.00
+            IF (TESTFL) PLWNDA(ID,IS,IPTST) = SWINEB*AC2(ID,IS,KCGRD(1))  40.85 40.00
+            GENC0(ID,IS,1) = GENC0(ID,IS,1) + SWINEB*AC2(ID,IS,KCGRD(1))  40.85
 !
 !           *** test output ***
 !
@@ -2319,8 +2333,8 @@
 !
       SUBROUTINE SWIND5 (SPCSIG  ,THETAW  ,ISSTOP  ,
      &                   UFRIC   ,KWAVE   ,IMATRA  ,IDCMIN  ,
-     &                   IDCMAX  ,AC2     ,ANYWND  ,PLWNDB  ,
-     &                   SPCDIR                             )
+     &                   IDCMAX  ,AC2     ,ANYWND  ,PLWNDA  ,
+     &                   SPCDIR  ,GENC0                     )
 !
 !****************************************************************
 !
@@ -2364,6 +2378,7 @@
 !     30.82: IJsbrand Haagsma
 !     40.41: Marcel Zijlema
 !     40.53: Andre van der Westhuysen
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -2373,6 +2388,7 @@
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
 !     40.53, Aug. 04: changes parameters of Yan formulae in case of Alves and
 !                     Banner whitecapping method
+!     40.85, Aug. 08: store wind input for output purposes
 !
 ! 2. Purpose
 !
@@ -2426,7 +2442,6 @@
 !        ---------------------------------
 !        KWAVE     2D    Wavenumber
 !        IMATRA    2D    Coefficients of right hand side of matrix
-!        IMATDA    2D    Coefficients of diagonal of matrix
 !        IDCMIN    1D    Frequency dependent counter
 !        IDCMAX    1D    Frequency dependent counter
 !        ANYWND    1D    Wind input for bin considered
@@ -2472,7 +2487,8 @@
       REAL    AC2(MDC,MSC,MCGRD)   ,
      &        IMATRA(MDC,MSC)      ,
      &        KWAVE(MSC,ICMAX)     ,
-     &        PLWNDB(MDC,MSC,NPTST)
+     &        PLWNDA(MDC,MSC,NPTST)
+      REAL    GENC0(MDC,MSC,MGENR)                                        40.85
 !
       INTEGER IDCMIN(MSC)          ,
      &        IDCMAX(MSC)
@@ -2514,7 +2530,8 @@
             SWINEB = TEMP3 * COSDIF - COF4                                40.41
             SWINEB = MAX ( 0. , SWINEB * SIGMA )
             IMATRA(ID,IS) = IMATRA(ID,IS) + SWINEB * AC2(ID,IS,KCGRD(1))
-            IF (TESTFL) PLWNDB(ID,IS,IPTST) = SWINEB                      40.00
+            IF (TESTFL) PLWNDA(ID,IS,IPTST) = SWINEB*AC2(ID,IS,KCGRD(1))  40.85 40.00
+            GENC0(ID,IS,1) = GENC0(ID,IS,1) + SWINEB*AC2(ID,IS,KCGRD(1))  40.85
           END IF
         ENDDO
       ENDDO
--- swancom4.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swancom4.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -685,7 +685,7 @@
      &                   FACHFR  ,ISSTOP  ,DAL1    ,DAL2    ,DAL3    ,
      &                   SFNL    ,DSNL    ,DEP2    ,AC2     ,IMATDA  ,
      &                   IMATRA  ,PLNL4S  ,PLNL4D  ,                      34.00
-     &                   IDDLOW  ,IDDTOP  )                               34.00
+     &                   IDDLOW  ,IDDTOP  ,REDC0   ,REDC1   )             40.85 34.00
 !
 !********************************************************************
 !
@@ -730,6 +730,7 @@
 !     40.17: IJsbrand Haagsma
 !     40.23: Marcel Zijlema
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -737,6 +738,7 @@
 !     40.17, Dec. 01: Implentation of Multiple DIA
 !     40.23, Aug. 02: some corrections
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store quadruplets for output purposes
 !
 !  2. Purpose
 !
@@ -895,6 +897,8 @@
      &          PLNL4D(MDC,MSC,NPTST)                 ,
      &          WWAWG(*)                              ,
      &          WWSWG(*)
+      REAL :: REDC0 (MDC,MSC,MREDS)                                       40.85
+      REAL :: REDC1 (MDC,MSC,MREDS)                                       40.85
 !
       INTEGER   IDCMIN(MSC)        ,
      &          IDCMAX(MSC)        ,
@@ -1123,8 +1127,10 @@
 !
           IF(TESTFL) THEN
             PLNL4S(ID,I,IPTST) = SFNL(I,ID) / SIGPI                       40.00
-            PLNL4D(ID,I,IPTST) = -1. * DSNL(I,ID) / PI3                   40.00
+            PLNL4D(ID,I,IPTST) = DSNL(I,ID) / PI3                         40.85 40.00
           END IF
+          REDC0(ID,I,1) = REDC0(ID,I,1) + SFNL(I,ID) / SIGPI              40.85
+          REDC1(ID,I,1) = REDC1(ID,I,1) + DSNL(I,ID) / PI3                40.85
 !
           IMATRA(ID,I) = IMATRA(ID,I) + SFNL(I,ID) / SIGPI
           IMATDA(ID,I) = IMATDA(ID,I) - DSNL(I,ID) / PI3
@@ -1176,8 +1182,8 @@
      &                   WWAWG   ,UE      ,SA1     ,ISSTOP  ,             40.17
      &                   SA2     ,SPCSIG  ,SNLC1   ,DAL1    ,DAL2    ,    30.72
      &                   DAL3    ,SFNL    ,DEP2    ,AC2     ,KMESPC  ,
-     &                                              IMATDA  ,IMATRA  ,    40.23 34.00
-     &                   FACHFR  ,PLNL4S           ,IDCMIN  ,IDCMAX  )    34.00
+     &                            REDC0   ,REDC1   ,IMATDA  ,IMATRA  ,    40.85 40.23 34.00
+     &                   FACHFR  ,PLNL4S  ,         IDCMIN  ,IDCMAX  )    34.00
 !
 !*******************************************************************
 !
@@ -1222,6 +1228,7 @@
 !     40.17: IJsbrand Haagsma
 !     40.23: Marcel Zijlema
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -1229,6 +1236,7 @@
 !     40.17, Dec. 01: Implemented Multiple DIA
 !     40.23, Aug. 02: rhs and main diagonal adjusted according to Patankar-rules
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store quadruplets for output purposes
 !
 !  2. Purpose
 !
@@ -1342,6 +1350,8 @@
      &          IMATDA(MDC,MSC)                       ,                   40.23
      &          PLNL4S(MDC,MSC,NPTST)                 ,                   40.00
      &          WWAWG(*)
+      REAL :: REDC0 (MDC,MSC,MREDS)                                       40.85
+      REAL :: REDC1 (MDC,MSC,MREDS)                                       40.85
 !
       INTEGER   WWINT(*)         ,
      &          IDCMIN(MSC)      ,
@@ -1527,9 +1537,12 @@
           IF(TESTFL) PLNL4S(ID,I,IPTST) =  SFNL(I,ID) / SIGPI             40.00
           IF (SFNL(I,ID).GT.0.) THEN                                      40.23
              IMATRA(ID,I) = IMATRA(ID,I) + SFNL(I,ID) / SIGPI
+             REDC0(ID,I,1)= REDC0(ID,I,1)+ SFNL(I,ID) / SIGPI             40.85
           ELSE
              IMATDA(ID,I) = IMATDA(ID,I) - SFNL(I,ID) /
      &                      MAX(1.E-18,AC2(ID,I,KCGRD(1))*SIGPI)
+             REDC1(ID,I,1)= REDC1(ID,I,1)+ SFNL(I,ID) /                   40.85
+     &                      MAX(1.E-18,AC2(ID,I,KCGRD(1))*SIGPI)          40.85
           END IF
 !
         ENDDO
@@ -2660,7 +2673,7 @@
 !*******************************************************************
 !
       SUBROUTINE FILNL3 (IDCMIN  ,IDCMAX  ,IMATRA  ,IMATDA  ,AC2     ,    40.23
-     &                   MEMNL4  ,PLNL4S  ,ISSTOP                    )    40.41
+     &                   MEMNL4  ,PLNL4S  ,ISSTOP  ,REDC0   ,REDC1   )    40.85 40.41
 !
 !*******************************************************************
 !
@@ -2702,11 +2715,13 @@
 !
 !     40.23: Marcel Zijlema
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
 !     40.23, Aug. 02: rhs and main diagonal adjusted according to Patankar-rules
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store quadruplets for output purposes
 !
 !  2. Purpose
 !
@@ -2752,6 +2767,8 @@
 !
       INTEGER   IDCMIN(MSC)         ,
      &          IDCMAX(MSC)
+      REAL ::   REDC0 (MDC,MSC,MREDS)                                     40.85
+      REAL ::   REDC1 (MDC,MSC,MREDS)                                     40.85
 !
       SAVE IENT
       DATA IENT/0/
@@ -2763,9 +2780,12 @@
           IF(TESTFL) PLNL4S(ID,IS,IPTST) = MEMNL4(ID,IS,KCGRD(1))         40.00
           IF (MEMNL4(ID,IS,KCGRD(1)).GT.0.) THEN                          40.23
              IMATRA(ID,IS) = IMATRA(ID,IS) + MEMNL4(ID,IS,KCGRD(1))
+             REDC0(ID,IS,1)= REDC0(ID,IS,1)+ MEMNL4(ID,IS,KCGRD(1))       40.85
           ELSE
              IMATDA(ID,IS) = IMATDA(ID,IS) - MEMNL4(ID,IS,KCGRD(1)) /
      &                       MAX(1.E-18,AC2(ID,IS,KCGRD(1)))
+             REDC1(ID,IS,1)= REDC1(ID,IS,1)+ MEMNL4(ID,IS,KCGRD(1)) /     40.85
+     &                       MAX(1.E-18,AC2(ID,IS,KCGRD(1)))              40.85
           END IF
   980   CONTINUE
   990 CONTINUE
@@ -3719,7 +3739,7 @@
 !****************************************************************
 !
       SUBROUTINE SWLTA ( AC2   , DEP2  , CGO   , SPCSIG,
-     &                   KWAVE , IMATRA, IMATDA,
+     &                   KWAVE , IMATRA, IMATDA, REDC0 , REDC1 ,
      &                   IDDLOW, IDDTOP, ISSTOP, IDCMIN, IDCMAX,
      &                   HS    , SMEBRK, PLTRI , URSELL )
 !
@@ -3765,10 +3785,12 @@
 !  0. Authors
 !
 !     40.55: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
 !     40.55, Feb. 06: New subroutine
+!     40.85, Aug. 08: store triads for output purposes
 !
 !  2. Purpose
 !
@@ -3867,6 +3889,8 @@
       REAL :: KWAVE(MSC,MICMAX)
       REAL :: PLTRI(MDC,MSC,NPTST)
       REAL :: URSELL(MCGRD)
+      REAL :: REDC0 (MDC,MSC,MREDS)                                       40.85
+      REAL :: REDC1 (MDC,MSC,MREDS)                                       40.85
 !
 !  6. Local variables
 !
@@ -4043,9 +4067,12 @@
               IF(TESTFL) PLTRI(ID,IS,IPTST) = STRI / SIGPI
               IF (STRI.GT.0.) THEN
                  IMATRA(ID,IS) = IMATRA(ID,IS) + STRI / SIGPI
+                 REDC0(ID,IS,2)= REDC0(ID,IS,2)+ STRI / SIGPI             40.85
               ELSE
                  IMATDA(ID,IS) = IMATDA(ID,IS) - STRI /
      &                           MAX(1.E-18,AC2(ID,IS,KCGRD(1))*SIGPI)
+                 REDC1(ID,IS,2)= REDC1(ID,IS,2)+ STRI /                   40.85
+     &                           MAX(1.E-18,AC2(ID,IS,KCGRD(1))*SIGPI)    40.85
               END IF
            END DO
         END DO
--- swancom5.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swancom5.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -2105,7 +2105,7 @@
       SUBROUTINE STRSXY (         ISSTOP  ,IDCMIN  ,IDCMAX  ,CAX     ,
      &                   CAY     ,AC2     ,AC1     ,IMATRA  ,IMATDA  ,
      &                            RDX     ,RDY     ,                      33.09
-     &                   OBREDF         )
+     &                   OBREDF  ,TRAC0   ,TRAC1   )
 !
 !****************************************************************
 !
@@ -2152,6 +2152,7 @@
 !        33.09: Nico Booij (changes related to spherical coordinates)
 !        40.08: Erick Rogers
 !        40.41: Marcel Zijlema
+!        40.85: Marcel Zijlema
 !
 !     1. UPDATE
 !
@@ -2165,6 +2166,7 @@
 !                        modified; introduction of spherical coordinates
 !        40.08, Mar. 03: Removed artifact from code
 !        40.41, Oct. 04: common blocks replaced by modules, include files removed
+!        40.85, Aug. 08: store xy-propagation for output purposes
 !
 !     2. PURPOSE
 !
@@ -2270,6 +2272,8 @@
      &         RDX(10)            ,RDY(10)                    ,           40.08
      &         TRSCF(3)            ,                                      33.09
      &         OBREDF(MDC,MSC,2)                                         040697
+      REAL  :: TRAC0(MDC,MSC,MTRNP)                                       40.85
+      REAL  :: TRAC1(MDC,MSC,MTRNP)                                       40.85
 !
       INTEGER  IDCMIN(MSC)                ,
      &         IDCMAX(MSC)                                                33.09
@@ -2354,9 +2358,13 @@
             ENDIF
             IMATRA(ID,IS) = IMATRA(ID,IS) + FXY2 + ACOLD*RDTIM            33.09
             IMATDA(ID,IS) = IMATDA(ID,IS) + FXY1 + RDTIM                  33.09
+            TRAC0(ID,IS,1) = TRAC0(ID,IS,1) - FXY2 - ACOLD*RDTIM          40.85
+            TRAC1(ID,IS,1) = TRAC1(ID,IS,1) + FXY1 + RDTIM                40.85
           ELSE
             IMATRA(ID,IS) = IMATRA(ID,IS) + FXY2
             IMATDA(ID,IS) = IMATDA(ID,IS) + FXY1
+            TRAC0(ID,IS,1) = TRAC0(ID,IS,1) - FXY2                        40.85
+            TRAC1(ID,IS,1) = TRAC1(ID,IS,1) + FXY1                        40.85
           ENDIF
 !         --- Using an if statement like this--in conjunction with        40.08
 !             inclusion of all directions in calculation, i.e. non-use    40.08
@@ -2404,7 +2412,7 @@
 !
       SUBROUTINE SORDUP (         ISSTOP  ,IDCMIN  ,IDCMAX  ,CAX     ,
      &                   CAY     ,AC2     ,IMATRA  ,IMATDA  ,
-     &                            RDX     ,RDY     )                      33.10
+     &                            RDX     ,RDY     ,TRAC0   ,TRAC1   )    40.85 33.10
 !
 !****************************************************************
 !
@@ -2450,6 +2458,7 @@
 !        33.09: Nico Booij (changes related to spherical coordinates)
 !        40.08: Erick Rogers
 !        40.41: Marcel Zijlema
+!        40.85: Marcel Zijlema
 !
 !     1. UPDATE
 !
@@ -2463,6 +2472,7 @@
 !                          Remove option for controllable 1st order diffusion ("MUXY",
 !                          "THETAK", etc.)
 !        40.41, Oct. 04: common blocks replaced by modules, include files removed
+!        40.85, Aug. 08: store xy-propagation for output purposes
 !
 !     2. PURPOSE
 !
@@ -2570,6 +2580,8 @@
       REAL  :: IMATRA(MDC,MSC)    ,IMATDA(MDC,MSC)            ,
      &         RDX(10)            ,RDY(10)                                40.08
      &         ,XMU(6),YMU(6)                                             40.08 33.10
+      REAL  :: TRAC0(MDC,MSC,MTRNP)                                       40.85
+      REAL  :: TRAC1(MDC,MSC,MTRNP)                                       40.85
 
       INTEGER  IDCMIN(MSC), IDCMAX(MSC), IENT, IXY                        33.10
       LOGICAL  XNUM                                                       33.10
@@ -2707,6 +2719,8 @@
 !          ENDIF
           IMATRA(ID,IS) = IMATRA(ID,IS) + FXY2
           IMATDA(ID,IS) = IMATDA(ID,IS) + FXY1
+          TRAC0(ID,IS,1) = TRAC0(ID,IS,1) - FXY2                          40.85
+          TRAC1(ID,IS,1) = TRAC1(ID,IS,1) + FXY1                          40.85
 !         *** test output ***
           IF ( ITEST .GE. 150 .AND. TESTFL ) THEN
               WRITE(PRINTF,6022) ID, FXY1, FXY2
@@ -2735,7 +2749,8 @@
 !
       SUBROUTINE SANDL ( ISSTOP  ,IDCMIN  ,IDCMAX  ,CGO     ,CAX     ,    33.08
      &                   CAY     ,AC2     ,AC1     ,IMATRA  ,IMATDA  ,
-     &                   RDX     ,RDY     ,CAX1    ,CAY1    ,SPCDIR)      33.08
+     &                   RDX     ,RDY     ,CAX1    ,CAY1    ,SPCDIR  ,    33.08
+     &                   TRAC0   ,TRAC1   )                               40.85
 !
 !****************************************************************
 !
@@ -2785,6 +2800,7 @@
 !        40.02: IJsbrand Haagsma
 !        40.08: W. Erick Rogers
 !        40.41: Marcel Zijlema
+!        40.85: Marcel Zijlema
 !
 !     1. UPDATE
 !
@@ -2794,6 +2810,7 @@
 !        40.02, Aug. 00: Avoide more than 19 continuatino lines
 !        40.08, Feb. 03: Check for exceedence of soft CFL criterion
 !        40.41, Oct. 04: common blocks replaced by modules, include files removed
+!        40.85, Aug. 08: store xy-propagation for output purposes
 !
 !     2. PURPOSE
 !
@@ -2932,6 +2949,8 @@
       REAL     FXY1 ,FXY2, ACOLD,                                         33.08
      &         DSS, DNN, D11AC, D12AC, D22AC                              33.08
 !
+      REAL  :: TRAC0(MDC,MSC,MTRNP)                                       40.85
+      REAL  :: TRAC1(MDC,MSC,MTRNP)                                       40.85
       REAL  :: AC1(MDC,MSC,MCGRD) ,AC2(MDC,MSC,MCGRD)
 !     Changed ICMAX to MICMAX, since MICMAX doesn't vary over gridpoint   40.22
       REAL  :: CGO(MSC,MICMAX)                                            33.08 40.22
@@ -3155,6 +3174,8 @@
           ENDIF                                                           40.08
           IMATRA(ID,IS) = IMATRA(ID,IS) + FXY2 + ACOLD*RDTIM              33.08
           IMATDA(ID,IS) = IMATDA(ID,IS) + FXY1 + RDTIM                    33.08
+          TRAC0(ID,IS,1) = TRAC0(ID,IS,1) - FXY2 - ACOLD*RDTIM            40.85
+          TRAC1(ID,IS,1) = TRAC1(ID,IS,1) + FXY1 + RDTIM                  40.85
 !
 !         *** test output ***
 !
@@ -3188,7 +3209,7 @@
       SUBROUTINE STRSSI(SPCSIG  ,
      &                  CAS     ,IMAT5L  ,IMATDA  ,IMAT6U  ,ANYBIN  ,
      &                  IMATRA  ,AC2     ,ISCMIN  ,ISCMAX  ,IDDLOW  ,
-     &                  IDDTOP                                      )     40.41 30.21
+     &                  IDDTOP  ,TRAC0   ,TRAC1                     )     40.85 40.41 30.21
 !
 !****************************************************************
 !
@@ -3230,11 +3251,13 @@
 !
 !     30.72: IJsbrand Haagsma
 !     40.41: Marcel Zijlema
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
 !     30.72, Feb. 98: Introduced generic names XCGRID, YCGRID and SPCSIG for SWAN
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
+!     40.85, Aug. 08: store sigma-propagation for output purposes
 !
 !  2. Purpose
 !
@@ -3346,6 +3369,7 @@
       REAL     DS      ,PNH     ,PN1     ,PN2     ,C1      ,C2      ,
      &         C3      ,A1      ,A3      ,PCD1    ,PCD2    ,RHS12   ,
      &         RHS23   ,DIAG12  ,DIAG23
+      REAL     TC12    ,TC23    ,S1      ,S3
 !
       LOGICAL  BIN1    ,BIN3
 !
@@ -3355,6 +3379,8 @@
      &         IMATDA(MDC,MSC)            ,
      &         IMAT6U(MDC,MSC)            ,
      &         IMATRA(MDC,MSC)
+      REAL  :: TRAC0(MDC,MSC,MTRNP)                                       40.85
+      REAL  :: TRAC1(MDC,MSC,MTRNP)                                       40.85
 !
       INTEGER  ISCMIN(MDC)                ,
      &         ISCMAX(MDC)
@@ -3380,6 +3406,8 @@
             BIN3 = ANYBIN(ID,IS+1)
             IF (.NOT.BIN3) A3 = AC2(ID,IS+1,KCGRD(1))                     30.21
             DS   = SPCSIG(IS+1) - SPCSIG(IS)                              30.72
+            S1 = 0.                                                       40.85
+            S3 = SPCSIG(IS+1)                                             40.85
           ELSE IF ( IS .EQ. MSC ) THEN
             C1   = CAS(ID,IS-1,1)
             BIN1 = ANYBIN(ID,IS-1)
@@ -3388,6 +3416,8 @@
             A3   = 0.
             BIN3 = .FALSE.
             DS   = SPCSIG(IS) - SPCSIG(IS-1)                              30.72
+            S1 = SPCSIG(IS-1)                                             40.85
+            S3 = 0.                                                       40.85
           ELSE
             C1   = CAS(ID,IS-1,1)
             C3   = CAS(ID,IS+1,1)
@@ -3396,6 +3426,8 @@
             IF (.NOT.BIN1) A1 = AC2(ID,IS-1,KCGRD(1))                     30.21
             IF (.NOT.BIN3) A3 = AC2(ID,IS+1,KCGRD(1))                     30.21
             DS   = 0.5 * ( SPCSIG(IS+1) - SPCSIG(IS-1) )                  30.72
+            S1 = SPCSIG(IS-1)                                             40.85
+            S3 = SPCSIG(IS+1)                                             40.85
           END IF
 !
           PNH = 1. / (2. * DS)
@@ -3416,6 +3448,7 @@
           END IF
 !
           RHS12 = 0.
+          TC12  = 0.
           IF ( IS .EQ. 1 .AND. C2.LT.0.) THEN
 !           fully upwind approximation at the boundary of the frequency space
             DIAG12 = - PCD1 - PCD2
@@ -3425,6 +3458,7 @@
               IMAT5L(ID,IS) = IMAT5L(ID,IS) - PCD1
             ELSE
               RHS12 = PCD1 * A1
+              TC12  = RHS12* S1
             ENDIF
           ENDIF
 !
@@ -3440,6 +3474,7 @@
           END IF
 !
           RHS23 = 0.
+          TC23  = 0.
           IF (IS .EQ. MSC .AND. C2.GT.0.) THEN
 !           full upwind approximation at the boundary
             DIAG23 = PCD2 + PCD3
@@ -3449,10 +3484,13 @@
               IMAT6U(ID,IS) = IMAT6U(ID,IS) + PCD3
             ELSE
               RHS23 = - PCD3 * A3
+              TC23  = RHS23 * S3
             ENDIF
           ENDIF
           IMATDA(ID,IS) = IMATDA(ID,IS) + DIAG12 + DIAG23
           IMATRA(ID,IS) = IMATRA(ID,IS) + RHS12 + RHS23
+          TRAC0(ID,IS,3) = TRAC0(ID,IS,3) - TC12 - TC23                   40.85
+          TRAC1(ID,IS,3) = TRAC1(ID,IS,3) + DIAG12 + DIAG23               40.85
 400     CONTINUE
 500   CONTINUE
 !
@@ -3857,7 +3895,7 @@
       SUBROUTINE STRSD (DD      ,IDCMIN  ,
      &                  IDCMAX  ,CAD     ,IMATLA  ,IMATDA  ,IMATUA  ,
      &                  IMATRA  ,AC2     ,ISSTOP  ,
-     &                  ANYBIN  ,LEAKC1                             )     40.41 30.21
+     &                  ANYBIN  ,LEAKC1  ,TRAC0   ,TRAC1            )     40.85 40.41 30.21
 
 !****************************************************************
 !
@@ -3898,6 +3936,7 @@
 !     1. UPDATE
 !
 !        40.41, Oct. 04: common blocks replaced by modules, include files removed
+!        40.85, Aug. 08: store theta-propagation for output purposes
 !
 !     2. PURPOSE
 !
@@ -4013,6 +4052,8 @@
      &         IMATUA(MDC,MSC)            ,
      &         IMATRA(MDC,MSC)            ,
      &         LEAKC1(MDC,MSC)
+      REAL  :: TRAC0(MDC,MSC,MTRNP)                                       40.85
+      REAL  :: TRAC1(MDC,MSC,MTRNP)                                       40.85
 !
       INTEGER  IDCMIN(MSC)                ,
      &         IDCMAX(MSC)
@@ -4110,6 +4151,8 @@
             ENDIF
             IMATDA(ID,IS) = IMATDA(ID,IS) + DIAG12 + DIAG23
             IMATRA(ID,IS) = IMATRA(ID,IS) + RHS12 + RHS23
+            TRAC0(ID,IS,2) = TRAC0(ID,IS,2) - RHS12 - RHS23               40.85
+            TRAC1(ID,IS,2) = TRAC1(ID,IS,2) + DIAG12 + DIAG23             40.85
           ENDIF
 !
  100    CONTINUE
@@ -4574,10 +4617,20 @@
       SUBROUTINE ADDDIS (DISSXY     ,LEAKXY     ,
      &                   AC2        ,ANYBIN     ,
      &                   DISC0      ,DISC1      ,
+     &                   GENC0      ,GENC1      ,                         40.85
+     &                   REDC0      ,REDC1      ,                         40.85
+     &                   TRAC0      ,TRAC1      ,                         40.85
+     &                   IMATLA     ,IMATUA     ,                         40.85
+     &                   IMAT5L     ,IMAT6U     ,                         40.85
      &                   DSXBOT     ,                                     40.67 40.61
      &                   DSXSRF     ,                                     40.67 40.61
      &                   DSXWCP     ,                                     40.67 40.61
-     &                   LEAKC1     ,SPCSIG     )                         30.72
+     &                   GSXWND     ,GENRXY     ,                         40.85
+     &                   RSXQUA     ,RSXTRI     ,                         40.85
+     &                   REDSXY     ,                                     40.85
+     &                   TSXGEO     ,TSXSPT     ,                         40.85
+     &                   TSXSPS     ,TRANXY     ,                         40.85
+     &                   LEAKC1     ,RADSXY     ,SPCSIG     )             40.85 30.72
 !
 !*******************************************************************
 !
@@ -4618,6 +4671,7 @@
 !     30.72: IJsbrand Haagsma
 !     40.61: Marcel Zijlema
 !     40.67: Nico Booij
+!     40.85: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -4626,10 +4680,12 @@
 !     30.72, Feb. 98: Introduced generic names XCGRID, YCGRID and SPCSIG for SWAN
 !     40.61, Sep. 06: introduction of all separate dissipation coefficients
 !     40.67, Jun. 07: more accurate computation of dissipation terms
+!     40.85, Aug. 08: add also propagation, generation and redistribution terms
+!                     and radiation stress
 !
 !  2. Purpose
 !
-!     Adds dissipation and leak
+!     Adds propagation, generation, dissipation, redistribution, leak and radiation stress terms
 !
 !  3. Method
 !
@@ -4683,39 +4739,155 @@
 !
       INTEGER :: II               ! counter                               40.67
       REAL    :: ADISSIP(1:MDISP)                                         40.67
+      REAL    :: AGENERT(1:MGENR)                                         40.85
+      REAL    :: AREDIST(1:MREDS)                                         40.85
+      REAL    :: ATRANSP(1:MTRNP)                                         40.85
       REAL     DISSXY(MCGRD)    ,LEAKXY(MCGRD)      ,
      &         DSXBOT(MCGRD)      ,                                       40.67 40.61
      &         DSXSRF(MCGRD)      ,                                       40.67 40.61
      &         DSXWCP(MCGRD)      ,                                       40.67 40.61
+     &         GSXWND(MCGRD)      ,                                       40.85
+     &         RSXQUA(MCGRD)      ,                                       40.85
+     &         RSXTRI(MCGRD)      ,                                       40.85
+     &         TSXGEO(MCGRD)      ,                                       40.85
+     &         TSXSPT(MCGRD)      ,                                       40.85
+     &         TSXSPS(MCGRD)      ,                                       40.85
+     &         GENRXY(MCGRD)      ,REDSXY(MCGRD)    ,TRANXY(MCGRD),       40.85
+     &         RADSXY(MCGRD)      ,                                       40.85
      &         LEAKC1(MDC,MSC)  ,AC2(MDC,MSC,MCGRD)                       30.21
       REAL :: DISC0(1:MDC,1:MSC,1:MDISP)       ! dissipation coeff.       40.67
       REAL :: DISC1(1:MDC,1:MSC,1:MDISP)       ! dissipation coeff.       40.67
+      REAL :: GENC0(1:MDC,1:MSC,1:MGENR)       ! generation coeff.        40.85
+      REAL :: GENC1(1:MDC,1:MSC,1:MGENR)       ! generation coeff.        40.85
+      REAL :: REDC0(1:MDC,1:MSC,1:MREDS)       ! redistribution coeff.    40.85
+      REAL :: REDC1(1:MDC,1:MSC,1:MREDS)       ! redistribution coeff.    40.85
+      REAL :: TRAC0(1:MDC,1:MSC,1:MTRNP)       ! transport coeff.         40.85
+      REAL :: TRAC1(1:MDC,1:MSC,1:MTRNP)       ! transport coeff.         40.85
+      REAL    IMATLA(MDC,MSC)           ,                                 40.85
+     &        IMATUA(MDC,MSC)           ,                                 40.85
+     &        IMAT5L(MDC,MSC)           ,                                 40.85
+     &        IMAT6U(MDC,MSC)                                             40.85
 !
       LOGICAL  ANYBIN(MDC,MSC)
       INTEGER, SAVE :: IENT=0
       CALL STRACE (IENT, 'ADDDIS')
 !
       ADISSIP(1:MDISP) = 0.                                               40.67
+      AGENERT(1:MGENR) = 0.                                               40.85
+      AREDIST(1:MREDS) = 0.                                               40.85
+      ATRANSP(1:MTRNP) = 0.                                               40.85
+      ARADSTR          = 0.                                               40.85
       DO 100 ISC = 1, MSC
-        DSDD = DDIR * FRINTF * SPCSIG(ISC)**2
+        DSDD  = DDIR * FRINTF * SPCSIG(ISC)
+        SDSDD = DSDD * SPCSIG(ISC)
         DO 90 IDC = 1, MDC
+          IDM = MOD ( IDC - 2 + MDC , MDC ) + 1
+          IDP = MOD ( IDC     + MDC , MDC ) + 1
+!
+          S1   = SPCSIG(ISC)
+          ACT1 = AC2(IDC,ISC,KCGRD(1))
+          IF (ISC.EQ.1) THEN
+             S2   = 0.
+             ACT2 = 0.
+          ELSE
+             S2   = SPCSIG(ISC-1)
+             ACT2 = AC2(IDC,ISC-1,KCGRD(1))
+          ENDIF
+          IF (ISC.EQ.MSC) THEN
+             S3   = 0.
+             ACT3 = 0.
+          ELSE
+             S3   = SPCSIG(ISC+1)
+             ACT3 = AC2(IDC,ISC+1,KCGRD(1))
+          ENDIF
+          IF (.NOT.FULCIR .AND. IDC.EQ.1) THEN
+             ACT4 = 0.
+          ELSE
+             ACT4 = AC2(IDM,ISC,KCGRD(1))
+          ENDIF
+          IF (.NOT.FULCIR .AND. IDC.EQ.MDC) THEN
+             ACT5 = 0.
+          ELSE
+             ACT5 = AC2(IDP,ISC,KCGRD(1))
+          ENDIF
+!
           IF (ANYBIN(IDC,ISC)) THEN
-            LEAKXY(KCGRD(1)) = LEAKXY(KCGRD(1)) + DSDD *
+            LEAKXY(KCGRD(1)) = LEAKXY(KCGRD(1)) + SDSDD*
      &                      LEAKC1(IDC,ISC) * AC2(IDC,ISC,KCGRD(1))
 !
 !           --- compute for each dissipation term                         40.61
 !
             DO II = 1, MDISP                                              40.67
-              ADISSIP(II) =  ADISSIP(II) + DSDD * (DISC0(IDC,ISC,II) +    40.67
-     &                      DISC1(IDC,ISC,II) * AC2(IDC,ISC,KCGRD(1)))    40.67
+              ACONTR= SDSDD*(DISC0(IDC,ISC,II) + DISC1(IDC,ISC,II)*ACT1)  40.85
+              ADISSIP(II) = ADISSIP(II) + ACONTR                          40.85 40.67
+              ARADSTR     = ARADSTR     - ACONTR                          40.85
             ENDDO                                                         40.67
+!
+!           --- compute for each generation term                          40.85
+!
+            DO II = 1, MGENR                                              40.85
+              ACONTR= SDSDD*(GENC0(IDC,ISC,II) + GENC1(IDC,ISC,II)*ACT1)  40.85
+              AGENERT(II) = AGENERT(II) + ACONTR                          40.85
+              ARADSTR     = ARADSTR     + ACONTR                          40.85
+            ENDDO                                                         40.85
+!
+!           --- compute for each redistribution term                      40.85
+!
+            DO II = 1, MREDS                                              40.85
+              ACONTR= SDSDD*(REDC0(IDC,ISC,II) + REDC1(IDC,ISC,II)*ACT1)  40.85
+              AREDIST(II) = AREDIST(II) + ABS(ACONTR)                     40.85
+              ARADSTR     = ARADSTR     + ACONTR                          40.85
+            ENDDO                                                         40.85
+!
+!           --- compute for each propagation term
+!
+            ACONTR = SDSDD* (TRAC0(IDC,ISC,1) + TRAC1(IDC,ISC,1)*ACT1)    40.85
+            ATRANSP(1) = ATRANSP(1) + ABS(ACONTR)                         40.85
+            ARADSTR    = ARADSTR    - ACONTR                              40.85
+!
+            ACONTR = SDSDD* (TRAC0(IDC,ISC,2)      +                      40.85
+     &                       TRAC1(IDC,ISC,2)*ACT1 +                      40.85
+     &                       IMATLA(IDC,ISC) *ACT4 +                      40.85
+     &                       IMATUA(IDC,ISC) *ACT5 )                      40.85
+            ATRANSP(2) = ATRANSP(2) + ABS(ACONTR)                         40.85
+            ARADSTR    = ARADSTR    - ACONTR                              40.85
+!
+            ACONTR = DSDD * (TRAC0(IDC,ISC,3)           +                 40.85
+     &                       TRAC1(IDC,ISC,3)* S1 *ACT1 +                 40.85
+     &                       IMAT5L(IDC,ISC) * S2 *ACT2 +                 40.85
+     &                       IMAT6U(IDC,ISC) * S3 *ACT3 )                 40.85
+            ATRANSP(3) = ATRANSP(3) + ABS(ACONTR)                         40.85
+            ARADSTR    = ARADSTR    - ACONTR                              40.85
+!
+            ARADSTR    = ABS(ARADSTR)                                     40.85
           ENDIF
   90    CONTINUE
  100  CONTINUE
-      DSXWCP(KCGRD(1)) = DSXWCP(KCGRD(1)) + ADISSIP(1)     ! whitecapping 40.67
-      DSXSRF(KCGRD(1)) = DSXSRF(KCGRD(1)) + ADISSIP(2)     ! surf break   40.67
-      DSXBOT(KCGRD(1)) = DSXBOT(KCGRD(1)) + ADISSIP(3)     ! bottom fric  40.67
-      DISSXY(KCGRD(1)) = DISSXY(KCGRD(1)) + SUM(ADISSIP)   ! total dissip 40.67
+!
+      DSXWCP(KCGRD(1)) = DSXWCP(KCGRD(1)) + ADISSIP(1)     ! whitecapping         40.67
+      DSXSRF(KCGRD(1)) = DSXSRF(KCGRD(1)) + ADISSIP(2)     ! surf break           40.67
+      DSXBOT(KCGRD(1)) = DSXBOT(KCGRD(1)) + ADISSIP(3)     ! bottom fric          40.67
+      DISSXY(KCGRD(1)) = DISSXY(KCGRD(1)) + SUM(ADISSIP)   ! total dissip         40.67
+!
+      GSXWND(KCGRD(1)) = GSXWND(KCGRD(1)) + AGENERT(1)     ! wind input           40.85
+      GENRXY(KCGRD(1)) = GENRXY(KCGRD(1)) + SUM(AGENERT)   ! total generation     40.85
+!
+      RSXQUA(KCGRD(1)) = RSXQUA(KCGRD(1)) + AREDIST(1)     ! quadruplets          40.85
+      RSXTRI(KCGRD(1)) = RSXTRI(KCGRD(1)) + AREDIST(2)     ! triads               40.85
+      REDSXY(KCGRD(1)) = REDSXY(KCGRD(1)) + SUM(AREDIST)   ! total redistribution 40.85
+!
+      TSXGEO(KCGRD(1)) = TSXGEO(KCGRD(1)) + ATRANSP(1)     ! xy-propagation       40.85
+      TSXSPT(KCGRD(1)) = TSXSPT(KCGRD(1)) + ATRANSP(2)     ! theta-propagation    40.85
+      TSXSPS(KCGRD(1)) = TSXSPS(KCGRD(1)) + ATRANSP(3)     ! sigma-propagation    40.85
+      TRANXY(KCGRD(1)) = TRANXY(KCGRD(1)) + SUM(ATRANSP)   ! total propagation    40.85
+!
+      RADSXY(KCGRD(1)) = RADSXY(KCGRD(1)) + ARADSTR        ! radiation stress     40.85
+!
+      IMATLA = 0.
+      IMATUA = 0.
+      IMAT5L = 0.
+      IMAT6U = 0.
+!
       RETURN
       END
 !
--- SwanCompdata.ftn90	2008-05-25 14:59:42.000000000 +0200
+++ SwanCompdata.ftn90	2008-10-15 11:57:42.000000000 +0200
@@ -32,10 +32,12 @@
 !   Authors
 !
 !   40.80: Marcel Zijlema
+!   40.92: Marcel Zijlema
 !
 !   Updates
 !
 !   40.80, July 2007: New Module
+!   40.92, June 2008: changes with respect to boundary polygons
 !
 !   Purpose
 !
@@ -56,14 +58,15 @@
 !
 !   Module variables
 !
-    integer                                  :: nbpt  ! number of boundary points
+    integer                                    :: nbpol  ! total number of boundary polygons
+    integer, dimension(100)                    :: nbpt   ! number of boundary vertices for each boundary polygon
 !
-    integer, dimension(MICMAX)               :: vs    ! computational stencil, i.e. set of vertices
-                                                      ! needed for the computation of a new value
-                                                      ! in the present vertex
+    integer, dimension(MICMAX)                 :: vs     ! computational stencil, i.e. set of vertices
+                                                         ! needed for the computation of a new value
+                                                         ! in the present vertex
 !
-    integer, dimension(:), save, allocatable :: blist ! list of boundary points in ascending order (counterclockwise)
-    integer, dimension(:), save, allocatable :: vlist ! vertex list
+    integer, dimension(:,:), save, allocatable :: blist  ! list of boundary vertices in ascending order for each boundary polygon
+    integer, dimension(:)  , save, allocatable :: vlist  ! vertex list
 !
 !   Source text
 !
--- SwanCompUnstruc.ftn90	2008-05-25 14:59:50.000000000 +0200
+++ SwanCompUnstruc.ftn90	2008-10-15 11:57:48.000000000 +0200
@@ -36,6 +36,7 @@
 !   Updates
 !
 !   40.80, July 2007: New subroutine
+!   40.85, August 2008: add propagation, generation and redistribution terms for output purposes
 !
 !   Purpose
 !
@@ -54,7 +55,7 @@
 !   In each iteration, a number of sweeps are carried out
 !   Per sweep, a loop over all vertices is executed
 !   The solution of each vertex must be updated geographically before proceeding to the next one
-!   The two upwave faces connecting the vertex to be updated encloses those wave directions that can be processed in the spectral space
+!   The two upwave faces connecting the vertex to be updated enclose those wave directions that can be processed in the spectral space
 !   A sweep is complete when all vertices are updated geographically (but not necessarily in whole spectral space)
 !   The process continues by sweeping through the vertices in a reverse manner, allowing waves to propagate from other directions
 !   An iteration is complete when all vertices are updated in both geographic and spectral spaces
@@ -188,9 +189,11 @@
     real, dimension(:,:), allocatable     :: da2c      ! implicit interaction contribution of second quadruplet, current bin (unfolded space)
     real, dimension(:,:), allocatable     :: da2m      ! implicit interaction contribution of second quadruplet, current bin -1 (unfolded space)
     real, dimension(:,:), allocatable     :: da2p      ! implicit interaction contribution of second quadruplet, current bin +1 (unfolded space)
-    real, dimension(:,:,:), allocatable   :: disc0     ! explicit part of total dissipation in present vertex for output purposes
-    real, dimension(:,:,:), allocatable   :: disc1     ! implicit part of total dissipation in present vertex for output purposes
+    real, dimension(:,:,:), allocatable   :: disc0     ! explicit part of dissipation in present vertex for output purposes
+    real, dimension(:,:,:), allocatable   :: disc1     ! implicit part of dissipation in present vertex for output purposes
     real, dimension(:,:), allocatable     :: dsnl      ! total interaction contribution of quadruplets to the main diagonal matrix
+    real, dimension(:,:,:), allocatable   :: genc0     ! explicit part of generation in present vertex for output purposes
+    real, dimension(:,:,:), allocatable   :: genc1     ! implicit part of generation in present vertex for output purposes
     real, dimension(:), allocatable       :: hscurr    ! wave height at current iteration level
     real, dimension(:), allocatable       :: hsdifc    ! difference in wave height of current and one before previous iteration
     real, dimension(:), allocatable       :: hsprev    ! wave height at previous iteration level
@@ -198,12 +201,18 @@
     real, dimension(:,:), allocatable     :: leakcf    ! leak coefficient in present vertex for output purposes
     real, dimension(:,:,:), allocatable   :: memnl4    ! auxiliary array to store results of 4 wave-wave interactions in full spectral space
     real, dimension(:,:,:), allocatable   :: obredf    ! action reduction coefficient based on transmission
+    real, dimension(:,:,:), allocatable   :: redc0     ! explicit part of redistribution in present vertex for output purposes
+    real, dimension(:,:,:), allocatable   :: redc1     ! implicit part of redistribution in present vertex for output purposes
     real, dimension(:,:), allocatable     :: reflso    ! contribution to the source term due to reflection
     real, dimension(:,:), allocatable     :: sa1       ! explicit interaction contribution of first quadruplet (unfolded space)
     real, dimension(:,:), allocatable     :: sa2       ! explicit interaction contribution of second quadruplet (unfolded space)
     real, dimension(:,:), allocatable     :: sfnl      ! total interaction contribution of quadruplets to the right-hand side
     real, dimension(:,:,:,:), allocatable :: swtsda    ! several source terms computed at test points
     real, dimension(:), allocatable       :: tmcurr    ! mean period at current iteration level
+    real, dimension(:), allocatable       :: tmdifc    ! difference in mean period of current and one before previous iteration
+    real, dimension(:), allocatable       :: tmprev    ! mean period at previous iteration level
+    real, dimension(:,:,:), allocatable   :: trac0     ! explicit part of propagation in present vertex for output purposes
+    real, dimension(:,:,:), allocatable   :: trac1     ! implicit part of propagation in present vertex for output purposes
     real, dimension(:,:), allocatable     :: ue        ! energy density for computing 4 wave-wave interactions (unfolded space)
     !
     logical                               :: fguess    ! indicate whether first guess need to be applied or not
@@ -262,6 +271,8 @@
     allocate(hsprev(nverts))
     allocate(hsdifc(nverts))
     allocate(tmcurr(nverts))
+    allocate(tmprev(nverts))
+    allocate(tmdifc(nverts))
     !
     allocate(swtsda(MDC,MSC,NPTSTA,MTSVAR))
     !
@@ -302,6 +313,12 @@
     !
     allocate( disc0(MDC,MSC,MDISP))
     allocate( disc1(MDC,MSC,MDISP))
+    allocate( genc0(MDC,MSC,MGENR))
+    allocate( genc1(MDC,MSC,MGENR))
+    allocate( redc0(MDC,MSC,MREDS))
+    allocate( redc1(MDC,MSC,MREDS))
+    allocate( trac0(MDC,MSC,MTRNP))
+    allocate( trac1(MDC,MSC,MTRNP))
     allocate(leakcf(MDC,MSC      ))
     !
     ! calculate ranges of spectral space for arrays related to 4 wave-wave interactions
@@ -352,19 +369,24 @@
     hsprev = 0.
     hsdifc = 0.
     tmcurr = 0.
+    tmprev = 0.
+    tmdifc = 0.
     !
     swtsda = 0.
 !TIMG    call SWTSTO(101)
     !
     ! marks vertices active and non-active
     !
+    nwetp = 0
     do kvert = 1, nverts
        if ( compda(kvert,JDP2) > DEPMIN ) then
           vert(kvert)%active = .true.
+          nwetp = nwetp +1
        else
           vert(kvert)%active = .false.
        endif
     enddo
+    if ( it == 1 .and. ITEST > 0 ) write (PRINTF,108) nwetp, real(nwetp)*100./real(nverts)
     !
     ! First guess of action density will be applied if 3rd generation mode is employed and wind is active (IWIND > 2)
     ! Note: this first guess is not used in nonstationary run (NSTATC > 0) or hotstart (ICOND = 4)
@@ -396,6 +418,16 @@
        compda(:,JDSXB) = 0.
        compda(:,JDSXS) = 0.
        compda(:,JDSXW) = 0.
+       compda(:,JGENR) = 0.
+       compda(:,JGSXW) = 0.
+       compda(:,JREDS) = 0.
+       compda(:,JRSXQ) = 0.
+       compda(:,JRSXT) = 0.
+       compda(:,JTRAN) = 0.
+       compda(:,JTSXG) = 0.
+       compda(:,JTSXT) = 0.
+       compda(:,JTSXS) = 0.
+       compda(:,JRADS) = 0.
        compda(:,JQB  ) = 0.
        !
        ! During first iteration, first guess of action density is based on 2nd generation mode
@@ -737,7 +769,7 @@
                                          cax   , cay   , cad   , cas   , anybin, &
                                          rdx   , rdy   , obredf, spcsig, idcmin, &
                                          idcmax, iscmin, iscmax, iddlow, iddtop, &
-                                         isslow, isstop )
+                                         isslow, isstop, trac0 , trac1 )
 !TIMG                     call SWTSTO(118)
                      !
                      ! compute the source part of the action balance equation
@@ -782,7 +814,8 @@
                                       sfnl                , dsnl                , memnl4              , wwint               , &
                                       wwawg               , wwswg               , cgo                 , compda(1,JUSTAR)    , &
                                       compda(1,JZEL)      , spcdir              , anywnd              , disc0               , &
-                                      disc1               , xis                 , compda(1,JFRC2)     , it                  , &
+                                      disc1               , genc0               , genc1               , redc0               , &
+                                      redc1               , xis                 , compda(1,JFRC2)     , it                  , &
                                       compda(1,JURSEL)    , anybin              , reflso              )
 !TIMG                        call SWTSTO(117)
                         !
@@ -833,6 +866,25 @@
                            !
                         endif
                         !
+                        ! store propagation, generation, dissipation, redistribution, leak and radiation stress in present vertex
+                        !
+!TIMG                        call SWTSTA(124)
+                        call ADDDIS ( compda(1,JDISS), compda(1,JLEAK), ac2   , anybin , &
+                                      disc0          , disc1          ,                  &
+                                      genc0          , genc1          ,                  &
+                                      redc0          , redc1          ,                  &
+                                      trac0          , trac1          ,                  &
+                                      amat(1,1,4)    , amat(1,1,5)    ,                  &
+                                      amat(1,1,2)    , amat(1,1,3)    ,                  &
+                                      compda(1,JDSXB), compda(1,JDSXS), compda(1,JDSXW), &
+                                      compda(1,JGSXW), compda(1,JGENR),                  &
+                                      compda(1,JRSXQ), compda(1,JRSXT),                  &
+                                      compda(1,JREDS),                                   &
+                                      compda(1,JTSXG), compda(1,JTSXT),                  &
+                                      compda(1,JTSXS), compda(1,JTRAN),                  &
+                                      leakcf         , compda(1,JRADS), spcsig           )
+!TIMG                        call SWTSTO(124)
+                        !
                         ! if negative action density occur rescale with a factor
                         !
 !TIMG                        call SWTSTA(121)
@@ -854,19 +906,10 @@
                         !
                         ! store some infinity norms meant for convergence check
                         !
-                        if ( PNUMS(21) == 2 ) call SWACC ( ac2, ac2old, acnrms, isstop, idcmin, idcmax )
+                        if ( PNUMS(21) == 2. ) call SWACC ( ac2, ac2old, acnrms, isstop, idcmin, idcmax )
                         !
                      endif
                      !
-                     ! store dissipation and leak in present vertex
-                     !
-!TIMG                     call SWTSTA(124)
-                     call ADDDIS ( compda(1,JDISS), compda(1,JLEAK), ac2   , anybin , &
-                                   disc0          , disc1          , compda(1,JDSXB), &
-                                   compda(1,JDSXS), compda(1,JDSXW),                  &
-                                   leakcf         , spcsig         )
-!TIMG                     call SWTSTO(124)
-                     !
                   endif
                   !
                   ! tag updated vertex in present cell
@@ -952,16 +995,16 @@
        !
        ! info regarding the iteration process and the accuracy
        !
-!TIMG       call SWTSTA(102)
-       if ( PNUMS(21) <= 1 ) then
+       if ( PNUMS(21) <= 1. ) then
           !
-          if ( PNUMS(21) == 0 ) then
+!TIMG          call SWTSTA(102)
+          if ( PNUMS(21) == 0. ) then
              !
              call SwanConvAccur ( accur, hscurr, tmcurr, compda(1,JDHS), compda(1,JDTM), xytst, spcsig, ac2 )
              !
           else
              !
-             call SwanConvStopc ( accur, hscurr, hsprev, hsdifc, tmcurr, compda(1,JDHS), compda(1,JDTM), xytst, spcsig, ac2 )
+             call SwanConvStopc ( accur, hscurr, hsprev, hsdifc, tmcurr, tmprev, tmdifc, compda(1,JDHS), compda(1,JDTM), xytst, spcsig, ac2 )
              !
           endif
           !
@@ -973,13 +1016,15 @@
              write (PRINTF,140) accur, PNUMS(4)
              if ( NSTATC == 0 ) write (SCREEN,140) accur, PNUMS(4)
           endif
+!TIMG          call SWTSTO(102)
           !
           ! if accuracy has been reached then terminates iteration process
           !
           if ( accur >= PNUMS(4) ) exit iterloop
           !
-       elseif ( PNUMS(21) == 2 ) then
+       elseif ( PNUMS(21) == 2. ) then
           !
+!TIMG          call SWTSTA(102)
           write (PRINTF,141)
           if ( NSTATC == 0 ) write (SCREEN,141)
           if ( iter == 1 ) then
@@ -998,13 +1043,13 @@
              endif
           endif
           acnrmo = acnrms(1)
+!TIMG          call SWTSTO(102)
           !
           ! if accuracy has been reached then terminates iteration process
           !
           if ( acnrms(1) < stopcr ) exit iterloop
           !
        endif
-!TIMG       call SWTSTO(102)
        !
     enddo iterloop
 !TIMG    call SWTSTO(103)
@@ -1051,6 +1096,12 @@
     !
     deallocate( disc0)
     deallocate( disc1)
+    deallocate( genc0)
+    deallocate( genc1)
+    deallocate( redc0)
+    deallocate( redc1)
+    deallocate( trac0)
+    deallocate( trac1)
     deallocate(leakcf)
     !
     deallocate(  ue)
@@ -1075,6 +1126,8 @@
     deallocate(hsprev)
     deallocate(hsdifc)
     deallocate(tmcurr)
+    deallocate(tmprev)
+    deallocate(tmdifc)
     !
     deallocate(swtsda)
     !
@@ -1087,9 +1140,10 @@
  104 format (' IWIND ',i4,'    IWCAP ',i4   ,'            IQUAD  ',i4)
  105 format (' ISURF ',i4,'    IBOT  ',i4   ,'            ITRIAD ',i4,/)
  107 format (' Test points :',2i5)
- 110 format ('+time ', a18, ', step ',i4, '; iteration ',i4, '; sweep ',i2)
- 120 format (' iteration ', i4, '; sweep ', i2)
- 130 format ('+iteration ', i4, '; sweep ', i2)
+ 108 format (' Number of active points = ',i6,' (fillings-degree: ',f6.2,' %)')
+ 110 format ('+time ', a18, ', step ',i4, '; iteration ',i4, '; sweep ',i3)
+ 120 format (' iteration ', i4, '; sweep ', i3)
+ 130 format ('+iteration ', i4, '; sweep ', i3)
  134 format (1x,'use of ',a9,' in ',f6.2,' % of active vertices with maximum in spectral space = ',i4)
  135 format (1x,'lowest frequency occured above which limiter is applied = ',f7.4,' Hz')
  136 format (2x,'SIP solver: no convergence in ',i4,' vertices')
--- SwanConvStopc.ftn90	2008-05-25 14:59:42.000000000 +0200
+++ SwanConvStopc.ftn90	2008-10-15 11:57:42.000000000 +0200
@@ -1,4 +1,4 @@
-subroutine SwanConvStopc ( accur, hscurr, hsprev, hsdifc, tmcurr, delhs, deltm, xytst, spcsig, ac2 )
+subroutine SwanConvStopc ( accur, hscurr, hsprev, hsdifc, tmcurr, tmprev, tmdifc, delhs, deltm, xytst, spcsig, ac2 )
 !
 !   --|-----------------------------------------------------------|--
 !     | Delft University of Technology                            |
@@ -32,14 +32,16 @@
 !   Authors
 !
 !   40.80: Marcel Zijlema
+!   40.93: Marcel Zijlema
 !
 !   Updates
 !
-!   40.80, October 2007: New subroutine
+!   40.80,   October 2007: New subroutine
+!   40.93, September 2008: extended with curvature of mean period
 !
 !   Purpose
 !
-!   Determine accuracy of wave height by means of curvature for convergence check
+!   Determine accuracy of wave height and period by means of curvature for convergence check
 !
 !   Modules used
 !
@@ -63,6 +65,8 @@
     real, dimension(nverts), intent(inout)      :: hsdifc ! difference in wave height of current and one before previous iteration
     real, dimension(nverts), intent(inout)      :: hsprev ! wave height at previous iteration level
     real, dimension(nverts), intent(inout)      :: tmcurr ! mean period at current iteration level
+    real, dimension(nverts), intent(inout)      :: tmdifc ! difference in mean period of current and one before previous iteration
+    real, dimension(nverts), intent(inout)      :: tmprev ! mean period at previous iteration level
     real, dimension(MSC), intent(in)            :: spcsig ! relative frequency bins
 !
 !   Local variables
@@ -75,7 +79,8 @@
     integer                               :: npacc    ! number of vertices in which required accuracy has been reached
     integer                               :: nwetp    ! total number of active vertices
     !
-    real                                  :: curvat   ! required accuracy with respect to curvature in wave height
+    real                                  :: curvah   ! required accuracy with respect to curvature in wave height
+    real                                  :: curvat   ! required accuracy with respect to curvature in mean period
     real                                  :: fact     ! auxiliary factor
     real                                  :: hsabs    ! absolute difference in wave height between last 2 iterations
     real                                  :: hscurv   ! curvature of iteration curve of wave height
@@ -85,7 +90,10 @@
     real                                  :: m0       ! moment of zeroth order
     real                                  :: m1       ! moment of first order
     real                                  :: tmabs    ! absolute difference in mean period between last 2 iterations
-    real                                  :: tmprev   ! mean period at previous iteration level
+    real                                  :: tmcurv   ! curvature of iteration curve of mean period
+    real                                  :: tmdif0   ! value of tmdifc at previous iteration level
+    real                                  :: tmprev0  ! mean period at one before previous iteration level
+    real                                  :: tmrel    ! required accuracy with respect to relative error in mean period
     !
     logical                               :: lhead    ! logical indicating to write header
     logical                               :: tstfl    ! indicates whether vertex is a test point
@@ -112,7 +120,7 @@
     !
     lhead = .true.
     !
-    ! calculate a set of accuracy parameters based on relative error and curvature for Hs
+    ! calculate a set of accuracy parameters based on relative error and curvature for Hs and Tm
     !
     do ivert = 1, nverts
        !
@@ -136,7 +144,8 @@
           !
           hsprev0       = max( 1.e-20, hsprev(ivert) )
           hsprev(ivert) = max( 1.e-20, hscurr(ivert) )
-          tmprev        = max( 1.e-20, tmcurr(ivert) )
+          tmprev0       = max( 1.e-20, tmprev(ivert) )
+          tmprev(ivert) = max( 1.e-20, tmcurr(ivert) )
           !
           ! compute wave height and mean period for present vertex
           !
@@ -166,7 +175,7 @@
           ! compute absolute differences in wave height and mean period between last 2 iterations
           !
           hsabs = abs ( hscurr(ivert) - hsprev(ivert) )
-          tmabs = abs ( tmcurr(ivert) - tmprev )
+          tmabs = abs ( tmcurr(ivert) - tmprev(ivert) )
           !
           delhs(ivert) = hsabs
           deltm(ivert) = tmabs
@@ -177,18 +186,30 @@
           hsdifc(ivert) = 0.5*( hscurr(ivert) - hsprev0 )
           hscurv        = abs ( hsdifc(ivert) - hsdif0 )
           !
+          ! compute curvature of mean period
+          !
+          tmdif0        = tmdifc(ivert)
+          tmdifc(ivert) = 0.5*( tmcurr(ivert) - tmprev0 )
+          tmcurv        = abs ( tmdifc(ivert) - tmdif0 )
+          !
           ! compute required accuracies for wave height
           !
           hsrel  = PNUMS( 1) * hscurr(ivert)
-          curvat = PNUMS(15) * hscurr(ivert)
+          curvah = PNUMS(15) * hscurr(ivert)
+          !
+          ! compute required accuracies for mean period
+          !
+          tmrel  = PNUMS( 1) * tmcurr(ivert)
+          curvat = PNUMS(16) * tmcurr(ivert)
           !
-          ! count vertices where wave height has reached required accuracies
+          ! count vertices where wave height and period have reached required accuracies
           !
-          if ( hscurv <= curvat .and. hsabs <= max(hsrel,PNUMS(2)) ) npacc = npacc + 1
+          if ( (hscurv <= curvah .and. hsabs <= max(hsrel,PNUMS(2)) ) .and. &
+               (tmcurv <= curvat .and. tmabs <= max(tmrel,PNUMS(3)) ) ) npacc = npacc + 1
           !
           if (tstfl) then
              if (lhead) write(PRINTF,11)
-             write (PRINTF,12) ivert, hsabs, hsabs/hscurr(ivert), hscurv/hscurr(ivert)
+             write (PRINTF,12) ivert, hsabs, hsabs/hscurr(ivert), hscurv/hscurr(ivert), tmabs, tmabs/tmcurr(ivert), tmcurv/tmcurr(ivert)
              lhead = .false.
           endif
           !
@@ -205,7 +226,7 @@
     !
     accur = real(npacc)*100./real(nwetp)
     !
- 11 format(11x,'dHabs          ','dHrel          ','Curvature      ')
- 12 format(1x,ss,'k=',i5,'  ',1pe13.6e2,'  ',1pe13.6e2,'  ',1pe13.6e2)
+ 11 format(11x,'dHabs          ','dHrel          ','Curvature H    ','dTabs          ','dTrel          ','Curvature T    ')
+ 12 format(1x,ss,'k=',i5,'  ',1pe13.6e2,'  ',1pe13.6e2,'  ',1pe13.6e2,'  ',1pe13.6e2,'  ',1pe13.6e2,'  ',1pe13.6e2)
     !
 end subroutine SwanConvStopc
--- SwanCreateEdges.ftn90	2008-05-25 14:59:42.000000000 +0200
+++ SwanCreateEdges.ftn90	2008-10-15 11:57:42.000000000 +0200
@@ -54,16 +54,25 @@
 !
 !   Local variables
 !
-    integer, save           :: ient = 0 ! number of entries in this subroutine
-    integer                 :: iface    ! actual face of present cell
-    integer                 :: istat    ! indicate status of allocation
-    integer                 :: j        ! loop counter
-    integer                 :: k        ! loop counter
-    integer                 :: maxnf    ! maximum number of faces
-    integer                 :: v1       ! first vertex of present cell
-    integer                 :: v2       ! second vertex of present cell
-    integer                 :: v3       ! third vertex of present cell
-    integer, dimension(2,3) :: vf       ! vertices of faces of present cell
+    integer, save                         :: ient = 0  ! number of entries in this subroutine
+    integer                               :: iface     ! actual face of present cell
+    integer                               :: istat     ! indicate status of allocation
+    integer                               :: j         ! loop counter
+    integer                               :: k         ! loop counter
+    integer                               :: m         ! counter
+    integer                               :: maxnf     ! maximum number of faces
+    integer                               :: n         ! counter
+    integer                               :: v1        ! first vertex of present cell
+    integer                               :: v2        ! second vertex of present cell
+    integer                               :: v3        ! third vertex of present cell
+    integer, dimension(2,3)               :: vf        ! vertices of faces of present cell
+    !
+    integer, dimension(:  ), allocatable  :: cntv1     ! array of vertex counter for for vertex 1
+    integer, dimension(:  ), allocatable  :: cntv2     ! array of vertex counter for for vertex 2
+    integer, dimension(:,:), allocatable  :: iflist1   ! list of index faces stored for vertex 1
+    integer, dimension(:,:), allocatable  :: iflist2   ! list of index faces stored for vertex 2
+    !
+    logical                               :: facefound ! true if face is found
 !
 !   Structure
 !
@@ -80,10 +89,20 @@
     if(.not.allocated(kvertf)) allocate (kvertf(2,maxnf), stat = istat)
     if ( istat /= 0 ) then
        call msgerr ( 4, 'Allocation problem in SwanCreateEdges: array kvertf ' )
-       goto 900
+       return
     endif
     kvertf = 0
     !
+    allocate(cntv1  (nverts   ))
+    allocate(cntv2  (nverts   ))
+    allocate(iflist1(nverts,10))
+    allocate(iflist2(nverts,10))
+    !
+    cntv1   =  0
+    cntv2   =  0
+    iflist1 = -1
+    iflist2 = -2
+    !
     nfaces = 0
     !
     do j = 1, ncells
@@ -101,27 +120,76 @@
        !
        kloop: do k = 1, 3
           !
-          iface = 0
-          do
-             iface = iface + 1
-             if (iface > nfaces) exit
-             v1 = kvertf(1,iface)
-             v2 = kvertf(2,iface)
-             if ((vf(1,k)==v1 .or. vf(2,k)==v1) .and. (vf(1,k)==v2 .or. vf(2,k)==v2)) cycle kloop
-          enddo
+          ! get two vertices of a face
+          !
+          v1 = vf(1,k)
+          v2 = vf(2,k)
+          !
+          ! search for identification number of that face
+          !
+          facefound = .false.
+          !
+          mloop: do m = 1, 10
+             !
+             iface = iflist1(v1,m)
+             !
+             do n = 1, 10
+                if ( iflist2(v2,n) == iface ) then
+                   facefound = .true.
+                   exit mloop
+                endif
+             enddo
+             !
+          enddo mloop
+          !
+          if ( .not.facefound ) then
+             !
+             nloop: do n = 1, 10
+                !
+                iface = iflist2(v1,n)
+                !
+                do m = 1, 10
+                   if ( iflist1(v2,m) == iface ) then
+                      facefound = .true.
+                      exit nloop
+                   endif
+                enddo
+                !
+             enddo nloop
+             !
+          endif
+          !
+          if ( facefound ) cycle kloop
           !
           nfaces = nfaces + 1
           if ( nfaces > maxnf ) then
              call msgerr ( 4, 'inconsistency found in SwanCreateEdges: more than maximum allowable faces found ' )
-             goto 900
+             return
+          endif
+          !
+          m = cntv1(v1) +1
+          if ( m > 10 ) then
+             call msgerr ( 4, 'SwanCreateEdges: more than 10 faces around vertex ' )
+             return
           endif
-          kvertf(1,nfaces) = vf(1,k)
-          kvertf(2,nfaces) = vf(2,k)
+          cntv1  (v1  ) = m
+          iflist1(v1,m) = nfaces
+          !
+          m = cntv2(v2) +1
+          if ( m > 10 ) then
+             call msgerr ( 4, 'SwanCreateEdges: more than 10 faces around vertex ' )
+             return
+          endif
+          cntv2  (v2  ) = m
+          iflist2(v2,m) = nfaces
+          !
+          kvertf(1,nfaces) = v1
+          kvertf(2,nfaces) = v2
           !
        enddo kloop
        !
     enddo
     !
- 900 return
+    deallocate(cntv1,cntv2,iflist1,iflist2)
     !
 end subroutine SwanCreateEdges
--- swan.edt	2008-05-25 14:59:38.000000000 +0200
+++ swan.edt	2008-10-15 11:57:40.000000000 +0200
@@ -187,14 +187,16 @@
 !          <  DSPR|HSIGN|DIR|PDIR|TDIR|TM01|RTM01|RTP|TM02|FSPR|DEPTH|VEL|  &
 !             FRCOEFF|WIND|DISSIP|QB|TRANSP|FORCE|UBOT|URMS|WLEN|STEEPNESS| &
 !             DHSIGN|DRTM01|LEAK|TSEC|XP|YP|DIST|SETUP|TMM10|RTMM10|        &
-!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP  >      &
+!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP|        &
+!             GENE|GENW|REDI|REDQ|REDT|PROPA|PROPX|PROPT|PROPS|RADS >       &
 !             ([unit]) (OUTPUT [tbegblk] [deltblk] SEC|MIN|HR|DAY)
 !
 !   TABLE   'sname'  HEADER | NOHEADER | INDEXED 'fname'                    &
 !          <  DSPR|HSIGN|DIR|PDIR|TDIR|TM01|RTM01|RTP|TM02|FSPR|DEPTH|VEL|  &
 !             FRCOEFF|WIND|DISSIP|QB|TRANSP|FORCE|UBOT|URMS|WLEN|STEEPNESS| &
 !             DHSIGN|DRTM01|LEAK|TIME|TSEC|XP|YP|DIST|SETUP|TMM10|RTMM10|   &
-!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP  >      &
+!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP|        &
+!             GENE|GENW|REDI|REDQ|REDT|PROPA|PROPX|PROPT|PROPS|RADS >       &
 !             ([unit]) (OUTPUT [tbegtbl] [delttbl] SEC|MIN|HR|DAY)
 !
 !   SPECout 'sname'  SPEC1D|SPEC2D  ABS|REL   'fname'                       &
--- SwanGridCell.ftn90	2008-05-25 14:59:43.000000000 +0200
+++ SwanGridCell.ftn90	2008-10-15 11:57:43.000000000 +0200
@@ -70,7 +70,7 @@
 !
     integer                               :: icell    ! loop counter over cells / index of present cell
     integer, save                         :: ient = 0 ! number of entries in this subroutine
-    integer                               :: ivert    ! loop counter over vertices
+    integer                               :: ivert    ! loop counter over vertices / index of present vertex
     integer                               :: j        ! loop counter
     integer                               :: jcell    ! index of next cell
     integer                               :: k        ! auxiliary integer / loop counter
@@ -82,6 +82,8 @@
     integer                               :: vn       ! first upwave vertex of next cell
     integer                               :: vp       ! last upwave vertex of present cell
     !
+    integer, dimension(:), allocatable    :: ivlist   ! list of index vertices
+    !
     real                                  :: carea    ! area of the present cell (triangles only)
     real                                  :: dx1      ! first component of covariant base vector a_(1)
     real                                  :: dx2      ! second component of covariant base vector a_(1)
@@ -228,38 +230,45 @@
        !
     enddo
     !
+    allocate(ivlist(nverts))
+    !
     ! loop over all vertices
     !
     do ivert = 1, nverts
        !
-       ! identify the considered vertex
+       ! identify the considered vertex and store index
        !
        vc = vert(ivert)%atti(VERTID)
+       ivlist(vc) = ivert
        !
-       ! search for cells around that vertex
+       ! initialize number of cells around vertex
        !
-       noc   = 0
-       icell = 0
- 10    continue
-       do
-          icell = icell + 1
-          if (icell > ncells) goto 20
-          v(1) = cell(icell)%atti(CELLV1)
-          v(2) = cell(icell)%atti(CELLV2)
-          v(3) = cell(icell)%atti(CELLV3)
-          if (v(1) == vc .or. v(2) == vc .or. v(3) == vc) exit
-       enddo
+       vert(ivert)%noc = 0
+       !
+    enddo
+    !
+    do icell = 1, ncells
        !
-       noc = noc + 1
+       v(1) = cell(icell)%atti(CELLV1)
+       v(2) = cell(icell)%atti(CELLV2)
+       v(3) = cell(icell)%atti(CELLV3)
        !
-       vert(ivert)%cell(noc)%atti(CELLID) = icell
+       ! add present cell to each of these vertices
        !
-       goto 10
- 20    continue
-       vert(ivert)%noc = noc
+       do j = 1, nov
+          !
+          ivert = ivlist(v(j))
+          noc   = vert(ivert)%noc +1
+          !
+          vert(ivert)%noc = noc
+          vert(ivert)%cell(noc)%atti(CELLID) = icell
+          !
+       enddo
        !
     enddo
     !
+    deallocate(ivlist)
+    !
     do ivert = 1, nverts
        !
        noc = vert(ivert)%noc
--- SwanGriddata.ftn90	2008-05-25 14:59:43.000000000 +0200
+++ SwanGriddata.ftn90	2008-10-15 11:57:43.000000000 +0200
@@ -61,9 +61,9 @@
 !
     integer                                    :: grid_generator ! used grid generator
     !
-    integer                                    :: nverts         ! number of vertices in grid
     integer                                    :: ncells         ! number of cells in grid
     integer                                    :: nfaces         ! number of faces in grid
+    integer                                    :: nverts         ! number of vertices in grid
     !
     integer, dimension(:,:), save, allocatable :: kvertc         !
     integer, dimension(:,:), save, allocatable :: kvertf         !
--- SwanGridFace.ftn90	2008-05-25 14:59:43.000000000 +0200
+++ SwanGridFace.ftn90	2008-10-15 11:57:43.000000000 +0200
@@ -66,28 +66,36 @@
 !
 !   Local variables
 !
-    integer                               :: icell    ! loop counter over cells
-    integer                               :: icell1   ! sequence number of cell 1 adjacent to present face
-    integer                               :: icell2   ! sequence number of cell 2 adjacent to present face
-    integer                               :: iface    ! loop counter over faces
-    integer, save                         :: ient = 0 ! number of entries in this subroutine
-    integer                               :: ivert    ! loop counter over vertices
-    integer                               :: jc       ! loop counter
-    integer                               :: jf       ! loop counter
-    integer                               :: v1       ! first vertex of present face
-    integer                               :: vl1      ! first vertex of local face for given cell
-    integer                               :: v2       ! second vertex of present face
-    integer                               :: vl2      ! second vertex of local face for given cell
-    !
-    real                                  :: carea1   ! area of cell 1 adjacent to present face
-    real                                  :: carea2   ! area of cell 2 adjacent to present face
-    real                                  :: lengthf  ! length of present face
-    real                                  :: xdiff    ! difference in x-coordinate between vertex 2 and vertex 1
-    real                                  :: ydiff    ! difference in y-coordinate between vertex 2 and vertex 1
-    !
-    type(celltype), dimension(:), pointer :: cell     ! datastructure for cells with their attributes
-    type(facetype), dimension(:), pointer :: face     ! datastructure for faces with their attributes
-    type(verttype), dimension(:), pointer :: vert     ! datastructure for vertices with their attributes
+    integer                               :: icell     ! loop counter over cells
+    integer                               :: icell1    ! sequence number of cell 1 adjacent to present face
+    integer                               :: icell2    ! sequence number of cell 2 adjacent to present face
+    integer                               :: iface     ! loop counter over faces
+    integer, save                         :: ient = 0  ! number of entries in this subroutine
+    integer                               :: ivert     ! loop counter over vertices
+    integer                               :: j         ! loop counter
+    integer                               :: jf        ! loop counter
+    integer                               :: k         ! counter
+    integer                               :: v1        ! first vertex of present face
+    integer                               :: vl1       ! first vertex of local face for given cell
+    integer                               :: v2        ! second vertex of present face
+    integer                               :: vl2       ! second vertex of local face for given cell
+    !
+    integer, dimension(:  ), allocatable  :: cntv1     ! array of vertex counter for for vertex 1
+    integer, dimension(:  ), allocatable  :: cntv2     ! array of vertex counter for for vertex 2
+    integer, dimension(:,:), allocatable  :: iflist1   ! list of index faces stored for vertex 1
+    integer, dimension(:,:), allocatable  :: iflist2   ! list of index faces stored for vertex 2
+    !
+    real                                  :: carea1    ! area of cell 1 adjacent to present face
+    real                                  :: carea2    ! area of cell 2 adjacent to present face
+    real                                  :: lengthf   ! length of present face
+    real                                  :: xdiff     ! difference in x-coordinate between vertex 2 and vertex 1
+    real                                  :: ydiff     ! difference in y-coordinate between vertex 2 and vertex 1
+    !
+    logical                               :: facefound ! true if face is found
+    !
+    type(celltype), dimension(:), pointer :: cell      ! datastructure for cells with their attributes
+    type(facetype), dimension(:), pointer :: face      ! datastructure for faces with their attributes
+    type(verttype), dimension(:), pointer :: vert      ! datastructure for vertices with their attributes
 !
 !   Structure
 !
@@ -141,6 +149,39 @@
        !
     enddo
     !
+    allocate(cntv1  (nverts   ))
+    allocate(cntv2  (nverts   ))
+    allocate(iflist1(nverts,10))
+    allocate(iflist2(nverts,10))
+    !
+    cntv1   =  0
+    cntv2   =  0
+    iflist1 = -1
+    iflist2 = -2
+    !
+    do iface = 1, nfaces
+       !
+       v1 = face(iface)%atti(FACEV1)
+       v2 = face(iface)%atti(FACEV2)
+       !
+       k = cntv1(v1) +1
+       if ( k > 10 ) then
+          call msgerr ( 4, 'SwanGridFace: more than 10 faces around vertex ' )
+          return
+       endif
+       cntv1  (v1  ) = k
+       iflist1(v1,k) = iface
+       !
+       k = cntv2(v2) +1
+       if ( k > 10 ) then
+          call msgerr ( 4, 'SwanGridFace: more than 10 faces around vertex ' )
+          return
+       endif
+       cntv2  (v2  ) = k
+       iflist2(v2,k) = iface
+       !
+    enddo
+    !
     ! loop over all cells
     !
     do icell = 1, ncells
@@ -156,20 +197,47 @@
           !
           ! search for identification number of that face
           !
-          iface = 1
-          do
-             v1 = face(iface)%atti(FACEV1)
-             v2 = face(iface)%atti(FACEV2)
-             if ((v1==vl1 .or. v1==vl2) .and. (v2==vl1 .or. v2==vl2)) exit
-             iface = iface + 1
-             if (iface > nfaces) exit
-          enddo
-          if ( iface > nfaces ) then
-             call msgerr ( 4, 'inconsistency found in SwanGridFace: no faces found ' )
+          facefound = .false.
+          !
+          kloop: do k = 1, 10
+             !
+             iface = iflist1(vl1,k)
+             !
+             do j = 1, 10
+                if ( iflist2(vl2,j) == iface ) then
+                   facefound = .true.
+                   exit kloop
+                endif
+             enddo
+             !
+          enddo kloop
+          !
+          if ( .not.facefound ) then
+             !
+             jloop: do j = 1, 10
+                !
+                iface = iflist2(vl1,j)
+                !
+                do k = 1, 10
+                   if ( iflist1(vl2,k) == iface ) then
+                      facefound = .true.
+                      exit jloop
+                   endif
+                enddo
+                !
+             enddo jloop
+             !
+          endif
+          !
+          if ( facefound ) then
+             cell(icell)%face(jf)%atti(FACEID) = iface
+          else
+             call msgerr ( 4, 'inconsistency found in SwanGridFace: no face found ' )
              return
           endif
           !
-          cell(icell)%face(jf)%atti(FACEID) = iface
+          v1 = face(iface)%atti(FACEV1)
+          v2 = face(iface)%atti(FACEV2)
           !
           ! Requirement: face(iface)%atti(FACEC1) < face(iface)%atti(FACEC2)
           !
@@ -193,6 +261,8 @@
        !
     enddo
     !
+    deallocate(cntv1,cntv2,iflist1,iflist2)
+    !
     ! loop over all faces
     !
     do iface = 1, nfaces
--- SwanGridobjects.ftn90	2008-05-25 14:59:44.000000000 +0200
+++ SwanGridobjects.ftn90	2008-10-15 11:57:43.000000000 +0200
@@ -32,10 +32,12 @@
 !   Authors
 !
 !   40.80: Marcel Zijlema
+!   40.92: Marcel Zijlema
 !
 !   Updates
 !
 !   40.80, July 2007: New Module
+!   40.92, June 2008: new attribute for vertices: BPOL
 !
 !   Purpose
 !
@@ -59,7 +61,7 @@
     integer, parameter :: MINVERTCELL = 4   ! mininum number of cells around a vertex
     integer, parameter :: MAXVERTCELL = 10  ! maximum number of cells around a vertex
     !
-    integer, parameter :: MAXVERTATTI = 6   ! maximum number of attributes of type integer
+    integer, parameter :: MAXVERTATTI = 7   ! maximum number of attributes of type integer
                                             ! in data structure of vertices
     integer, parameter :: VERTID  = 1       ! identification number
     integer, parameter :: VMARKER = 2       ! boundary marker for vertices
@@ -71,6 +73,7 @@
     integer, parameter :: VERTF1  = 4       ! first face connecting to present vertex
     integer, parameter :: VERTF2  = 5       ! second face connecting to present vertex
     integer, parameter :: BINDX   = 6       ! indices for boundary points in ascending order
+    integer, parameter :: BPOL    = 7       ! sequence number of boundary polygons
     !
     integer, parameter :: MAXVERTATTR = 2   ! maximum number of attributes of type real
                                             ! in data structure of vertices
--- SwanInterpolateAc.ftn90	2008-05-25 14:59:44.000000000 +0200
+++ SwanInterpolateAc.ftn90	2008-10-15 11:57:44.000000000 +0200
@@ -32,10 +32,12 @@
 !   Authors
 !
 !   40.80: Marcel Zijlema
+!   40.90: Nico Booij
 !
 !   Updates
 !
 !   40.80, August 2007: New subroutine
+!   40.90,   June 2008: improved interpolation near obstacles
 !
 !   Purpose
 !
@@ -43,15 +45,17 @@
 !
 !   Method
 !
-!   First, look for closest vertex and next,
-!   interpolate action density inside triangle
-!   where given point is resided
+!   Look for closest vertex and determine triangle in which given point is located
+!   Determine weighting coefficients for the corresponding vertices
+!   Set weighting coeff to zero if there is an obstacle between given point and vertex
+!   Interpolate action density using the resulting weighting coefficients
 !
 !   Modules used
 !
     use ocpcomm4
     use swcomm2
     use swcomm3
+    use m_obsta
     use SwanGriddata
     use SwanGridobjects
 !
@@ -69,35 +73,42 @@
 !
     integer                               :: icell     ! cell index
     integer, save                         :: ient = 0  ! number of entries in this subroutine
+    integer, dimension(3)                 :: ivc       ! vertex indices in cyclic order
     integer                               :: ivert     ! vertex index
     integer                               :: jc        ! loop counter
     integer                               :: k         ! loop counter
+    integer                               :: l         ! loop counter
+    integer                               :: numcor    ! number of corner points in an obstacle
     integer, dimension(3)                 :: v         ! vertices in present cell
     !
-    real                                  :: carea     ! area of the present cell
     real                                  :: dxp       ! distance between given point and present vertex in x-direction
+    real, dimension (3)                   :: dxv       ! difference of vertices of opposite side in x-coordinate
     real                                  :: dyp       ! distance between given point and present vertex in y-direction
+    real, dimension (3)                   :: dyv       ! difference of vertices of opposite side in y-coordinate
     real                                  :: eps       ! a small number
-    real, dimension(MDC,MSC)              :: phi1      ! value of action density in first vertex of considered cell
-    real, dimension(MDC,MSC)              :: phi2      ! value of action density in second vertex of considered cell
-    real, dimension(MDC,MSC)              :: phi3      ! value of action density in third vertex of considered cell
-    real, dimension(MDC,MSC)              :: phic      ! value of action density in centroid of considered cell
+    real                                  :: sumww     ! sum of the interpolation weights
     real                                  :: th        ! direction of given point to present vertex
     real                                  :: th1       ! direction of one face pointing to present vertex
     real                                  :: th2       ! direction of another face pointing to present vertex
     real                                  :: thdiff    ! difference between th and th2
-    real, dimension(2)                    :: vec12     ! translation vector of coordinates: vertex2 - vertex1
-    real, dimension(2)                    :: vec23     ! translation vector of coordinates: vertex3 - vertex2
-    real, dimension(2)                    :: vec31     ! translation vector of coordinates: vertex1 - vertex3
-    real                                  :: xc        ! x-coordinate of the cell-centroid
-    real                                  :: yc        ! y-coordinate of the cell-centroid
-    real, dimension(MDC,MSC)              :: xgrs      ! x-component of gradient vector of action density
-    real, dimension(MDC,MSC)              :: ygrs      ! y-component of gradient vector of action density
+    real                                  :: xb        ! user x-coordinate of begin of obstacle side
+    real                                  :: xe        ! user x-coordinate of end of obstacle side
+    real, dimension (3)                   :: xv        ! x-coordinate of the vertex
+    real                                  :: yb        ! user y-coordinate of begin of obstacle side
+    real                                  :: ye        ! user y-coordinate of end of obstacle side
+    real, dimension (3)                   :: yv        ! y-coordinate of the vertex
+    real, dimension (3)                   :: ww        ! weight of each vertex in the interpolation
     !
     character(80)                         :: msgstr    ! string to pass message
     !
     logical                               :: cellfound ! indicate whether cell containing given point is found or not
+    logical, dimension (3)                :: cross     ! if true there is an obstacle between given point and vertex
     logical                               :: EQREAL    ! indicate whether two reals are equal or not
+    logical                               :: obstcell  ! if true there is an obstacle in cell
+    logical                               :: TCROSS    ! determines whether two line segments cross
+    logical                               :: xonobst   ! not used
+    !
+    type(OBSTDAT), pointer                :: COBST     ! pointer to obstacle data
     !
     type(celltype), dimension(:), pointer :: cell      ! datastructure for cells with their attributes
     type(verttype), dimension(:), pointer :: vert      ! datastructure for vertices with their attributes
@@ -125,17 +136,9 @@
     !
     call SwanFindPoint ( x, y, ivert )
     !
-    ! if point not found, give warning and return
-    !
-    if ( ivert < 0 ) then
-       write (msgstr, '(a,f12.4,a,f12.4,a)') ' Point (',x+XOFFS,',',y+YOFFS,') is outside computational grid'
-       !call msgerr( 1, trim(msgstr) )
-       return
-    endif
-    !
-    ! if closest vertex is not active, return
+    ! if point not found, return
     !
-    !if ( .not.vert(ivert)%active ) return
+    if ( ivert < 0 ) return
     !
     ! determine direction of given point to closest vertex
     !
@@ -205,51 +208,92 @@
        return
     endif
     !
-    ! 2D linear interpolation on considered triangle is carried out only if all vertices are active
+    ! 2D linear interpolation on considered triangle is carried out now
     !
-    !if ( vert(v(1))%active .and. vert(v(2))%active .and. vert(v(3))%active ) then
-       !
-       excpt = .false.
-       !
-       ! determine centroid and area of found cell
-       !
-       xc    = cell(icell)%attr(CELLCX  )
-       yc    = cell(icell)%attr(CELLCY  )
-       carea = cell(icell)%attr(CELLAREA)
-       !
-       ! determine action density in vertices and in centroid
-       !
-       phi1(:,:) = ac2(:,:,v(1))
-       phi2(:,:) = ac2(:,:,v(2))
-       phi3(:,:) = ac2(:,:,v(3))
-       !
-       phic = ( phi1 + phi2 + phi3 ) / 3.
-       !
-       ! determine translation vectors of found cell
-       !
-       vec12(1) = xcugrd(v(2)) - xcugrd(v(1))
-       vec12(2) = ycugrd(v(2)) - ycugrd(v(1))
-       vec23(1) = xcugrd(v(3)) - xcugrd(v(2))
-       vec23(2) = ycugrd(v(3)) - ycugrd(v(2))
-       vec31(1) = xcugrd(v(1)) - xcugrd(v(3))
-       vec31(2) = ycugrd(v(1)) - ycugrd(v(3))
-       !
-       ! determine gradient vector inside found cell based on outward normals
-       ! Note: the outward normal is obtained by rotating the translation vector
-       !       over 90 degrees in clockwise direction
-       !
-       xgrs =  vec23(2)*phi1 + vec31(2)*phi2 + vec12(2)*phi3
-       ygrs = -vec23(1)*phi1 - vec31(1)*phi2 - vec12(1)*phi3
-       !
-       xgrs = -0.5*xgrs/carea
-       ygrs = -0.5*ygrs/carea
-       !
-       ! determine action density inside considered triangle by means of 2D interpolation
-       ! using constant gradient vector of action density
-       ! Note: since, ac2 can be very small (e.g., <1e-20) the result of interpolation can be negative
-       !
-       acintp = max(0.,phic + xgrs*(x - xc) + ygrs*(y - yc))
+    excpt = .false.
+    !
+    !  get coordinates of the vertices
+    !
+    do k = 1, 3
+       xv(k) = xcugrd(v(k))
+       yv(k) = ycugrd(v(k))
+       cross(k) = .false.
+    enddo
+    !
+    ! determine difference in x and y of opposite side
+    !
+    do k = 1, 3
+       ivc(2) = mod(k  ,3)+1
+       ivc(3) = mod(k+1,3)+1
+       dxv(k) = xv(ivc(3)) - xv(ivc(2))
+       dyv(k) = yv(ivc(3)) - yv(ivc(2))
+    enddo
+    !
+    ! determine whether there is an obstacle between given point and vertices
+    !
+    if ( NUMOBS > 0 ) then
+       !
+       COBST => FOBSTAC
+       !
+       do jc = 1, NUMOBS
+          !
+          numcor = COBST%NCRPTS
+          if ( ITEST >= 120 ) write (PRINTF,10) jc, numcor
+          !
+          xb = COBST%XCRP(1)
+          yb = COBST%YCRP(1)
+          if ( ITEST >= 120 ) write (PRINTF,20) 1, xb+XOFFS, yb+YOFFS
+          !
+          do l = 2, numcor
+             !
+             xe = COBST%XCRP(l)
+             ye = COBST%YCRP(l)
+             if ( ITEST >= 120 ) write (PRINTF,20) l, xe+XOFFS, ye+YOFFS
+             !
+             ! loop over vertices
+             !
+             do k = 1, 3
+                if ( TCROSS(x, xv(k), xb, xe, y, yv(k), yb, ye, xonobst) ) cross(k) = .true.
+             enddo
+             !
+             xb = xe
+             yb = ye
+             !
+          enddo
+          !
+          if (.not.associated(COBST%NEXTOBST)) exit
+          COBST => COBST%NEXTOBST
+          !
+       enddo
        !
-    !endif
+    endif
+    !
+    ! determine weighting coefficients
+    !
+    obstcell = .false.
+    do k = 1, 3
+       if (cross(k)) then
+          ww(k) = 0.
+          obstcell = .true.
+       else
+          ivc(1) = k
+          ivc(2) = mod(k  ,3)+1
+          ivc(3) = mod(k+1,3)+1
+          ww(k) = ((x - xv(ivc(3))) * dyv(ivc(1)) - (y - yv(ivc(3))) * dxv(ivc(1))) / ( dxv(ivc(2)) * dyv(ivc(1)) - dyv(ivc(2)) * dxv(ivc(1)) )
+       endif
+    enddo
+    if (obstcell) sumww = sum(ww)
+    !
+    ! use weighting coefficients to determine interpolated action density
+    !
+    do k = 1, 3
+       if ( ww(k) > 1.e-10 ) then
+          if (obstcell) ww(k) = ww(k) / sumww
+          acintp(:,:) = acintp(:,:) + ww(k) * ac2(:,:,v(k))
+       endif
+    enddo
+    !
+ 10 format (' Obstacle number : ', i4,'  has ', i4, ' corners')
+ 20 format (' Corner number:', i4,'    Xp: ', e10.4, ' Yp: ', e11.4)
     !
 end subroutine SwanInterpolateAc
--- SwanInterpolateOutput.ftn90	2008-05-25 14:59:44.000000000 +0200
+++ SwanInterpolateOutput.ftn90	2008-10-15 11:57:44.000000000 +0200
@@ -32,10 +32,12 @@
 !   Authors
 !
 !   40.80: Marcel Zijlema
+!   40.90: Nico Booij
 !
 !   Updates
 !
 !   40.80, August 2007: New subroutine
+!   40.90,   June 2008: improved interpolation near obstacles
 !
 !   Purpose
 !
@@ -43,15 +45,17 @@
 !
 !   Method
 !
-!   First, for each given point look for closest vertex and next,
-!   interpolate given output quantity inside triangle where given
-!   point is resided
+!   Look for closest vertex and determine triangle in which given point is located
+!   Determine weighting coefficients for the corresponding vertices
+!   Set weighting coeff to zero if there is an obstacle between given point and vertex
+!   Interpolate output quantity using the resulting weighting coefficients
 !
 !   Modules used
 !
     use ocpcomm4
     use swcomm2
     use swcomm3
+    use m_obsta
     use SwanGriddata
     use SwanGridobjects
 !
@@ -72,35 +76,42 @@
     integer                               :: icell     ! cell index
     integer, save                         :: ient = 0  ! number of entries in this subroutine
     integer                               :: ip        ! loop counter
+    integer, dimension(3)                 :: ivc       ! vertex indices in cyclic order
     integer                               :: ivert     ! vertex index
     integer                               :: jc        ! loop counter
     integer                               :: k         ! loop counter
+    integer                               :: l         ! loop counter
+    integer                               :: numcor    ! number of corner points in an obstacle
     integer, dimension(3)                 :: v         ! vertices in present cell
     !
-    real                                  :: carea     ! area of the present cell
     real                                  :: dxp       ! distance between given point and present vertex in x-direction
+    real, dimension (3)                   :: dxv       ! difference of vertices of opposite side in x-coordinate
     real                                  :: dyp       ! distance between given point and present vertex in y-direction
+    real, dimension (3)                   :: dyv       ! difference of vertices of opposite side in y-coordinate
     real                                  :: eps       ! a small number
-    real                                  :: phi1      ! value of output quantity in first vertex of considered cell
-    real                                  :: phi2      ! value of output quantity in second vertex of considered cell
-    real                                  :: phi3      ! value of output quantity in third vertex of considered cell
-    real                                  :: phic      ! value of output quantity in centroid of considered cell
+    real                                  :: sumww     ! sum of the interpolation weights
     real                                  :: th        ! direction of given point to present vertex
     real                                  :: th1       ! direction of one face pointing to present vertex
     real                                  :: th2       ! direction of another face pointing to present vertex
     real                                  :: thdiff    ! difference between th and th2
-    real, dimension(2)                    :: vec12     ! translation vector of coordinates: vertex2 - vertex1
-    real, dimension(2)                    :: vec23     ! translation vector of coordinates: vertex3 - vertex2
-    real, dimension(2)                    :: vec31     ! translation vector of coordinates: vertex1 - vertex3
-    real                                  :: xc        ! x-coordinate of the cell-centroid
-    real                                  :: yc        ! y-coordinate of the cell-centroid
-    real                                  :: xgrs      ! x-component of gradient vector of output quantity
-    real                                  :: ygrs      ! y-component of gradient vector of output quantity
+    real                                  :: xb        ! user x-coordinate of begin of obstacle side
+    real                                  :: xe        ! user x-coordinate of end of obstacle side
+    real, dimension (3)                   :: xv        ! x-coordinate of the vertex
+    real                                  :: yb        ! user y-coordinate of begin of obstacle side
+    real                                  :: ye        ! user y-coordinate of end of obstacle side
+    real, dimension (3)                   :: yv        ! y-coordinate of the vertex
+    real, dimension (3)                   :: ww        ! weight of each vertex in the interpolation
     !
     character(80)                         :: msgstr    ! string to pass message
     !
     logical                               :: cellfound ! indicate whether cell containing given point is found or not
+    logical, dimension (3)                :: cross     ! if true there is an obstacle between given point and vertex
     logical                               :: EQREAL    ! indicate whether two reals are equal or not
+    logical                               :: obstcell  ! if true there is an obstacle in cell
+    logical                               :: TCROSS    ! determines whether two line segments cross
+    logical                               :: xonobst   ! not used
+    !
+    type(OBSTDAT), pointer                :: COBST     ! pointer to obstacle data
     !
     type(celltype), dimension(:), pointer :: cell      ! datastructure for cells with their attributes
     type(verttype), dimension(:), pointer :: vert      ! datastructure for vertices with their attributes
@@ -130,13 +141,9 @@
        !
        call SwanFindPoint ( x(ip), y(ip), ivert )
        !
-       ! if point not found, give warning and go to next point
+       ! if point not found, go to next point
        !
-       if ( ivert < 0 ) then
-          write (msgstr, '(a,f12.4,a,f12.4,a)') ' Point (',x(ip)+XOFFS,',',y(ip)+YOFFS,') is outside computational grid'
-          !call msgerr( 1, trim(msgstr) )
-          cycle pointloop
-       endif
+       if ( ivert < 0 ) cycle pointloop
        !
        ! if closest vertex is not active, go to next point
        !
@@ -213,46 +220,92 @@
        !
        if ( vert(v(1))%active .and. vert(v(2))%active .and. vert(v(3))%active ) then
           !
-          ! determine centroid and area of found cell
-          !
-          xc    = cell(icell)%attr(CELLCX  )
-          yc    = cell(icell)%attr(CELLCY  )
-          carea = cell(icell)%attr(CELLAREA)
-          !
-          ! determine output quantity in vertices and in centroid
+          !  get coordinates of the vertices
           !
-          phi1 = finp(v(1))
-          phi2 = finp(v(2))
-          phi3 = finp(v(3))
+          do k = 1, 3
+             xv(k) = xcugrd(v(k))
+             yv(k) = ycugrd(v(k))
+             cross(k) = .false.
+          enddo
           !
-          phic = ( phi1 + phi2 + phi3 ) / 3.
+          ! determine difference in x and y of opposite side
           !
-          ! determine translation vectors of found cell
+          do k = 1, 3
+             ivc(2) = mod(k  ,3)+1
+             ivc(3) = mod(k+1,3)+1
+             dxv(k) = xv(ivc(3)) - xv(ivc(2))
+             dyv(k) = yv(ivc(3)) - yv(ivc(2))
+          enddo
           !
-          vec12(1) = xcugrd(v(2)) - xcugrd(v(1))
-          vec12(2) = ycugrd(v(2)) - ycugrd(v(1))
-          vec23(1) = xcugrd(v(3)) - xcugrd(v(2))
-          vec23(2) = ycugrd(v(3)) - ycugrd(v(2))
-          vec31(1) = xcugrd(v(1)) - xcugrd(v(3))
-          vec31(2) = ycugrd(v(1)) - ycugrd(v(3))
+          ! determine whether there is an obstacle between given point and vertices
           !
-          ! determine gradient vector inside found cell based on outward normals
-          ! Note: the outward normal is obtained by rotating the translation vector
-          !       over 90 degrees in clockwise direction
+          if ( NUMOBS > 0 ) then
+             !
+             COBST => FOBSTAC
+             !
+             do jc = 1, NUMOBS
+                !
+                numcor = COBST%NCRPTS
+                if ( ITEST >= 120 ) write (PRINTF,10) jc, numcor
+                !
+                xb = COBST%XCRP(1)
+                yb = COBST%YCRP(1)
+                if ( ITEST >= 120 ) write (PRINTF,20) 1, xb+XOFFS, yb+YOFFS
+                !
+                do l = 2, numcor
+                   !
+                   xe = COBST%XCRP(l)
+                   ye = COBST%YCRP(l)
+                   if ( ITEST >= 120 ) write (PRINTF,20) l, xe+XOFFS, ye+YOFFS
+                   !
+                   ! loop over vertices
+                   !
+                   do k = 1, 3
+                      if ( TCROSS(x(ip), xv(k), xb, xe, y(ip), yv(k), yb, ye, xonobst) ) cross(k) = .true.
+                   enddo
+                   !
+                   xb = xe
+                   yb = ye
+                   !
+                enddo
+                !
+                if (.not.associated(COBST%NEXTOBST)) exit
+                COBST => COBST%NEXTOBST
+                !
+             enddo
+             !
+          endif
           !
-          xgrs =  vec23(2)*phi1 + vec31(2)*phi2 + vec12(2)*phi3
-          ygrs = -vec23(1)*phi1 - vec31(1)*phi2 - vec12(1)*phi3
+          ! determine weighting coefficients
           !
-          xgrs = -0.5*xgrs/carea
-          ygrs = -0.5*ygrs/carea
+          obstcell = .false.
+          do k = 1, 3
+             if (cross(k)) then
+                ww(k) = 0.
+                obstcell = .true.
+             else
+                ivc(1) = k
+                ivc(2) = mod(k  ,3)+1
+                ivc(3) = mod(k+1,3)+1
+                ww(k) = ((x(ip) - xv(ivc(3))) * dyv(ivc(1)) - (y(ip) - yv(ivc(3))) * dxv(ivc(1))) / ( dxv(ivc(2)) * dyv(ivc(1)) - dyv(ivc(2)) * dxv(ivc(1)) )
+             endif
+          enddo
+          if (obstcell) sumww = sum(ww)
           !
-          ! determine output quantity inside considered triangle by means of 2D interpolation
-          ! using constant gradient vector of output quantity
+          ! use weighting coefficients to determine interpolated output quantity
           !
-          foutp(ip) = phic + xgrs*(x(ip) - xc) + ygrs*(y(ip) - yc)
+          do k = 1, 3
+             if ( ww(k) > 1.e-10 ) then
+                if (obstcell) ww(k) = ww(k) / sumww
+             endif
+          enddo
+          foutp(ip) = sum (ww(:) * finp(v(:)))
           !
        endif
        !
     enddo pointloop
     !
+ 10 format (' Obstacle number : ', i4,'  has ', i4, ' corners')
+ 20 format (' Corner number:', i4,'    Xp: ', e10.4, ' Yp: ', e11.4)
+    !
 end subroutine SwanInterpolateOutput
--- swanmain.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swanmain.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -259,7 +259,6 @@
       INTEGER   IUNIT                                                     34.01
       INTEGER   IOSTAT, IT0, IT, SAVITE, ILEN                             40.30
       INTEGER   INERR                                                     40.31
-      INTEGER   IERR                                                      40.31 40.00
       INTEGER   ISTAT, IF1, IL1                                           40.41
       CHARACTER PTYPE, PNAME *8, COMPUT *4, DTTIWR*18                     40.00
       CHARACTER*20 NUMSTR, CHARS(1)                                       40.41
@@ -850,7 +849,7 @@
       VERTXT = BLANK                                                      40.03
       VERNUM = 40.72
       WRITE (VERTXT, '(F5.2)') VERNUM                                     40.03
-!FIX      CALL BUGFIX ('A')
+      CALL BUGFIX ('A')
 !
       CALL OCPINI ('swaninit', .TRUE.,INERR)                              34.01
       IF (INERR.GT.0) RETURN                                              34.01
@@ -1288,6 +1287,16 @@
       JDSXB  = 1                                                          40.65 40.61
       JDSXS  = 1                                                          40.65 40.61
       JDSXW  = 1                                                          40.65 40.61
+      JGENR  = 1                                                          40.85
+      JGSXW  = 1                                                          40.85
+      JREDS  = 1                                                          40.85
+      JRSXQ  = 1                                                          40.85
+      JRSXT  = 1                                                          40.85
+      JTRAN  = 1                                                          40.85
+      JTSXG  = 1                                                          40.85
+      JTSXT  = 1                                                          40.85
+      JTSXS  = 1                                                          40.85
+      JRADS  = 1                                                          40.85
 !
 !     Next pointers are for the plot of the source terms (SWTSDA)         40.31
 !
@@ -1977,7 +1986,7 @@
 !
       IVTYPE = 54
       OVKEYW(IVTYPE) = 'DISB'                                             40.61
-      OVSNAM(IVTYPE) = 'Disbot'
+      OVSNAM(IVTYPE) = 'Sfric'                                            40.85
       OVLNAM(IVTYPE) = 'Bottom friction dissipation'
       OVUNIT(IVTYPE) = 'm2/s'
       OVSVTY(IVTYPE) = 1
@@ -1989,8 +1998,8 @@
 !
       IVTYPE = 55
       OVKEYW(IVTYPE) = 'DISSU'                                            40.61
-      OVSNAM(IVTYPE) = 'Dissrf'
-      OVLNAM(IVTYPE) = 'Wave breaking dissipation'
+      OVSNAM(IVTYPE) = 'Ssurf'                                            40.85
+      OVLNAM(IVTYPE) = 'Surf breaking dissipation'                        40.85
       OVUNIT(IVTYPE) = 'm2/s'
       OVSVTY(IVTYPE) = 1
       OVLLIM(IVTYPE) = 0.
@@ -2001,7 +2010,7 @@
 !
       IVTYPE = 56
       OVKEYW(IVTYPE) = 'DISW'                                             40.61
-      OVSNAM(IVTYPE) = 'Diswcp'
+      OVSNAM(IVTYPE) = 'Swcap'                                            40.85
       OVLNAM(IVTYPE) = 'Whitecapping dissipation'
       OVUNIT(IVTYPE) = 'm2/s'
       OVSVTY(IVTYPE) = 1
@@ -2035,6 +2044,126 @@
       OVHEXP(IVTYPE) = 1000.
       OVEXCV(IVTYPE) = -9.
 !
+      IVTYPE = 60
+      OVKEYW(IVTYPE) = 'GENE'                                             40.85
+      OVSNAM(IVTYPE) = 'Genera'
+      OVLNAM(IVTYPE) = 'Energy generation'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 61
+      OVKEYW(IVTYPE) = 'GENW'                                             40.85
+      OVSNAM(IVTYPE) = 'Swind'
+      OVLNAM(IVTYPE) = 'Wind source term'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 62
+      OVKEYW(IVTYPE) = 'REDI'                                             40.85
+      OVSNAM(IVTYPE) = 'Redist'
+      OVLNAM(IVTYPE) = 'Energy redistribution'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 63
+      OVKEYW(IVTYPE) = 'REDQ'                                             40.85
+      OVSNAM(IVTYPE) = 'Snl4'
+      OVLNAM(IVTYPE) = 'Total absolute 4-wave interaction'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 64
+      OVKEYW(IVTYPE) = 'REDT'                                             40.85
+      OVSNAM(IVTYPE) = 'Snl3'
+      OVLNAM(IVTYPE) = 'Total absolute 3-wave interaction'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 65
+      OVKEYW(IVTYPE) = 'PROPA'                                            40.85
+      OVSNAM(IVTYPE) = 'Propag'
+      OVLNAM(IVTYPE) = 'Energy propagation'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 66
+      OVKEYW(IVTYPE) = 'PROPX'                                            40.85
+      OVSNAM(IVTYPE) = 'Propxy'
+      OVLNAM(IVTYPE) = 'xy-propagation'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 67
+      OVKEYW(IVTYPE) = 'PROPT'                                            40.85
+      OVSNAM(IVTYPE) = 'Propth'
+      OVLNAM(IVTYPE) = 'theta-propagation'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 68
+      OVKEYW(IVTYPE) = 'PROPS'                                            40.85
+      OVSNAM(IVTYPE) = 'Propsi'
+      OVLNAM(IVTYPE) = 'sigma-propagation'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
+      IVTYPE = 69
+      OVKEYW(IVTYPE) = 'RADS'                                             40.85
+      OVSNAM(IVTYPE) = 'Radstr'
+      OVLNAM(IVTYPE) = 'Radiation stress'
+      OVUNIT(IVTYPE) = 'm2/s'
+      OVSVTY(IVTYPE) = 1
+      OVLLIM(IVTYPE) = 0.
+      OVULIM(IVTYPE) = 1000.
+      OVLEXP(IVTYPE) = 0.
+      OVHEXP(IVTYPE) = 0.1
+      OVEXCV(IVTYPE) = -9.
+!
 !     various parameters for computation of output quantities             40.00
 !
 !     reference time for TSEC
@@ -2548,7 +2677,7 @@
 !
 ! 13. Source text
 !
-      INTEGER  KGRPNT(MXC,MYC), IERR                                      40.02
+      INTEGER  KGRPNT(MXC,MYC)                                            40.02
       LOGICAL  SINBTG
       CHARACTER STYPE *1
       TYPE(OPSDAT), POINTER :: CUOPS                                      40.31
@@ -3162,6 +3291,10 @@
       COMPDA(:,JZEL  ) = 2.E-33                                           40.41
       COMPDA(:,JUSTAR) = 1.E-15                                           40.41
 !
+!     --- initialize UBOT and TMBOT                                       40.94
+      COMPDA(:,JUBOT) = 0.                                                40.94
+      IF (JPBOT.GT.1) COMPDA(:,JPBOT) = 0.                                40.94
+!
       RETURN
 ! * end of subroutine SWRBC *
       END
--- swanout1.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swanout1.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -82,6 +82,7 @@
 !     40.51: Marcel Zijlema
 !     40.80: Marcel Zijlema
 !     40.86: Nico Booij
+!     40.90: Nico Booij
 !
 !  1. Updates
 !
@@ -109,6 +110,8 @@
 !     40.80, Feb. 08: computation of wave-induced force on unstructured grid added
 !     40.86, Feb. 08: arguments added to calls of subroutines
 !                     to prevent interpolation over obstacles
+!     40.90, June 08: arguments added to call of subroutine SWSPEC
+!                     to prevent interpolation over obstacles
 !
 !  2. Purpose
 !
@@ -432,7 +435,7 @@
              ALLOCATE(AUX1(3*MSC))                                        40.31
           ENDIF
           CALL SWSPEC ( RTYPE, CORQ%OQI, MIP, VOQR, VOQ(1), AC2, AUX1,    40.31
-     &                  SPCSIG, SPCDIR, COMPDA(1,JDP2), KGRPNT,           40.31
+     &                  SPCSIG, SPCDIR, COMPDA(1,JDP2), KGRPNT, CROSS,    40.90 40.31
      &                  IONOD )                                           40.31
           IF (STPNOW()) RETURN                                            34.01
           DEALLOCATE(AUX1)                                                40.31
@@ -1352,6 +1355,7 @@
       USE M_PARALL                                                        40.31
       USE M_DIFFR                                                         40.21
       USE SwanGriddata                                                    40.80
+      USE SwanGridobjects                                                 40.91
 !
 !
 !
@@ -1459,10 +1463,13 @@
       INTEGER    IONOD(*)                                                 40.31
       LOGICAL    OQPROC(*), EQREAL                                        30.72
       LOGICAL    CROSS(4,MIP)                                             40.86
+      LOGICAL, ALLOCATABLE :: LTMP(:)                                     40.91
+      type(verttype), dimension(:), pointer :: vert                       40.91
       SAVE IENT
       DATA IENT /0/
       CALL STRACE (IENT, 'SWOEXD')
 !
+      vert => gridobject%vert_grid                                        40.91
       IF (ITEST.GE. 100 .OR. IOUTES .GE. 10) WRITE (PRTEST, 10)
      &(OQPROC(JJ), JJ=1,10), OQPROC(26), MIP
   10  FORMAT (' Entry SWOEXD ', 11L2, I8)
@@ -1701,6 +1708,276 @@
         ENDIF
       ENDIF
 !
+!     energy generation
+!
+      IF (OQPROC(60)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 60,
+     &  VOQR(60), JGENR
+        IF (JGENR.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JGENR),OVEXCV(60),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(60)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(60)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JGENR),
+     &                                     MIP, OVEXCV(60) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(60)) = OVEXCV(60)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(60))
+            IF (.NOT.EQREAL(F1,OVEXCV(60))) VOQ(IP,VOQR(60))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     wind source term
+!
+      IF (OQPROC(61)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 61,
+     &  VOQR(61), JGSXW
+        IF (JGSXW.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JGSXW),OVEXCV(61),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(61)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(61)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JGSXW),
+     &                                     MIP, OVEXCV(61) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(61)) = OVEXCV(61)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(61))
+            IF (.NOT.EQREAL(F1,OVEXCV(61))) VOQ(IP,VOQR(61))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     energy redistribution
+!
+      IF (OQPROC(62)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 62,
+     &  VOQR(62), JREDS
+        IF (JREDS.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JREDS),OVEXCV(62),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(62)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(62)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JREDS),
+     &                                     MIP, OVEXCV(62) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(62)) = OVEXCV(62)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(62))
+            IF (.NOT.EQREAL(F1,OVEXCV(62))) VOQ(IP,VOQR(62))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     total absolute 4-wave interaction
+!
+      IF (OQPROC(63)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 63,
+     &  VOQR(63), JRSXQ
+        IF (JRSXQ.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JRSXQ),OVEXCV(63),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(63)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(63)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JRSXQ),
+     &                                     MIP, OVEXCV(63) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(63)) = OVEXCV(63)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(63))
+            IF (.NOT.EQREAL(F1,OVEXCV(63))) VOQ(IP,VOQR(63))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     total absolute 3-wave interaction
+!
+      IF (OQPROC(64)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 64,
+     &  VOQR(64), JRSXT
+        IF (JRSXT.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JRSXT),OVEXCV(64),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(64)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(64)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JRSXT),
+     &                                     MIP, OVEXCV(64) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(64)) = OVEXCV(64)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(64))
+            IF (.NOT.EQREAL(F1,OVEXCV(64))) VOQ(IP,VOQR(64))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     energy propagation
+!
+      IF (OQPROC(65)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 65,
+     &  VOQR(65), JTRAN
+        IF (JTRAN.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JTRAN),OVEXCV(65),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(65)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(65)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JTRAN),
+     &                                     MIP, OVEXCV(65) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(65)) = OVEXCV(65)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(65))
+            IF (.NOT.EQREAL(F1,OVEXCV(65))) VOQ(IP,VOQR(65))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     xy-propagation
+!
+      IF (OQPROC(66)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 66,
+     &  VOQR(66), JTSXG
+        IF (JTSXG.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JTSXG),OVEXCV(66),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(66)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(66)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JTSXG),
+     &                                     MIP, OVEXCV(66) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(66)) = OVEXCV(66)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(66))
+            IF (.NOT.EQREAL(F1,OVEXCV(66))) VOQ(IP,VOQR(66))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     theta-propagation
+!
+      IF (OQPROC(67)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 67,
+     &  VOQR(67), JTSXT
+        IF (JTSXT.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JTSXT),OVEXCV(67),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(67)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(67)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JTSXT),
+     &                                     MIP, OVEXCV(67) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(67)) = OVEXCV(67)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(67))
+            IF (.NOT.EQREAL(F1,OVEXCV(67))) VOQ(IP,VOQR(67))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     sigma-propagation
+!
+      IF (OQPROC(68)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 68,
+     &  VOQR(68), JTSXS
+        IF (JTSXS.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JTSXS),OVEXCV(68),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(68)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(68)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JTSXS),
+     &                                     MIP, OVEXCV(68) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(68)) = OVEXCV(68)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(68))
+            IF (.NOT.EQREAL(F1,OVEXCV(68))) VOQ(IP,VOQR(68))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
+!     radiation stress
+!
+      IF (OQPROC(69)) THEN                                                40.85
+        IF (ITEST.GE.50 .OR. IOUTES .GE. 10) WRITE (PRTEST, 121) 69,
+     &  VOQR(69), JRADS
+        IF (JRADS.GT.1) THEN
+           IF (OPTG.NE.5) THEN
+              CALL SWIPOL(COMPDA(1,JRADS),OVEXCV(69),XC, YC, MIP, CROSS,
+     &                    VOQ(1,VOQR(69)) ,KGRPNT, COMPDA(1,JDP2))
+           ELSE
+              CALL SwanInterpolateOutput ( VOQ(1,VOQR(69)), VOQ(1,1),
+     &                                     VOQ(1,2), COMPDA(1,JRADS),
+     &                                     MIP, OVEXCV(69) )
+           ENDIF
+        ELSE
+           DO IP = 1, MIP
+             VOQ(IP,VOQR(69)) = OVEXCV(69)
+           ENDDO
+        ENDIF
+        IF (INRHOG.EQ.1) THEN
+          DO IP = 1, MIP
+            F1 = VOQ(IP,VOQR(69))
+            IF (.NOT.EQREAL(F1,OVEXCV(69))) VOQ(IP,VOQR(69))=F1*RHO*GRAV
+          END DO
+        ENDIF
+      ENDIF
+!
 !     Qb
 !
       IF (OQPROC(8)) THEN
@@ -1999,9 +2276,15 @@
      &                     VOQ(1,VOQR(27)) ,KGRPNT, COMPDA(1,JDP2))
                DEPMIN=RTMP
             ELSE                                                          40.80
+!              interpolation done in all active and non-active points     40.91
+               ALLOCATE(LTMP(nverts))                                     40.91
+               LTMP(:) = vert(:)%active                                   40.91
+               vert(:)%active = .TRUE.                                    40.91
                CALL SwanInterpolateOutput ( VOQ(1,VOQR(27)), VOQ(1,1),    40.80
      &                                      VOQ(1,2), COMPDA(1,JFRC2),    40.80
      &                                      MIP, OVEXCV(27) )             40.80
+               vert(:)%active = LTMP(:)                                   40.91
+               DEALLOCATE(LTMP)                                           40.91
             ENDIF                                                         40.80
          ELSE
             F1=0.
@@ -2028,9 +2311,15 @@
      &                    VOQ(1,VOQR(51)) ,KGRPNT, COMPDA(1,JDP2))
               DEPMIN=RTMP
            ELSE                                                           40.80
+!             interpolation done in all active and non-active points      40.91
+              ALLOCATE(LTMP(nverts))                                      40.91
+              LTMP(:) = vert(:)%active                                    40.91
+              vert(:)%active = .TRUE.                                     40.91
               CALL SwanInterpolateOutput ( VOQ(1,VOQR(51)), VOQ(1,1),     40.80
      &                                     VOQ(1,2), COMPDA(1,JWLV2),     40.80
      &                                     MIP, OVEXCV(51) )              40.80
+              vert(:)%active = LTMP(:)                                    40.91
+              DEALLOCATE(LTMP)                                            40.91
            ENDIF                                                          40.80
         ELSE
            DO IP = 1, MIP
@@ -2057,9 +2346,15 @@
      &                    VOQ(1,VOQR(52)) ,KGRPNT, COMPDA(1,JDP2))
               DEPMIN=RTMP
            ELSE                                                           40.80
+!             interpolation done in all active and non-active points      40.91
+              ALLOCATE(LTMP(nverts))                                      40.91
+              LTMP(:) = vert(:)%active                                    40.91
+              vert(:)%active = .TRUE.                                     40.91
               CALL SwanInterpolateOutput ( VOQ(1,VOQR(52)), VOQ(1,1),     40.80
      &                                     VOQ(1,2), COMPDA(1,JBOTLV),    40.80
      &                                     MIP, OVEXCV(52) )              40.80
+              vert(:)%active = LTMP(:)                                    40.91
+              DEALLOCATE(LTMP)                                            40.91
            ENDIF                                                          40.80
         ELSE
            DO IP = 1, MIP                                                 40.65
@@ -2330,7 +2625,7 @@
               IF (INDX(JC).LE.1) THEN                                     40.86
                 WW(JC) = 0.                                               40.86
               ELSE IF (DEP2(INDX(JC)).LE.DEPMIN) THEN                     40.86
-                WW(JC) = 0.                                               40.86
+                OUTSID = .TRUE.                                           40.94 40.86
               ELSE IF (CROSS(JC,IP) .AND. WW(JC).LT.0.999) THEN           40.86
                 WW(JC) = 0.                                               40.86
               ENDIF
@@ -2344,7 +2639,6 @@
               FOUTP(IP) = SUM(WW*FINP(INDX)) / SUMWW                      40.86
             ELSE
               FOUTP(IP) = EXCVAL                                          40.86
-              OUTSID = .TRUE.                                             40.86
             ENDIF
           ENDIF
         ENDIF
@@ -4037,7 +4331,7 @@
                WW(JC) = 0.                                                40.86
              ELSE IF (DEPXY(INDX(JC)).LE.DEPMIN) THEN                     40.86
 !              dry point
-               WW(JC) = 0.                                                40.86
+               EXCPT =  .TRUE.                                            40.94 40.86
              ELSE IF (CROSS(JC) .AND. WW(JC).LT.0.999) THEN               40.86
 !              obstacle                                                   40.86
                WW(JC) = 0.                                                40.86
@@ -4070,8 +4364,10 @@
          ENDIF
       ENDIF
       IF (ITEST.GE. 10) WRITE (PRTEST, 89)
-     &   XC, YC, ((JX(JC), JY(JC), WW(JC)), JC=1,4), SUMWW
-  89  FORMAT (2F9.3, 4(2X, 2I5, F6.3), 2X, F6.3)
+     &   XC, YC, (JX(JC), JY(JC), WW(JC), INDX(JC), CROSS(JC), JC=1,4),
+     &   SUMWW
+  89  FORMAT (' SWOINA ', 2F9.3, 4(2X, 2I5, F6.3, 1X, I4, 1X, L1), 2X,
+     &                    F6.3)
  900  RETURN
 !     end of subroutine SWOINA
       END
--- swanout2.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swanout2.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -230,7 +230,7 @@
         IF (OVSVTY(IVTYPE) .LT. 3) THEN
 !                      scalar quantities
           IF (MATLAB) THEN                                                40.30
-             IF (IL.EQ.1) THEN                                            40.41
+             IF (IL.EQ.1 .OR. IVTYPE.LT.3) THEN                           40.94 40.41
                 NAMVAR = OVSNAM(IVTYPE)                                   40.41
              ELSE                                                         40.41
                 NAMVAR = OVSNAM(IVTYPE)(1:LEN_TRIM(OVSNAM(IVTYPE)))//     40.41
@@ -1172,7 +1172,7 @@
 !***********************************************************************
 !                                                                      *
       SUBROUTINE SWSPEC (RTYPE, OQI, MIP, VOQR, VOQ, AC2, ACLOC,          40.31 20.28
-     &                   SPCSIG, SPCDIR, DEP2, KGRPNT, IONOD)             40.31 30.72
+     &                   SPCSIG, SPCDIR, DEP2, KGRPNT, CROSS, IONOD)      40.90 40.31 30.72
 !                                                                      *
 !***********************************************************************
 !
@@ -1225,6 +1225,7 @@
 !     40.31: Marcel Zijlema
 !     40.41: Marcel Zijlema
 !     40.51: Agnieszka Herman
+!     40.90: Nico Booij
 !
 !  1. Updates
 !
@@ -1246,6 +1247,8 @@
 !     40.31, Dec. 03: removing POOL construction
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
 !     40.51, Feb. 05: further optimization
+!     40.90, June 08: argument CROSS added to enable subroutine SWCMSP to
+!                     take into account obstacles
 !
 !  2. Purpose
 !
@@ -1269,6 +1272,8 @@
 !
       REAL    SPCDIR(MDC,6)                                               30.82
       REAL    SPCSIG(MSC)                                                 30.72
+      LOGICAL, INTENT(IN) :: CROSS(1:4,1:MIP) ! true if obstacle is       40.90
+      ! between output point and computational grid point                 40.90
 !
 !     RTYPE   ch*4   input    type of output request: 'SPEC' for 2-D spectral
 !                             output, 'SPE1' for 1-D freq. spectrum
@@ -1309,7 +1314,7 @@
 !
 ! 13. Source text
 !
-      CHARACTER (LEN=*) :: RTYPE                                              30.81 40.13
+      CHARACTER (LEN=*) :: RTYPE                                          40.13 30.81
       CHARACTER (LEN=8) :: CRFORM = '(2F14.4)'                            40.13
       INTEGER       :: VOQR(*), OQI(4), OTYPE, KGRPNT(MXC,MYC)            40.31 40.13
       INTEGER       :: IONOD(*)                                           40.31
@@ -1482,8 +1487,8 @@
         CALL SWCMSP (OTYPE       ,XC         ,YC          ,               40.00
      &               AC2         ,ACLOC      ,SPCSIG      ,
      &               DEP         ,DEP2       ,UX          ,               40.00
-     &               UY          ,SPCDIR(1,2) ,SPCDIR(1,3),
-     &               OFAC        ,KGRPNT     ,IERR        )               40.00
+     &               UY          ,SPCDIR(1,2),SPCDIR(1,3) ,
+     &               OFAC        ,KGRPNT     ,CROSS(1,IP) ,IERR        )  40.90 40.00
 !
         IF (IERR.GT.0) THEN
           WRITE (NREF, 220) 'NODATA'
@@ -1514,7 +1519,7 @@
      &                   AC2       ,ACLOC     ,SPCSIG    ,
      &                   DEP       ,DEP2      ,UX        ,                40.00
      &                   UY        ,ECOS      ,ESIN      ,
-     &                   OFAC      ,KGRPNT    ,IERR      )                30.21
+     &                   OFAC      ,KGRPNT    ,CROSS     ,IERR         )  40.90 30.21
 !                                                                      *
 !***********************************************************************
 !
@@ -1562,6 +1567,7 @@
 !     40.00: Nico Booij
 !     40.41: Marcel Zijlema
 !     40.80: Marcel Zijlema
+!     40.90: Nico Booij
 !
 !  1. Updates
 !
@@ -1579,6 +1585,7 @@
 !     30.82, July 99: Corrected argumentlist KSCIP1
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
 !     40.80, Sep. 07: extension to unstructured grids
+!     40.90, June 08: interpolation near obstacles improved
 !
 !  2. Purpose
 !
@@ -1621,6 +1628,9 @@
 !       ESIN  real   input    sines of spectral directions
 !       OFAC    real   input    output factor (if INRHOG=1, equal to Rho*Grav)
 !
+      LOGICAL, INTENT(IN) :: CROSS(1:4) ! true if obstacle is between     40.90
+              ! output point and computational grid point                 40.90
+!
 !  5. SUBROUTINES CALLING
 !
 !       SWSPEC (SWAN/OUTP)
@@ -1675,142 +1685,20 @@
 !
 !     the action density spectrum is interpolated
 !
-      IF (OPTG.NE.5) THEN                                                 40.80
-!
-!     determine interpolation coeff in case of structured grid
-!
-      JX1 = NINT(XC-0.5) + 1                                              33.09
-      IF (KREPTX.EQ.0) THEN                                               33.09
-        IF (JX1.LT.0) THEN
-          GOTO 800
-        ELSE IF (JX1.GT.MXC) THEN
-          GOTO 800
-        ELSE IF (JX1.EQ.0) THEN
-          IF (XC.GT.-0.01) THEN
-            JX1 = 1
-            JX2 = 2
-            SX1 = 1.
-            SX2 = 0.
-          ELSE
-            GOTO 800
-          ENDIF
-        ELSE IF (JX1.EQ.MXC) THEN
-          IF (XC.LT.REAL(MXC-1)+0.01) THEN
-            JX1 = MXC-1
-            JX2 = MXC
-            SX1 = 0.
-            SX2 = 1.
-          ELSE
-            GOTO 800
-          ENDIF
-        ELSE
-          JX2 = JX1+1
-          SX2 = XC + 1. - FLOAT(JX1)
-          SX1 = 1. - SX2
-          IF (SX1.LT.0.01) THEN
-            SX1 = 0.
-            SX2 = 1.
-          ENDIF
-          IF (SX2.LT.0.01) THEN
-            SX2 = 0.
-            SX1 = 1.
-          ENDIF
-        ENDIF
-      ELSE
-        JX2 = JX1+1
-        SX2 = XC + 1. - FLOAT(JX1)
-        SX1 = 1. - SX2
-        JX1 = MOD(MXC+JX1-1,MXC) + 1                                      33.09
-        JX2 = MOD(MXC+JX2-1,MXC) + 1                                      33.09
-      ENDIF                                                               33.09
-!
-      IF (.NOT. ONED) THEN                                                30.81
-        JY1 = INT(YC+3.) - 2
-        IF (JY1.LT.0) THEN
-          GOTO 800
-        ELSE IF (JY1.GT.MYC) THEN
-          GOTO 800
-        ELSE IF (JY1.EQ.0) THEN
-          IF (YC.GT.-0.01) THEN
-            JY1 = 1
-            JY2 = 2
-            SY1 = 1.
-            SY2 = 0.
-          ELSE
-            GOTO 800
-          ENDIF
-        ELSE IF (JY1.EQ.MYC) THEN
-          IF (YC.LT.REAL(MYC-1)+0.01) THEN
-            JY1 = MYC-1
-            JY2 = MYC
-            SY1 = 0.
-            SY2 = 1.
-          ELSE
-            GOTO 800
-          ENDIF
-        ELSE
-          JY2 = JY1+1
-          SY2 = YC + 1. - FLOAT(JY1)
-          SY1 = 1. - SY2
-          IF (SY1.LT.0.01) THEN
-            SY1 = 0.
-            SY2 = 1.
-          ENDIF
-          IF (SY2.LT.0.01) THEN
-            SY2 = 0.
-            SY1 = 1.
-          ENDIF
-        ENDIF
-      ELSE                                                                30.81
-        JY1 = 1                                                           30.81
-        JY2 = 1                                                           30.81
-        SY1 = 1.                                                          30.81
-!       SY2 = 1. - SY1  so:                                               30.81
-        SY2 = 0.                                                          30.81
-      END IF                                                              30.81
-
-!
-!     *** Using indirect addressing kgrpnt instead x and y ***
-!         *** KGRPNT(JX1,JY1) instead  (JX1,JY1)
-!         *** KGRPNT(JX1,JY2) instead  (JX1,JY2) ETC.
-      IND11 = KGRPNT(JX1,JY1)
-      IND12 = KGRPNT(JX1,JY2)
-      IND21 = KGRPNT(JX2,JY1)
-      IND22 = KGRPNT(JX2,JY2)
-      IF (IND11.LE.0 .OR. IND11.GT.MCGRD) WRITE (PRINTF, *)
-     &      ' error SWCMSP ', JX1, JY1, IND11, MCGRD
-      IF (IND12.LE.0 .OR. IND12.GT.MCGRD) WRITE (PRINTF, *)
-     &      ' error SWCMSP ', JX1, JY2, IND11, MCGRD
-      IF (IND21.LE.0 .OR. IND21.GT.MCGRD) WRITE (PRINTF, *)
-     &      ' error SWCMSP ', JX2, JY1, IND11, MCGRD
-      IF (IND22.LE.0 .OR. IND22.GT.MCGRD) WRITE (PRINTF, *)
-     &      ' error SWCMSP ', JX2, JY2, IND11, MCGRD
-      RF11 = SX1*SY1
-      RF12 = SX1*SY2
-      RF21 = SX2*SY1
-      RF22 = SX2*SY2
-      IF (DEP2(IND11).LE.DEPMIN .AND. RF11.GT.0.01) GOTO 800              40.00
-      IF (DEP2(IND12).LE.DEPMIN .AND. RF12.GT.0.01) GOTO 800              40.00
-      IF (DEP2(IND21).LE.DEPMIN .AND. RF21.GT.0.01) GOTO 800              40.00
-      IF (DEP2(IND22).LE.DEPMIN .AND. RF22.GT.0.01) GOTO 800              40.00
-!
-      IF (ITEST.GE. 250 .OR. IOUTES .GE. 30) THEN
-        WRITE (PRTEST, 69) JX1, JX2, JY1, JY2,
-     &          SX1, SX2, SY1, SY2, XC ,YC
-        WRITE (PRTEST, 70) IND11, IND12, IND21, IND22,
-     &          RF11 ,RF12 ,RF21 ,RF22
-  69    FORMAT ('   -------------------SWCMSP -------------------',/,
-     &     ' JX1,JX2,JY1,JY2,  SX1,  SX2,  SY1, SY2,     XC,      YC',/,
-     &           4I4,1X, 4(F5.2,1X),2(F8.2,1X))
-  70    FORMAT(12X, 'IND11..22       RF11    RF12    RF21    RF22 ',
-     &         /, 4I6, 2X, 4F8.4)
-      ENDIF
-!
-      ELSE                                                                40.80
-        ALLOCATE(ACL(MDC,MSC))                                            40.80
+      ALLOCATE(ACL(MDC,MSC))                                              40.90
+      IF (OPTG.EQ.5) THEN                                                 40.90
         CALL SwanInterpolateAc ( ACL, XC, YC, AC2, EXCPT )                40.80
-        IF (EXCPT) GOTO 800                                               40.80
-      ENDIF                                                               40.80
+      ELSE                                                                40.90
+        IF (KREPTX.EQ.0) THEN                                             40.90
+!         non-repeating grid                                              40.90
+          IF (XC .LT. -0.01)            GOTO 800                          40.90
+          IF (XC .GT. REAL(MXC-1)+0.01) GOTO 800                          40.90
+        ENDIF                                                             40.90
+        IF (YC .LT. -0.01)            GOTO 800                            40.90
+        IF (YC .GT. REAL(MYC-1)+0.01) GOTO 800                            40.90
+        CALL SWOINA (XC, YC, AC2, ACL, KGRPNT, DEP2, CROSS(1), EXCPT)     40.90
+      ENDIF                                                               40.90
+      IF (EXCPT) GOTO 800                                                 40.90
 !
       DO 110 ID = 1, MDC
         IF (ICUR.GT.0 .AND. OTYPE.LT.0) THEN
@@ -1818,26 +1706,7 @@
         ENDIF
         DO 100 ISIGM = 1, MSC
 !
-!         interpolate local action density
-!
-          ACLL = 0.
-!
-          IF (OPTG.NE.5) THEN                                             40.80
-             IF (RF11.GT.1.E-10) THEN
-                ACLL =        RF11 * AC2(ID,ISIGM,IND11)
-             ENDIF
-             IF (RF12.GT.1.E-10) THEN
-                ACLL = ACLL + RF12 * AC2(ID,ISIGM,IND12)
-             ENDIF
-             IF (RF21.GT.1.E-10) THEN
-                ACLL = ACLL + RF21 * AC2(ID,ISIGM,IND21)
-             ENDIF
-             IF (RF22.GT.1.E-10) THEN
-                ACLL = ACLL + RF22 * AC2(ID,ISIGM,IND22)
-             ENDIF
-          ELSE                                                            40.80
-             ACLL = ACL(ID,ISIGM)                                         40.80
-          ENDIF                                                           40.80
+          ACLL = ACL(ID,ISIGM)                                            40.80
 !
 !         energy density interpolated in space:
           ECLL = OFAC * ACLL * SPCSIG(ISIGM)                              40.00
--- swanparll.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swanparll.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -2931,7 +2931,7 @@
 !  6. Local variables
 !
 !     CORQ  :     current item in list of request outputs
-!     CROSS :     auxiliary logical array (not used)
+!     CROSS :     auxiliary logical array
 !     CUOPS :     current item in list of point sets
 !     DIF   :     difference between end and actual times
 !     DTTIWR:     to write time string
@@ -3099,10 +3099,7 @@
                IF (.NOT.ALLOCATED(YC)) ALLOCATE(YC(MIP))
                IF (.NOT.ALLOCATED(XP)) ALLOCATE(XP(MIP))
                IF (.NOT.ALLOCATED(YP)) ALLOCATE(YP(MIP))
-
-!              --- the next array will not be used in this routine        40.86
-
-               IF (.NOT.ALLOCATED(CROSS)) ALLOCATE(CROSS(0,0))
+               IF (.NOT.ALLOCATED(CROSS)) ALLOCATE(CROSS(4,MIP))          40.86
 
 !              --- compute coordinates of output points                   40.51
 
--- swanpre1.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swanpre1.ftn	2008-10-15 11:57:47.000000000 +0200
@@ -282,7 +282,7 @@
       INTEGER, SAVE     :: INCNUM(1:MXINCL) = 0                           40.03
       INTEGER, SAVE     :: INCLEV = 1                                     40.03
 !
-      INTEGER           :: IERR = 0                                       40.02
+      INTEGER           :: IOSTAT = 0                                     40.02
       INTEGER           :: ICNL4, ILAMBDA                                 40.17
       INTEGER           :: ITMP1, ITMP2, ITMP3, ITMP4                     40.31
 !
@@ -486,8 +486,8 @@
           CALL MSGERR (4, 'too many INCLUDE levels')                      40.03
           RETURN
         ENDIF
-        IERR   = 0
-        CALL FOR (INCNUM(INCLEV), FILENM, 'OF', IERR)                     40.03
+        IOSTAT = 0
+        CALL FOR (INCNUM(INCLEV), FILENM, 'OF', IOSTAT)                   40.03
         INPUTF = INCNUM(INCLEV)
         GOTO 100
       ENDIF
@@ -538,7 +538,6 @@
           MPTST  = 50
           IPP    = 2                                                      40.80
           IF (OPTG.EQ.5) IPP = 1                                          40.80
-          IERR   = 0                                                      40.00
           IF (.NOT.ALLOCATED(IARR)) ALLOCATE(IARR(IPP*MPTST))             40.80 40.31
 !
           CALL RETSTP (IPP*MPTST, IARR, KGRPNT, KGRBND, XCGRID, YCGRID,   40.80 40.31
@@ -1603,9 +1602,9 @@
 !
 ! =====================================================================
 !
-!             | -> ACCUR [drel] [dhoval] [dtoval] [npnts] |               40.41 40.03
-!   NUMeric (<                                             >          &   40.41
-!             |    STOPC [dabs] [drel] [curvat] [npnts]   |               40.41
+!             | -> ACCUR [drel] [dhoval] [dtoval] [npnts]            |    40.41 40.03
+!   NUMeric (<                                                        > & 40.41
+!             | STOPC [dabs] [drel] [curvat] [npnts] [dtabs] [curvt] |    40.93 40.41
 !
 !                    | -> STAT  [mxitst] [alfa] |                         40.23
 !                   <                            >  [limiter]   )     &   40.03
@@ -1652,6 +1651,8 @@
           CALL INREAL ('DREL'   , PNUMS(1) , 'STA', 0.01)                 40.41
           CALL INREAL ('CURVAT' , PNUMS(15), 'STA', 0.005)                40.41
           CALL INREAL ('NPNTS'  , PNUMS(4) , 'UNC', 0.)                   40.41
+          CALL INREAL ('DTABS'  , PNUMS(3) , 'STA', 1000.)                40.93
+          CALL INREAL ('CURVT'  , PNUMS(16), 'STA', 1000.)                40.93
           CALL INKEYW ('STA', 'STAT')                                     40.41
           IF (KEYWIS ('STAT')) THEN                                       40.41
             CALL ININTG ('MXITST' , MXITST   , 'STA', 50)                 40.41
@@ -2667,7 +2668,7 @@
 !
 ! 13. SOURCE TEXT
 !
-      INTEGER   IGRID1, IERR
+      INTEGER   IGRID1
       CHARACTER SNAMEG *8
       LOGICAL   KEYWIS                                                    30.00
       TYPE(OPSDAT), POINTER :: OPSTMP                                     40.31
@@ -5015,9 +5016,9 @@
            WRITE(FILENM(ILPOS+1:ILPOS+4),33) INODE                        40.31
   33       FORMAT('-',I3.3)                                               40.31
         END IF                                                            40.31
-        NREF = 0
-        IERR = 0
-        CALL FOR (NREF, FILENM, 'OF', IERR)
+        NREF   = 0
+        IOSTAT = 0
+        CALL FOR (NREF, FILENM, 'OF', IOSTAT)
         IF (STPNOW()) RETURN                                              34.01
  100    READ (NREF, 102) RLINE
  102    FORMAT (A)                                                        40.00
@@ -5334,9 +5335,9 @@
          WRITE(FILENM(ILPOS+1:ILPOS+4),33) INODE                          40.31
   33     FORMAT('-',I3.3)                                                 40.31
       END IF                                                              40.31
-      NREF = 0
-      IERR = 0
-      CALL FOR (NREF, FILENM, 'UF', IERR)
+      NREF   = 0
+      IOSTAT = 0
+      CALL FOR (NREF, FILENM, 'UF', IOSTAT)
       IF (STPNOW()) RETURN                                                34.01
       WRITE (NREF, 102) 'SWAN   1', 'SWAN standard file, with version'
       IF (NSTATM.EQ.1) THEN
--- swanpre2.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swanpre2.ftn	2008-10-15 11:57:48.000000000 +0200
@@ -1146,11 +1146,12 @@
       CALL STRACE (IENT,'SWREOQ')
 !
 !   --------------------------------------------------------------------------
-!   BLOCK   'sname'  HEADER / NOHEADER  'fname' (LAY-OUT [idla])            &
-!          <  DSPR/HSIGN/DIR/PDIR/TDIR/TM01/RTM01/RTP/TM02/FSPR/DEPTH/VEL/  &
-!             FRCOEFF/WIND/DISSIP/QB/TRANSP/FORCE/UBOT/URMS/WLEN/STEEPNESS/ &
-!             DHSIGN/DRTM01/LEAK/TSEC/XP/YP/DIST/SETUP/TMM10/RTMM10/        &
-!             TMBOT/QP/BFI/WATLEV/BOTLEV/TPS/DISBOT/DISSURF/DISWCAP  >      &
+!   BLOCK   'sname'  HEADER / NOHEADER  'fname' (LAY-OUT [idla])             &
+!          <  DSPR/HSIGN/DIR/PDIR/TDIR/TM01/RTM01/RTP/TM02/FSPR/DEPTH/VEL/   &
+!             FRCOEFF/WIND/DISSIP/QB/TRANSP/FORCE/UBOT/URMS/WLEN/STEEPNESS/  &
+!             DHSIGN/DRTM01/LEAK/TSEC/XP/YP/DIST/SETUP/TMM10/RTMM10/         &
+!             TMBOT/QP/BFI/WATLEV/BOTLEV/TPS/DISBOT/DISSURF/DISWCAP/         &
+!             GENE/GENW/REDI/REDQ/REDT/PROPA/PROPX/PROPT/PROPS/RADS >        &
 !             ([unit]) (OUTPUT [tbegblk] [deltblk] SEC/MIN/HR/DAY)
 !   --------------------------------------------------------------------------
 !   BLO   block type output
@@ -1272,6 +1273,46 @@
                    MCMVAR = MCMVAR+1                                      40.65
                    JDSXW  = MCMVAR                                        40.65
                 ENDIF                                                     40.65
+                IF (IVTYPE.EQ.60 .AND. JGENR.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JGENR  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.61 .AND. JGSXW.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JGSXW  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.62 .AND. JREDS.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JREDS  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.63 .AND. JRSXQ.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JRSXQ  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.64 .AND. JRSXT.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JRSXT  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.65 .AND. JTRAN.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JTRAN  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.66 .AND. JTSXG.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JTSXG  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.67 .AND. JTSXT.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JTSXT  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.68 .AND. JTSXS.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JTSXS  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
+                IF (IVTYPE.EQ.69 .AND. JRADS.LE.1) THEN                   40.85
+                   MCMVAR = MCMVAR+1                                      40.85
+                   JRADS  = MCMVAR                                        40.85
+                ENDIF                                                     40.85
              ENDIF
              GOTO 70
           ENDIF
@@ -1309,11 +1350,12 @@
         ENDIF                                                             32.02
       ENDIF
 !   --------------------------------------------------------------------------
-!   TABLE   'sname'  HEADER / NOHEADER / INDEXED 'fname'                    &
-!          <  DSPR/HSIGN/DIR/PDIR/TDIR/TM01/RTM01/RTP/TM02/FSPR/DEPTH/VEL/  &
-!             FRCOEFF/WIND/DISSIP/QB/TRANSP/FORCE/UBOT/URMS/WLEN/STEEPNESS/ &
-!             DHSIGN/DRTM01/LEAK/TIME/TSEC/XP/YP/DIST/SETUP/TMM10/RTMM10/   &
-!             TMBOT/QP/BFI/WATLEV/BOTLEV/TPS/DISBOT/DISSURF/DISWCAP  >      &
+!   TABLE   'sname'  HEADER / NOHEADER / INDEXED 'fname'                     &
+!          <  DSPR/HSIGN/DIR/PDIR/TDIR/TM01/RTM01/RTP/TM02/FSPR/DEPTH/VEL/   &
+!             FRCOEFF/WIND/DISSIP/QB/TRANSP/FORCE/UBOT/URMS/WLEN/STEEPNESS/  &
+!             DHSIGN/DRTM01/LEAK/TIME/TSEC/XP/YP/DIST/SETUP/TMM10/RTMM10/    &
+!             TMBOT/QP/BFI/WATLEV/BOTLEV/TPS/DISBOT/DISSURF/DISWCAP/         &
+!             GENE/GENW/REDI/REDQ/REDT/PROPA/PROPX/PROPT/PROPS/RADS >        &
 !             ([unit]) (OUTPUT [tbegtbl] [delttbl] SEC/MIN/HR/DAY)
 !   --------------------------------------------------------------------------
 !   TABLE   output in the form of a table
@@ -1405,6 +1447,46 @@
                MCMVAR = MCMVAR+1                                          40.65
                JDSXW  = MCMVAR                                            40.65
             ENDIF                                                         40.65
+            IF (IVTYPE.EQ.60 .AND. JGENR.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JGENR  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.61 .AND. JGSXW.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JGSXW  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.62 .AND. JREDS.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JREDS  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.63 .AND. JRSXQ.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JRSXQ  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.64 .AND. JRSXT.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JRSXT  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.65 .AND. JTRAN.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JTRAN  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.66 .AND. JTSXG.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JTSXG  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.67 .AND. JTSXT.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JTSXT  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.68 .AND. JTSXS.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JTSXS  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
+            IF (IVTYPE.EQ.69 .AND. JRADS.LE.1) THEN                       40.85
+               MCMVAR = MCMVAR+1                                          40.85
+               JRADS  = MCMVAR                                            40.85
+            ENDIF                                                         40.85
             CALL INKEYW ('STA', ' ')                                      40.00
             IF (KEYWIS('UNIT')) THEN
               CALL MSGERR (1, 'UNIT is ignored in this version')          40.00
@@ -2086,6 +2168,7 @@
 !     40.31: Marcel Zijlema
 !     40.41: Marcel Zijlema
 !     40.80: Marcel Zijlema
+!     40.92: Marcel Zijlema
 !
 !  1. Updates
 !
@@ -2105,6 +2188,7 @@
 !     40.31, Nov. 03: removing POOL-mechanism, reconsideration of this subroutine
 !     40.41, Oct. 04: common blocks replaced by modules, include files removed
 !     40.80, Jun. 07: extension to unstructured grids
+!     40.92, Jun. 08: changes with respect to boundary polygons
 !
 !  2. Purpose
 !
@@ -2135,7 +2219,9 @@
       INTEGER   IENT,KOUNTR,IX1,IY1,IX2,IY2
       INTEGER   MM,IX,IY,ISIDM,ISIDE,KC,KC2,KC1,IX3,IY3,MP
       INTEGER   IP,II,NBSPSS,NFSEQ,IKO,IKO2,IBSPC1,IBSPC2
-      INTEGER   VM, KX(1)                                                 40.80
+      INTEGER   VM                                                        40.80
+
+      INTEGER, DIMENSION(:), ALLOCATABLE :: IARR1, IARR2                  40.92
 
       REAL      CRDP, CRDM, SOMX, SOMY
       REAL      XP,YP,XC,YC,RR,DIRSI,COSDIR,SINDIR,DIRSID,DIRREF
@@ -2244,7 +2330,7 @@
       IF (OPTG.EQ.5) THEN                                                 40.80
 !
 !        in case of unstructured grid, make list of boundary points
-!        in ascending order (counterclockwise)
+!        in ascending order
 !
          CALL SwanBpntlist                                                40.80
       ENDIF                                                               40.80
@@ -2631,14 +2717,18 @@
 !
                IF (LFRST1) THEN                                           40.80
                   IXB1 = vert(IX2)%atti(BINDX)                            40.80
+                  JBG  = vert(IX2)%atti(BPOL)                             40.92
+                  DET  = 1.                                               40.92
                   LFRST1 = .FALSE.                                        40.80
                ELSE                                                       40.80
                   IXB1 = vert(IX1)%atti(BINDX)                            40.80
+                  JBG  = vert(IX1)%atti(BPOL)                             40.92
 !
 !                 1) the wave spectrum along the given segment can be
 !                    imposed in counterclockwise or clockwise direction
-!                 2) content of array blist is always ordered in
-!                    counterclockwise manner
+!                 2) content of array blist is ordered in counterclockwise
+!                    manner for sea/mainland boundary (JBG=1) and
+!                    clockwise for island boundary (JBG>1)
 !                 3) therefore, determine orientation by means of the
 !                    determinant of two endpoints of the given segment
 !                    and an arbitrary point inside domain
@@ -2651,34 +2741,61 @@
                   X2 = vert(IX2)%attr(VERTX)                              40.80
                   Y2 = vert(IX2)%attr(VERTY)                              40.80
 !
-!                 an arbitrary internal point
-                  KX = MINLOC(vert(:)%attr(VERTX),                        40.80
-     &                        vert(:)%atti(VMARKER)/=1)                   40.80
-                  X3 = vert(KX(1))%attr(VERTX)                            40.80
-                  Y3 = vert(KX(1))%attr(VERTY)                            40.80
+!                 an arbitrary internal point                             40.92
+                  DX=0.1*mingsiz
+                  DY=0.1*mingsiz
+                  DO IP=1,4
+                     X3 = X1 - DX
+                     Y3 = Y1 - DY
+                     CALL SwanFindPoint ( X3, Y3, IX )
+                     IF ( JBG>1 .AND. IX.LT.0 ) THEN
+                        X3 = X1 + DX
+                        Y3 = Y1 + DY
+                        EXIT
+                     ELSEIF ( JBG==1 .AND. IX.GT.0 ) THEN
+                        EXIT
+                     ENDIF
+                     IF ( MOD(IP,2).EQ.0 ) THEN
+                        DX = -DX
+                     ELSE
+                        DY = -DY
+                     ENDIF
+                  ENDDO
 !
                   DET= (Y3-Y1)*(X2-X1)-(Y2-Y1)*(X3-X1)                    40.80
                   IF (DET.GT.0.) THEN                                     40.80
 !                    take next boundary point in counterclockwise
 !                    direction
-                     IXB1 = MOD(IXB1,nbpt)+1                              40.80
+                     IXB1 = MOD(IXB1,nbpt(JBG))+1                         40.92 40.80
                   ELSE                                                    40.80
 !                    take next boundary point in clockwise direction
-                     IXB1 = nbpt-MOD(nbpt+1-IXB1,nbpt)                    40.80
+                     IXB1 = nbpt(JBG)-MOD(nbpt(JBG)+1-IXB1,nbpt(JBG))     40.92 40.80
                   ENDIF                                                   40.80
                ENDIF                                                      40.80
                IXB2 = vert(IX2)%atti(BINDX)                               40.80
 !
 !              determine order of counting
                IF (IXB1.GT.IXB2 ) THEN                                    40.80
-                  IXI=-1                                                  40.80
+                  IF (DET.LT.0.) THEN                                     40.92
+                     IXI  = -1                                            40.80
+                  ELSE                                                    40.92
+                     IXI  = 1                                             40.92
+                     IXB2 = IXB2+nbpt(JBG)                                40.92
+                  ENDIF                                                   40.92
                ELSE                                                       40.80
-                  IXI= 1                                                  40.80
+                  IF (DET.GT.0.) THEN                                     40.92
+                     IXI  = 1                                             40.80
+                  ELSE                                                    40.92
+                     IXI  = -1                                            40.92
+                     IXB1 = IXB1+nbpt(JBG)                                40.92
+                  ENDIF                                                   40.92
                ENDIF                                                      40.80
 !
-               DO IP = IXB1, IXB2, IXI                                    40.80
+               DO IPP = IXB1, IXB2, IXI                                   40.92 40.80
+                  IP = MOD(IPP,nbpt(JBG))                                 40.92
+                  IF (IP.EQ.0) IP = nbpt(JBG)                             40.92
                   KOUNTR = KOUNTR + 1                                     40.80
-                  IX = blist(IP)                                          40.80
+                  IX = blist(IP,JBG)                                      40.92 40.80
                   vert(IX)%atti(VBC) = 1                                  40.80
                   ALLOCATE(TMP)                                           40.80
                   TMP%JX = IX                                             40.80
@@ -2702,7 +2819,7 @@
           CALL IGNORE ('SIDE')
 !         *** specification of side for which boundary   ***
 !         *** condition is given                         ***
-          IF (OPTG.EQ.1) THEN                                             40.80
+          IF (OPTG.NE.5) THEN                                             40.80
              CALL INKEYW ('REQ',' ')
              IF (KEYWIS ('NW')) THEN
                DIRSI = 45.
@@ -2723,7 +2840,7 @@
              ELSE
                CALL WRNKEY
              ENDIF
-          ELSEIF (OPTG.EQ.5) THEN                                         40.80
+          ELSE                                                            40.80
              CALL ININTG ('K', VM, 'REQ', 0)                              40.80
           ENDIF                                                           40.80
 !
@@ -2739,7 +2856,7 @@
 !
 !         select side in the chosen direction
 !
-          IF ( OPTG.EQ.1 ) THEN                                           40.80
+          IF ( OPTG.NE.5 ) THEN                                           40.80
              CRDM   = -1.E10
              ISIDM  = 0
              IF (ONED) THEN                                               40.00
@@ -2907,22 +3024,48 @@
                  CURR => TMP                                              40.31
                ENDIF
              ENDDO
-          ELSEIF ( OPTG.EQ.5 ) THEN                                       40.80
+          ELSE                                                            40.80
             ! unstructured grid
             !
-            IF ( CCW ) THEN                                               40.80
-               IXB1 = 1                                                   40.80
-               IXB2 = nbpt                                                40.80
-               IXI  = 1                                                   40.80
-            ELSE                                                          40.80
-               IXB1 = nbpt                                                40.80
-               IXB2 = 1                                                   40.80
-               IXI  = -1                                                  40.80
-            ENDIF                                                         40.80
-            !
-            DO IP = IXB1, IXB2, IXI                                       40.80
-               IX = blist(IP)                                             40.80
-               IF ( vmark(IX) == VM ) THEN                                40.80
+            DO JBG = 1, nbpol                                             40.92
+               !
+               ! first boundary polyogon is assumed an outer one
+               ! (sea/mainland boundary) and hence, content of blist
+               ! is ordered in counterclockwise manner
+               !
+               IF ( JBG==1 .EQV. CCW ) THEN                               40.92 40.80
+                  IXB1 = 1                                                40.80
+                  IXB2 = nbpt(JBG)                                        40.92 40.80
+                  IXI  = 1                                                40.80
+               ELSE                                                       40.80
+                  IXB1 = nbpt(JBG)                                        40.92 40.80
+                  IXB2 = 1                                                40.80
+                  IXI  = -1                                               40.80
+               ENDIF                                                      40.80
+               !
+               ALLOCATE(IARR1(SUM(nbpt)))
+               K = 0
+               DO IP = IXB1, IXB2, IXI                                    40.92
+                  IX = blist(IP,JBG)                                      40.92
+                  IF ( vmark(IX) == VM ) THEN                             40.92
+                     K = K+1                                              40.92
+                     IARR1(K) = IP                                        40.92
+                  ENDIF
+               ENDDO
+               ALLOCATE(IARR2(K))                                         40.92
+               IARR2(1:K) = IARR1(1:K)                                    40.92
+               ISH = 0                                                    40.92
+               DO IPP = 2, K                                              40.92
+                  IF ( IARR2(IPP)/=IARR2(IPP-1)+IXI ) THEN                40.92
+                     ISH = IPP-1                                          40.92
+                     EXIT                                                 40.92
+                  ENDIF                                                   40.92
+               ENDDO                                                      40.92
+               IARR2 = CSHIFT(IARR2,ISH)                                  40.92
+               !
+               DO IPP = 1, K                                              40.92
+                  IP = IARR2(IPP)                                         40.92
+                  IX = blist(IP,JBG)                                      40.92 40.80
                   KOUNTR = KOUNTR + 1                                     40.80
                   vert(IX)%atti(VBC) = 1                                  40.80
                   ALLOCATE(TMP)                                           40.80
@@ -2930,8 +3073,10 @@
                   NULLIFY(TMP%NEXTXY)                                     40.80
                   CURR%NEXTXY => TMP                                      40.80
                   CURR => TMP                                             40.80
-               ENDIF                                                      40.80
-            ENDDO                                                         40.80
+               ENDDO                                                      40.80
+               DEALLOCATE(IARR1,IARR2)                                    40.92
+               !
+            ENDDO                                                         40.92
             !
           ENDIF                                                           40.80
         ENDIF
@@ -4894,31 +5039,36 @@
 !        since this grid is nested in a coarse structured or
 !        unstructured grid run
 !
-!        Note that the variable DONALL has no effect, since the
-!        boundary of the nested run is always a closed polygon
+!        Note that the variable DONALL has no effect, since we
+!        searching into the whole grid
 !
          DO IXP = 1, nverts                                               40.80
             IF ( vert(IXP)%atti(VMARKER) == 1 .AND.                       40.80
      &           vert(IXP)%atti(VBC) == 0 ) THEN                          40.80
-               vert(IXP)%atti(VBC) = 1                                    40.80
-               NBGRPT = NBGRPT + 1                                        40.80
-               ALLOCATE(BGPTMP)                                           40.80
-               BGPTMP%BGP(1) = IXP                                        40.80
-               BGPTMP%BGP(2) = 1                                          40.80
-               BGPTMP%BGP(3) = 1000                                       40.80
-               BGPTMP%BGP(4) = IBSP2                                      40.80
-               BGPTMP%BGP(5) = 0                                          40.80
-               BGPTMP%BGP(6) = IBSP2-1                                    40.80
-               NULLIFY(BGPTMP%NEXTBGP)                                    40.80
-               IF ( .NOT.LBGP ) THEN                                      40.80
-                  FBGP = BGPTMP                                           40.80
-                  CUBGP => FBGP                                           40.80
-                  LBGP = .TRUE.                                           40.80
-               ELSE                                                       40.80
-                  CUBGP%NEXTBGP => BGPTMP                                 40.80
-                  CUBGP => BGPTMP                                         40.80
-               ENDIF                                                      40.80
-               EXIT                                                       40.80
+               RX = XP2 - vert(IXP)%attr(VERTX)
+               RY = YP2 - vert(IXP)%attr(VERTY)
+               DISXY = SQRT(RX**2 + RY**2)
+               IF (DISXY.LT.0.1) THEN
+                  vert(IXP)%atti(VBC) = 1                                 40.80
+                  NBGRPT = NBGRPT + 1                                     40.80
+                  ALLOCATE(BGPTMP)                                        40.80
+                  BGPTMP%BGP(1) = IXP                                     40.80
+                  BGPTMP%BGP(2) = 1                                       40.80
+                  BGPTMP%BGP(3) = 1000                                    40.80
+                  BGPTMP%BGP(4) = IBSP2                                   40.80
+                  BGPTMP%BGP(5) = 0                                       40.80
+                  BGPTMP%BGP(6) = IBSP2-1                                 40.80
+                  NULLIFY(BGPTMP%NEXTBGP)                                 40.80
+                  IF ( .NOT.LBGP ) THEN                                   40.80
+                     FBGP = BGPTMP                                        40.80
+                     CUBGP => FBGP                                        40.80
+                     LBGP = .TRUE.                                        40.80
+                  ELSE                                                    40.80
+                     CUBGP%NEXTBGP => BGPTMP                              40.80
+                     CUBGP => BGPTMP                                      40.80
+                  ENDIF                                                   40.80
+                  EXIT                                                    40.80
+               ENDIF
             ENDIF                                                         40.80
          ENDDO                                                            40.80
          RETURN                                                           40.80
--- swantech.tex	2008-05-25 14:59:53.000000000 +0200
+++ swantech.tex	2008-10-15 11:57:51.000000000 +0200
@@ -13,17 +13,17 @@
 \end{center}
 \vspace{2cm}
 \begin{center}
-{\Large\bf TECHNICAL DOCUMENTATION}
+{\Large\bf SCIENTIFIC\\ AND\\ TECHNICAL\\ DOCUMENTATION\\}
 \end{center}
 \vfill
 \begin{center}
-{\Large\bf SWAN Cycle III version 40.72}
+{\Large\bf SWAN Cycle III version 40.72A}
 \end{center}
 
 \cleardoublepage
 
 \noindent
-{\Large\bf SWAN TECHNICAL DOCUMENTATION}
+{\Large\bf SWAN\\ SCIENTIFIC AND TECHNICAL\\ DOCUMENTATION\\}
 
 \vfill
 
@@ -195,6 +195,7 @@
 systems of equations.
 Chapter~\ref{ch:parall} deals with some consideration on parallelization of SWAN on
 distributed memory architectures.
+Chapter~\ref{ch:unswan} presents an unstructured-grid procedure for SWAN.
 Chapter~\ref{ch:concl} concludes this document by summarizing the overall solution algorithm of SWAN.
 \\[2ex]
 \noindent
@@ -1031,7 +1032,7 @@
 area due to wave breaking $D_{\rm tot}$ is expressed as:
 \begin{equation}
   D_{\rm tot} = - \frac{1}{4} \alpha_{\rm BJ} Q_b (\frac{\tilde{\sigma}}{2\pi}) H^2_{\rm max}
-              = \alpha_{\rm BJ} Q_b \tilde{\sigma} \frac{H^2_{\rm max}}{8\pi}
+              = - \alpha_{\rm BJ} Q_b \tilde{\sigma} \frac{H^2_{\rm max}}{8\pi}
   \label{eq3-22}
 \end{equation}
 in which $\alpha_{\rm BJ} = 1$ in SWAN, $Q_b$ is the fraction of breaking waves determined by:
@@ -1071,7 +1072,7 @@
   -\frac{\alpha_{\rm BJ} Q_b \tilde{\sigma}}{\beta^2 \pi} E(\sigma,\theta)
   \label{eq3-26}
 \end{equation}
-The maximum wave height $H_{\rm max}$ is determined in SWAN with $H_m = \gamma d$, in which $\gamma$ is the breaker parameter
+The maximum wave height $H_{\rm max}$ is determined in SWAN with $H_{\rm max} = \gamma d$, in which $\gamma$ is the breaker parameter
 and $d$ is the total water depth (including the wave-induced set-up if computed by SWAN). In the literature,
 this breaker parameter $\gamma$ is often a constant or it is expressed as a function of bottom slope or incident
 wave steepness (see e.g., Galvin, 1972; Battjes and Janssen, 1978; Battjes and Stive, 1985; Arcilla and
@@ -1568,7 +1569,7 @@
 
 \section{Wave-induced set-up} \label{sec:setup}
 
-In a (geographic) 1D case the computation of the wave induced set-up is based on the vertically integrated
+In a (geographic) 1D case the computation of the wave-induced set-up is based on the vertically integrated
 momentum balance equation which is a balance between the wave force (gradient of the wave radiation
 stress normal to the coast) and the hydrostatic pressure gradient (note that the component parallel to the
 coast causes wave-induced currents but no set-up).
@@ -1596,6 +1597,9 @@
   \frac{\partial}{\partial y} (\rho g H \frac{\partial \overline{\eta}}{\partial y}) = 0
   \label{eq3-41}
 \end{equation}
+This approximation can \underline{only} be applied to open coast (unlimited supply of water from outside
+the domain, e.g. nearshore coasts and estuaries) in contrast to closed basin, e.g. lakes, where this approach
+should not be used.
 
 \chap{Numerical approaches} \label{ch:numerics}
 
@@ -2711,13 +2715,13 @@
 
 \section{Computation of breaking source term}
 
-The surf breaking source term is
+The surf breaking dissipation reads
 \begin{equation}
-  S_{\rm br} = -\beta Q_{b} \frac{H^2_m}{8}
+  D_{\rm tot} = -\beta Q_{b} \frac{H^2_m}{8}
 \end{equation}
-and for each spectral bin $i$, we have
+The surf breaking source term for each spectral bin $i$ is
 \begin{equation}
-  S_{\rm br} = -\beta \frac{Q_b}{B} E_i
+  S_{\rm br} = \frac{D_{\rm tot}}{E_{\rm tot}} E_i = -\beta \frac{Q_b}{B} E_i
 \end{equation}
 with
 \begin{equation}
@@ -2728,15 +2732,17 @@
 to $B$. The two are related by
 \begin{equation}
   1- Q_b + B \ln Q_b = 0
+  \label{eq:breakfract}
 \end{equation}
 The derivative is found by differentiating this with respect to $B$:
 \begin{equation}
-  -{Q'}_{b} + \ln Q_b + \frac{B}{Q_b} {Q'}_{b}
+  -{Q'}_{b} + \ln Q_b + \frac{B}{Q_b} {Q'}_{b} = 0
 \end{equation}
 Hence,
 \begin{equation}
   {Q'}_{b} = \frac{\ln Q_b}{1 - B/Q_b} = \frac{Q_b}{B} \frac{Q_b - 1}{Q_b - B}
 \end{equation}
+using Eq. (\ref{eq:breakfract}).
 The approximation of the source term is based on
 \begin{equation}
   S_{\rm br,i}^{+} = S_{\rm br,i}^{-} + \frac{d S_{\rm br}}{d E_{\rm tot}} (E_{i}^{+} - E_{i}^{-})
@@ -3403,7 +3409,205 @@
 
 A survey of other alternatives to the parallelization of the implicit schemes is given in Templates (1994).
 
+\chap{Unstructured mesh implementation} \label{ch:unswan}
+
+Since, the characteristic spatial scales of the wind waves propagating from deep to shallow waters are very
+diverse, a flexible grid would be required to allow local refinement of the mesh
+in areas of interest  e.g.,
+regions of strong bathymetry variations in estuaries and fjords,
+without incurring
+overhead associated with grid adaptation at some distance offshore. Traditionally, this can be achieved by employing
+a nesting technique.
+Although, this practise is very common for SWAN, it is generally recognized that
+this may lead to complicated programming with the corresponding significant increase in computational effort.
+
+The use of unstructured grids, however, offers a good alternative to nested models not only because of the
+ease of local grid refinement, either adaptive or fixed, but also the high flexibility to generate
+grids along coastline and around islands.
+The variable mesh is especially useful in coastal regions where the water depth varies greatly.
+Thus, the variable grid gives the highest resolution where it is most needed.
+Moreover, this can be automated to a large extent.
+Although, the CPU cost per grid point is often relative higher than cases with structured grids,
+this effect is probably more than offset by the reduction in the number of grid points.
+
+This chapter presents an unstructured grid procedure for SWAN.
+The numerical propagation scheme for structured grids is based on
+a four-direction Gauss-Seidel iteration technique and is accompanied by a fully implicit temporal discretization; see Section~\ref{sec:sol}.
+Hence, SWAN is stable for any time step.
+Because of this nice property, this solution technique is tailored to unstructured grids.
+
+\section{Numerical method}
+\label{sec:nummeth}
+
+\subsection{Discretization procedure}
+
+For the sake of clarity of the algorithm description below, we put all the terms but the time derivative and propagation term in the geographical space of Eq. (\ref{eq:actbal1})
+in one term $F(\vec{x},\sigma,\theta)$:
+\begin{equation}
+  \frac{\partial N}{\partial t} + \nabla_{\vec{x}} \cdot [\vec{c}_{\vec{x}} N] = F
+  \label{eq:waveeq}
+\end{equation}
+with $\vec{c}_{\vec{x}} = {\vec{c}}_g + \vec{U}$ the geographic velocity vector.
+
+For the time being, we restrict ourselves to triangular meshes. However, other
+type of meshes can be employed as well, e.g. hybrid grids (consisting of both triangles and quadrilaterals). We consider a triangulation of a geographical domain in which
+Eq. (\ref{eq:waveeq}) is solved; see Fig~\ref{fig:triangul}.
+\begin{figure}[htb]
+   \centerline{
+      \epsfig{file=triangul.eps,height=7cm}
+              }
+      \caption{An example of triangulation.}
+      \label{fig:triangul}
+\end{figure}
+Every vertex and all the triangles around this vertex are taken into account.
+Observe that the number of cells around a vertex can be different for all vertices.
+A vertex-based scheme is used in which the wave action $N$ is stored at the vertices and Eq. (\ref{eq:waveeq}) is solved in each vertex.
+We note that the values at boundary vertices are fixed during the computation.
+
+For the time integration, we adopt the first order implicit Euler scheme, as follows
+\begin{equation}
+  \frac{N^n - N^{n-1}}{\Delta t} + \nabla_{\vec{x}} \cdot [\vec{c}_{\vec{x}} N^n] = F^n
+  \label{eq:waveeq2}
+\end{equation}
+where $\Delta t$ is the time step and $n$ is the time step counter. The main property of this approximation is that it does not suffer from the stability restriction
+imposed by the CFL condition inherent in the explicit methods as employed in most spectral models. In principle, the time step is limited only by
+the desired temporal accuracy. This procedure, however, involves the solution of a large system of equations.
+
+A point-by-point multi-directional Gauss-Seidel iteration technique is employed for updating all grid vertices.
+A key feature of this technique is that it takes advantage of the newly acquired vertex values during an iteration.
+It is locally implicit but globally explicit. In other words, it circumvents the need to build or store large matrices and remains stable at any time steps.
+This means that this numerical procedure can converge to steady state much more rapidly than
+explicit methods without requiring too much computational work and memory as do implicit methods.
+
+We consider the update of a vertex as labeled 1 in Figure~\ref{fig:gsunstruc}. This involves looping over each cell of this vertex.
+\begin{figure}[htb]
+   \centerline{
+      \epsfig{file=gsunstruc.eps,height=7cm}
+              }
+      \caption{Update of the wave action at vertex 1 in a triangle $\triangle$123 and the shaded directional sector
+               in spectral space for which the waves are propagated.}
+      \label{fig:gsunstruc}
+\end{figure}
+Considering a triangle $\triangle$123 where the faces towards vertex 1 are given by
+\begin{equation}
+  {\vec{e}}_{(1)}  = {\vec{x}}_1 - {\vec{x}}_2 \, , \quad {\vec{e}}_{(2)}  = {\vec{x}}_1 - {\vec{x}}_3
+\end{equation}
+with ${\vec{x}}_i = (x_i, y_i)$ the position vector of vertex $i$ in a Cartesian coordinate system.
+Next, the action densities at vertices 1, 2 and 3 are denoted by $N_1$, $N_2$ and $N_3$, respectively.
+With the help of vector analysis and after some algebra, the propagation term of Eq. (\ref{eq:waveeq}) may be approximated as follows
+\begin{equation}
+  \nabla_{\vec{x}} \cdot [\vec{c}_{\vec{x}} N] \approx c_x N|_2^1 e^{(1)}_1 + c_x N|_3^1 e^{(2)}_1 + c_y N|_2^1 e^{(1)}_2 + c_y N|_3^1 e^{(2)}_2
+  \label{eq:spacedisc}
+\end{equation}
+where $c_x$ and $c_y$ are the $x-$ and $y-$components of the wave propagation vector $\vec{c}_{\vec{x}}$, respectively, and
+\begin{equation}
+  \vec{e}^{(1)} = \frac{1}{D} ( e^2_{(2)},-e^1_{(2)} )^{\top}\, ,\, \, \vec{e}^{(2)} = \frac{1}{D} (-e^2_{(1)}, e^1_{(1)} )^{\top}\, , \, \,
+  D = e^2_{(2)} e^1_{(1)} - e^2_{(1)} e^1_{(2)} \, .
+\end{equation}
+This space discretization is first order accurate and conserves action. The upwind difference scheme (\ref{eq:spacedisc}) is employed for two reasons.
+First, it enforces the propagation of wave action to follow the characteristics.
+Second, it is monotone (i.e. guaranteeing $N > 0$ everywhere) and compact (i.e. operating on one triangle only), while sufficiently accurate for nearshore applications.
+Given the action densities $N^n_2$ and $N^n_3$ at vertices 2 and 3 of triangle $\triangle$123,
+the wave action in vertex 1 is determined according to
+\begin{eqnarray}
+  &&\left[ \frac{1}{\Delta t} + c_{x,1} \left( e^{(1)}_1 + e^{(2)}_1 \right) + c_{y,1} \left( e^{(1)}_2 + e^{(2)}_2 \right) \right] N_1^n = \nonumber \\
+  &&\frac{N_1^{n-1}}{\Delta t}+\left( c_{x,2} e^{(1)}_1 + c_{y,2} e^{(1)}_2 \right) N^n_2 + \left( c_{x,3} e^{(2)}_1 + c_{y,3} e^{(2)}_2 \right) N^n_3 + F^n \, .
+  \label{eq:waveeq3}
+\end{eqnarray}
+
+The wave directions between faces $\vec{e}_{(1)}$ and $\vec{e}_{(2)}$ enclose all wave energy propagation in between the corresponding directions $\theta_1$ and $\theta_2$ as
+indicated as a shaded sector in Figure~\ref{fig:gsunstruc}.
+This sector is the domain of dependence of Eq. (\ref{eq:waveeq3}) in vertex 1.
+Since, the wave characteristics lie within this directional sector, this ensures that the CFL number
+used will properly capture the propagation of wave action towards vertex 1. So, propagation is not subjected to a CFL stability criterion.
+Next, the term $F^n$ in Eq. (\ref{eq:waveeq3}) is discretized implicitly in the sector considered.
+Since, the approximation in the spectral space and the linearization of the source terms are well explained in Section~\ref{sec:sol}, we shall not pursue them any further.
+Eq. (\ref{eq:waveeq3}) constitute a coupled set of linear, algebraic equations for all spectral bins within the sector considered at vertex 1. The solution is found by means
+of an iterative solver; see Section~\ref{sec:sol} for details.
+
+The update of vertex 1 is completed when all surrounding cells have been treated. This allows waves to transmit from all directions.
+Due to refraction and nonlinear interactions, wave energy shifts in the spectral space from one directional sector to another. This is taken into account properly
+by repeating the whole procedure with
+converging results.
+
+\subsection{The sweeping algorithm}
+
+The solution of each vertex must be updated geographically before proceeding to the next one. For example, referring to Figure~\ref{fig:gsunstruc},
+the value in vertex 1 is determined by its two upwave vertices 2 and 3 only if they are already updated.
+For regular grids, the four-sweep scheme based on a four-direction Gauss-Seidel relaxation is employed as outlined in Section~\ref{sec:sol}.
+The grid points are ordered in a natural manner, e.g. left to right and bottom to top during the first sweep, right to left and bottom to top during the second
+sweep, and so on.
+Hence, the updated values will be used immediately for updating the next unknown.
+However,
+in an unstructured mesh there are no distinct directions. Thus the vertices are ordered by their numbering which for
+an unstructured grid are quite random. As a consequence, the latest obtained solution will be not necessarily used for updating surrounding vertices.
+
+An ordering is proposed such that
+the solution of each vertex will tend to ensure that updated values from the surrounding vertices are used as soon as they are available.
+We introduce a reference point on the boundary where the incoming wave energy is imposed
+and order all the vertices according to their distances to the reference point in ascending order.
+The updates along this ordering of vertices can be interpreted as propagation of spherical wave fronts with a center
+on the upwave boundary through the domain as illustrated in Figure~\ref{fig:wavefronts}.
+\begin{figure}[htb]
+   \centerline{
+      \epsfig{file=wavefronts.eps,height=6cm}
+              }
+      \caption{Ordering of vertices along spherical wave fronts indicated by different color points. The black point in left-bottom corner is chosen as reference point.}
+      \label{fig:wavefronts}
+\end{figure}
+It is expected that this specific ordering should result in a faster convergence than a random ordering of vertices.
+
+An algorithm is employed that consists of simply proceeding through a list of vertices that remain to be updated. This list is sorted according to the ascending distances
+of vertices to the chosen reference point. For a given vertex to be updated,
+we first check if its upwave neighbours has already been
+updated. If this is the case, this vertex is updated and tagged in the list. Otherwise, the considered vertex is placed untagged and the process continues with the next vertex in the list
+of non-updated vertices.
+These updates are swept in two cycles. The first cycle involves a forward sweep from the first vertex in the list to the last. The second cycle moves backward from the last to the first.
+As such, all directions of characteristics can be covered efficiently.
+An iteration is completed when all vertices are updated in both geographic and spectral spaces so that wave energy from all directions has been propagated through geographical space.
+This numerical process is iterated until an {\em a priori} convergence condition is satisfied. Here, the curvature-based stopping criteria
+as outlined in Section~\ref{sec:stop} will be applied.
+
+\section{Some notes on grid generation}
+
+We briefly outline some issues related to grid generation from a practical point of view.
+The process of grid generation can be difficult and time consuming. A common approach is proceeding from coarse to fine grid through refinement in various ways.
+Generally, one would like to have an optimal grid in which areas where the bathymetry or evolution of the waves change
+rapidly require a higher resolution than areas where the physics or depth changes less.
+This goes around by having an indication how to determine the refinement based on
+bathymetry or geometric variations through preliminary evaluations.
+To facilitate this procedure,
+a mesh generation package BatTri (Bilgili and Smith, 2003) is used.
+This grid generator is a public-domain, graphical Matlab interface to Triangle (Shewchuk, 1996).
+Triangle is a freely-distributed, two-dimensional Delaunay triangulator.
+Generation of the meshes presented in this paper was accomplished using BatTri.
+\nocite{Bil03S,She96}
+
+An important key ingredient for the preparation of the grid for the model domain is bathymetry data.
+Boundary nodes, segments and holes
+can be created from this data with the
+use of the mesh editing options of BatTri.
+After checking and improving grid quality, the final information on nodes and segments is forced into the
+triangulation of the domain. Triangle is called within BatTri to generate
+the actual grid. This triangulation includes only acute triangles.
+
+BatTri provides many pre-defined depth-dependent contraints for further mesh refinement.
+From a numerical point of view, mesh refinement is often directly related to properly resolve the shape of the wave,
+i.e. to keep the wavelength to grid size ratio relatively large.
+When wavelength decreases in shallower water, the grid size must decrease as well. Therefore, this criterion, called the $h$-refinement,
+has the effect of using smaller cells in shallow water and larger
+cells in deeper water. Here, $h$ refers to the water depth. Another useful criterion is known as the topographic length scale constraint,
+when one try to keep the ratio $\Delta h/h$ less than one. Here, $\Delta h$ equals the difference between the maximum depth of a triangle and the minimum depth and
+$h$ is the average depth. This
+criterion addresses the bathymetric slope and cells with a high value of $\Delta h/h$ indicate areas of steep bottom topography that will need to be
+more finely resolved.
+When refining the grid, one must balance the need to fully meet the refinement criteria with the desire to keep the triangle sizes from becoming too small.
+Thus, these criteria
+are generally imposed along with a minimum area constraint.
+The refinement process is repeated iteratively until a final grid with the appropriate resolution is obtained.
+
 \chap{The overall solution algorithm} \label{ch:concl}
+This chapter is under preparation.
 
 \newpage
 \markboth{}{}
@@ -3494,6 +3698,11 @@
 Bertotti, L and L. Cavaleri, 1994: Accuracy of wind and wave evaluation in coastal regions, {\it Proc. 24$^{{\rm th}}$ Int.
 Conf. Coastal Engineering}, ASCE, 57-67
 
+\bibitem{Bil03S}
+Bilgili, A. and Smith, K.W., 2003.
+BatTri: a 2-D finite element grid generator, version 11.11.03.
+Available from: $<$http://www-nml.dartmouth.edu/Publications/internal\_reports/NML-03-15/$>$.
+
 \bibitem{Boo87H}
 Booij, N., and L.H. Holthuijsen, 1987, Propagation of ocean waves in discrete spectral wave m{\it odels,
 Journal of Computational Physics}, vol. 68, 307-326.
@@ -4051,6 +4260,11 @@
 effects in shallow water, in: Turbulent Fluxes through the Sea Surface, {\it Wave Dynamics and
 Prediction, NATO Conf. Ser}., {\bf V}, 1, 347$-$372
 
+\bibitem{She96}
+Shewchuk, J.R., 1996.
+Triangle: a two-dimensional quality mesh generator and Delaunay triangulator, version 1.3.
+Available from: $<$http://www-2.cs.cmu.edu/$\,\tilde{}\,$quake/triangle.html$>$.
+
 \bibitem{Sny81DEL}
 Snyder, R.L., Dobson, F.W., Elliott, J.A. and R.B. Long, 1981: Array measurement of atmospheric pressure
 fluctuations above surface gravity waves, {\it J. Fluid Mech}., {\bf 102}, 1-59
@@ -4228,74 +4442,78 @@
 \begin{theindex}
 \addcontentsline{toc}{chapter}{Index}
   \item ambient, \hyperpage{2}, \hyperpage{7}, \hyperpage{11, 12}, 
-		\hyperpage{29}, \hyperpage{85}
+		\hyperpage{29}, \hyperpage{91}
 
   \indexspace
 
-  \item bathymetry, \hyperpage{24}, \hyperpage{87}
+  \item bathymetry, \hyperpage{24}, \hyperpage{77}, \hyperpage{81, 82}, 
+		\hyperpage{93}
   \item bottom, \hyperpage{1--3}, \hyperpage{12, 13}, \hyperpage{15}, 
-		\hyperpage{22--24}, \hyperpage{30}, \hyperpage{82}, 
-		\hyperpage{84}, \hyperpage{87--92}
+		\hyperpage{22--24}, \hyperpage{30}, \hyperpage{80--82}, 
+		\hyperpage{88}, \hyperpage{90}, \hyperpage{93--98}
   \item boundary, \hyperpage{3, 4}, \hyperpage{13}, \hyperpage{15}, 
 		\hyperpage{43}, \hyperpage{59, 60}, \hyperpage{62, 63}, 
-		\hyperpage{65--69}, \hyperpage{86}, \hyperpage{88}
+		\hyperpage{65--69}, \hyperpage{78}, \hyperpage{80}, 
+		\hyperpage{92}, \hyperpage{94}
   \item breaking, \hyperpage{1}, \hyperpage{3}, \hyperpage{12, 13}, 
 		\hyperpage{15--17}, \hyperpage{21}, \hyperpage{23}, 
-		\hyperpage{42}, \hyperpage{56}, \hyperpage{79, 80}, 
-		\hyperpage{82, 83}, \hyperpage{87}, \hyperpage{91}
+		\hyperpage{42}, \hyperpage{56}, \hyperpage{85, 86}, 
+		\hyperpage{88, 89}, \hyperpage{93}, \hyperpage{97}
 
   \indexspace
 
-  \item Cartesian, \hyperpage{3}, \hyperpage{10--12}, \hyperpage{64}
+  \item Cartesian, \hyperpage{3}, \hyperpage{10--12}, \hyperpage{64}, 
+		\hyperpage{79}
   \item co-ordinate, \hyperpage{3}, \hyperpage{7}, \hyperpage{10--12}, 
 		\hyperpage{27}, \hyperpage{48--50}, \hyperpage{66}, 
 		\hyperpage{68}
   \item coastal, \hyperpage{1, 2}, \hyperpage{15}, \hyperpage{45}, 
-		\hyperpage{73}, \hyperpage{80, 81}, \hyperpage{83}, 
-		\hyperpage{85--87}, \hyperpage{89, 90}
+		\hyperpage{73}, \hyperpage{77}, \hyperpage{86, 87}, 
+		\hyperpage{89}, \hyperpage{91--93}, \hyperpage{95, 96}
   \item convergence, \hyperpage{36, 37}, \hyperpage{41}, 
-		\hyperpage{43--47}, \hyperpage{75, 76}, \hyperpage{89}, 
-		\hyperpage{93}
+		\hyperpage{43--47}, \hyperpage{75, 76}, \hyperpage{81}, 
+		\hyperpage{95}, \hyperpage{99}
   \item Courant, \hyperpage{40}
   \item current, \hyperpage{2, 3}, \hyperpage{7}, \hyperpage{10--13}, 
 		\hyperpage{15}, \hyperpage{29}, \hyperpage{32, 33}, 
 		\hyperpage{37, 38}, \hyperpage{40}, \hyperpage{43}, 
 		\hyperpage{49}, \hyperpage{55}, \hyperpage{61}, 
-		\hyperpage{74}, \hyperpage{76}, \hyperpage{82}, 
-		\hyperpage{85}, \hyperpage{89--92}
+		\hyperpage{74}, \hyperpage{76}, \hyperpage{88}, 
+		\hyperpage{91}, \hyperpage{95--98}
   \item curvi-linear, \hyperpage{2, 3}, \hyperpage{48, 49}, 
-		\hyperpage{62}, \hyperpage{68, 69}, \hyperpage{81}, 
-		\hyperpage{85}
+		\hyperpage{62}, \hyperpage{68, 69}, \hyperpage{87}, 
+		\hyperpage{91}
 
   \indexspace
 
-  \item dam, \hyperpage{16}, \hyperpage{29--31}, \hyperpage{85}, 
-		\hyperpage{92, 93}
+  \item dam, \hyperpage{16}, \hyperpage{29--31}, \hyperpage{91}, 
+		\hyperpage{98, 99}
   \item diffraction, \hyperpage{3}, \hyperpage{10}, \hyperpage{30--33}, 
-		\hyperpage{80}, \hyperpage{86, 87}
+		\hyperpage{86}, \hyperpage{92, 93}
   \item diffusion, \hyperpage{38--40}
   \item dissipation, \hyperpage{1}, \hyperpage{3}, \hyperpage{12--16}, 
-		\hyperpage{20, 21}, \hyperpage{23, 24}, \hyperpage{57}, 
-		\hyperpage{79--81}, \hyperpage{84}, \hyperpage{89}, 
-		\hyperpage{91, 92}
+		\hyperpage{20, 21}, \hyperpage{23, 24}, 
+		\hyperpage{56, 57}, \hyperpage{85--87}, \hyperpage{90}, 
+		\hyperpage{95}, \hyperpage{97, 98}
 
   \indexspace
 
   \item filter, \hyperpage{13}, \hyperpage{18}, \hyperpage{32}
-  \item flow, \hyperpage{7}, \hyperpage{61}, \hyperpage{81}, 
-		\hyperpage{86}, \hyperpage{88}, \hyperpage{93}
+  \item flow, \hyperpage{7}, \hyperpage{61}, \hyperpage{87}, 
+		\hyperpage{92}, \hyperpage{94}, \hyperpage{99}
   \item force, \hyperpage{33}, \hyperpage{49, 50}, \hyperpage{61--63}, 
-		\hyperpage{68, 69}, \hyperpage{82}
+		\hyperpage{68, 69}, \hyperpage{79}, \hyperpage{82}, 
+		\hyperpage{88}
   \item frequency, \hyperpage{7--9}, \hyperpage{11}, \hyperpage{13, 14}, 
 		\hyperpage{16}, \hyperpage{18--22}, \hyperpage{24, 25}, 
 		\hyperpage{28, 29}, \hyperpage{35--37}, \hyperpage{40}, 
 		\hyperpage{43--46}, \hyperpage{53--55}, 
-		\hyperpage{59, 60}, \hyperpage{79}, \hyperpage{87}, 
-		\hyperpage{93}
+		\hyperpage{59, 60}, \hyperpage{85}, \hyperpage{93}, 
+		\hyperpage{99}
   \item friction, \hyperpage{1}, \hyperpage{3}, \hyperpage{12, 13}, 
 		\hyperpage{15}, \hyperpage{18}, \hyperpage{22, 23}, 
-		\hyperpage{84}, \hyperpage{86, 87}, \hyperpage{89}, 
-		\hyperpage{91, 92}
+		\hyperpage{90}, \hyperpage{92, 93}, \hyperpage{95}, 
+		\hyperpage{97, 98}
 
   \indexspace
 
@@ -4309,6 +4527,7 @@
 
   \item initial, \hyperpage{13}, \hyperpage{15}, \hyperpage{28}, 
 		\hyperpage{59, 60}
+  \item island, \hyperpage{77}
 
   \indexspace
 
@@ -4326,16 +4545,16 @@
 		\hyperpage{38, 39}, \hyperpage{50--52}
   \item ocean, \hyperpage{1}, \hyperpage{7, 8}, \hyperpage{11}, 
 		\hyperpage{29}, \hyperpage{33}, \hyperpage{38}, 
-		\hyperpage{40}, \hyperpage{80}, \hyperpage{84--88}, 
-		\hyperpage{90--92}
+		\hyperpage{40}, \hyperpage{86}, \hyperpage{90--94}, 
+		\hyperpage{96}, \hyperpage{98}
 
   \indexspace
 
   \item propagation, \hyperpage{1--4}, \hyperpage{10--12}, 
 		\hyperpage{32}, \hyperpage{37}, \hyperpage{39}, 
 		\hyperpage{41, 42}, \hyperpage{48, 49}, \hyperpage{51}, 
-		\hyperpage{73, 74}, \hyperpage{80--83}, \hyperpage{89}, 
-		\hyperpage{91}
+		\hyperpage{73, 74}, \hyperpage{77}, \hyperpage{79, 80}, 
+		\hyperpage{86--89}, \hyperpage{95}, \hyperpage{97}
 
   \indexspace
 
@@ -4348,54 +4567,59 @@
 		\hyperpage{33}, \hyperpage{35}, \hyperpage{52}
   \item refraction, \hyperpage{1}, \hyperpage{3}, \hyperpage{11}, 
 		\hyperpage{31, 32}, \hyperpage{43}, \hyperpage{59}, 
-		\hyperpage{80, 81}, \hyperpage{86, 87}, \hyperpage{90}, 
-		\hyperpage{92}
+		\hyperpage{80}, \hyperpage{86, 87}, \hyperpage{92, 93}, 
+		\hyperpage{96}, \hyperpage{98}
   \item regular, \hyperpage{2}, \hyperpage{4}, \hyperpage{7}, 
-		\hyperpage{15}, \hyperpage{30}, \hyperpage{90}, 
-		\hyperpage{92}
+		\hyperpage{15}, \hyperpage{30}, \hyperpage{80}, 
+		\hyperpage{96}, \hyperpage{98}
 
   \indexspace
 
   \item set-up, \hyperpage{3, 4}, \hyperpage{24}, \hyperpage{33}, 
-		\hyperpage{61}, \hyperpage{69}, \hyperpage{79}
+		\hyperpage{61}, \hyperpage{69}, \hyperpage{85}
   \item shoaling, \hyperpage{1}, \hyperpage{3}, \hyperpage{15}, 
-		\hyperpage{82, 83}
+		\hyperpage{89}
   \item SORDUP, \hyperpage{38}, \hyperpage{40}, \hyperpage{73}
-  \item spherical, \hyperpage{3}, \hyperpage{11, 12}
+  \item spherical, \hyperpage{3}, \hyperpage{11, 12}, 
+		\hyperpage{80, 81}
   \item stability, \hyperpage{21}, \hyperpage{35, 36}, 
-		\hyperpage{39, 40}, \hyperpage{43}, \hyperpage{45, 46}
+		\hyperpage{39, 40}, \hyperpage{43}, \hyperpage{45, 46}, 
+		\hyperpage{78}, \hyperpage{80}
   \item stationary, \hyperpage{2, 3}, \hyperpage{7}, \hyperpage{36--38}, 
 		\hyperpage{40}, \hyperpage{44}, \hyperpage{49}, 
-		\hyperpage{60, 61}, \hyperpage{81, 82}, \hyperpage{85}, 
-		\hyperpage{93}
+		\hyperpage{60, 61}, \hyperpage{87, 88}, \hyperpage{91}, 
+		\hyperpage{99}
   \item steepness, \hyperpage{14}, \hyperpage{19--21}, \hyperpage{24}, 
 		\hyperpage{29}
   \item swell, \hyperpage{14, 15}, \hyperpage{21}, \hyperpage{23}, 
-		\hyperpage{81}, \hyperpage{84}, \hyperpage{92}
+		\hyperpage{87}, \hyperpage{90}, \hyperpage{98}
 
   \indexspace
 
   \item triads, \hyperpage{16}
+  \item triangular, \hyperpage{78}
 
   \indexspace
 
-  \item unstructured, \hyperpage{80}
+  \item unstructured, \hyperpage{4}, \hyperpage{77}, \hyperpage{80}, 
+		\hyperpage{86}
 
   \indexspace
 
   \item WAM, \hyperpage{1}, \hyperpage{13, 14}, \hyperpage{18--20}, 
 		\hyperpage{25}, \hyperpage{35, 36}, \hyperpage{44, 45}, 
-		\hyperpage{55}, \hyperpage{59}, \hyperpage{84, 85}, 
-		\hyperpage{90, 91}
-  \item WAVEWATCH, \hyperpage{1}, \hyperpage{59}, \hyperpage{91}
+		\hyperpage{55}, \hyperpage{59}, \hyperpage{90, 91}, 
+		\hyperpage{96}, \hyperpage{98}
+  \item WAVEWATCH, \hyperpage{1}, \hyperpage{59}, \hyperpage{97}
   \item whitecapping, \hyperpage{3}, \hyperpage{12--14}, \hyperpage{16}, 
-		\hyperpage{19--22}, \hyperpage{29}, \hyperpage{84}, 
-		\hyperpage{86}, \hyperpage{91, 92}
+		\hyperpage{19--22}, \hyperpage{29}, \hyperpage{90}, 
+		\hyperpage{92}, \hyperpage{97, 98}
   \item wind, \hyperpage{1--4}, \hyperpage{7}, \hyperpage{12--15}, 
 		\hyperpage{17--22}, \hyperpage{29}, \hyperpage{35}, 
 		\hyperpage{37--42}, \hyperpage{44, 45}, \hyperpage{50}, 
-		\hyperpage{60}, \hyperpage{68}, \hyperpage{79--81}, 
-		\hyperpage{84}, \hyperpage{86--93}
+		\hyperpage{60}, \hyperpage{68}, \hyperpage{77}, 
+		\hyperpage{79}, \hyperpage{85--87}, \hyperpage{90}, 
+		\hyperpage{92--99}
 
 \end{theindex}
 
--- SwanTranspAc.ftn90	2008-05-25 14:59:48.000000000 +0200
+++ SwanTranspAc.ftn90	2008-10-15 11:57:46.000000000 +0200
@@ -2,7 +2,7 @@
                           cax   , cay   , cad   , cas   , anybin, &
                           rdx   , rdy   , obredf, spcsig, idcmin, &
                           idcmax, iscmin, iscmax, iddlow, iddtop, &
-                          isslow, isstop )
+                          isslow, isstop, trac0 , trac1 )
 !
 !   --|-----------------------------------------------------------|--
 !     | Delft University of Technology                            |
@@ -40,6 +40,7 @@
 !   Updates
 !
 !   40.80, August 2007: New subroutine
+!   40.85, August 2008: add tranport terms for output purposes
 !
 !   Purpose
 !
@@ -85,6 +86,8 @@
     real, dimension(2), intent(in)              :: rdy    ! second component of contravariant base vector rdy(b) = a^(b)_2
     real, dimension(MDC,MSC), intent(out)       :: rhs    ! right-hand side of system of equations in (sigma,theta) space
     real, dimension(MSC), intent(in)            :: spcsig ! relative frequency bins
+    real, dimension(MDC,MSC,MTRNP), intent(out) :: trac0  ! explicit part of propagation in present vertex for output purposes
+    real, dimension(MDC,MSC,MTRNP), intent(out) :: trac1  ! implicit part of propagation in present vertex for output purposes
     !
     logical, dimension(MDC,MSC), intent(in)     :: anybin ! true if bin is active in considered sweep
 !
@@ -105,16 +108,18 @@
     amat = 0.
     rhs  = 0.
     !
-    ! set leak coefficient to zero
+    ! set leak and transport coefficients to zero
     !
     leakcf = 0.
+    trac0  = 0.
+    trac1  = 0.
     !
     ! compute transport in x-y space
     !
 !TIMG    call SWTSTA(140)
-    call SwanTranspX ( amat   , rhs, ac2   , ac1   , cax   , cay   , &
-                       rdx    , rdy, obredf, idcmin, idcmax, isslow, &
-                       isstop )
+    call SwanTranspX ( amat   , rhs  , ac2   , ac1   , cax   , cay   , &
+                       rdx    , rdy  , obredf, idcmin, idcmax, isslow, &
+                       isstop , trac0, trac1 )
 !TIMG    call SWTSTO(140)
     !
     ! compute transport in theta space
@@ -124,7 +129,8 @@
        !
        call STRSD ( DDIR       , idcmin     , idcmax     , cad    , &
                     amat(1,1,4), amat(1,1,1), amat(1,1,5), rhs    , &
-                    ac2        , isstop     , anybin     , leakcf )
+                    ac2        , isstop     , anybin     , leakcf , &
+                    trac0      , trac1      )
        !
     endif
 !TIMG    call SWTSTO(142)
@@ -140,7 +146,8 @@
           !
           call STRSSI ( spcsig     , cas   , amat(1,1,2), amat(1,1,1), &
                         amat(1,1,3), anybin, rhs        , ac2        , &
-                        iscmin     , iscmax, iddlow     , iddtop     )
+                        iscmin     , iscmax, iddlow     , iddtop     , &
+                        trac0      , trac1 )
           !
        else
           !
--- SwanTranspX.ftn90	2008-05-25 14:59:48.000000000 +0200
+++ SwanTranspX.ftn90	2008-10-15 11:57:47.000000000 +0200
@@ -1,6 +1,6 @@
-subroutine SwanTranspX ( amat   , rhs, ac2   , ac1   , cax   , cay   , &
-                         rdx    , rdy, obredf, idcmin, idcmax, isslow, &
-                         isstop )
+subroutine SwanTranspX ( amat   , rhs  , ac2   , ac1   , cax   , cay   , &
+                         rdx    , rdy  , obredf, idcmin, idcmax, isslow, &
+                         isstop , trac0, trac1 )
 !
 !   --|-----------------------------------------------------------|--
 !     | Delft University of Technology                            |
@@ -38,10 +38,11 @@
 !   Updates
 !
 !   40.80, August 2007: New subroutine
+!   40.85, August 2008: add xy-propagation for output purposes
 !
 !   Purpose
 !
-!   Computes transport in x-y space using the N scheme
+!   Computes transport in x-y space using the first order upwind scheme
 !
 !   Modules used
 !
@@ -76,6 +77,8 @@
     real, dimension(2), intent(in)              :: rdx    ! first component of contravariant base vector rdx(b) = a^(b)_1
     real, dimension(2), intent(in)              :: rdy    ! second component of contravariant base vector rdy(b) = a^(b)_2
     real, dimension(MDC,MSC), intent(inout)     :: rhs    ! right-hand side of system of equations in (sigma,theta) space
+    real, dimension(MDC,MSC,MTRNP), intent(out) :: trac0  ! explicit part of propagation in present vertex for output purposes
+    real, dimension(MDC,MSC,MTRNP), intent(out) :: trac1  ! implicit part of propagation in present vertex for output purposes
 !
 !   Local variables
 !
@@ -122,7 +125,7 @@
        do iddum = idcmin(is), idcmax(is)
           id = mod ( iddum - 1 + MDC , MDC ) + 1
           !
-          ! compute the contributions based on the N scheme
+          ! compute the contributions based on the first order upwind scheme
           !
           asum = (rdx(1)+rdx(2))*cax(id,is,1) + (rdy(1)+rdy(2))*cay(id,is,1)
           !
@@ -134,6 +137,9 @@
           amat(id,is,1) = amat(id,is,1) + asum
           rhs (id,is  ) = rhs (id,is  ) + rsum
           !
+          trac0(id,is,1) = trac0(id,is,1) - rsum
+          trac1(id,is,1) = trac1(id,is,1) + asum
+          !
           if ( NSTATC == 1 ) then
              !
              if ( ITERMX == 1 ) then
@@ -145,6 +151,9 @@
              amat(id,is,1) = amat(id,is,1) + RDTIM
              rhs (id,is  ) = rhs (id,is  ) + acold*RDTIM
              !
+             trac0(id,is,1) = trac0(id,is,1) - acold*RDTIM
+             trac1(id,is,1) = trac1(id,is,1) + RDTIM
+             !
           endif
           !
        enddo
--- swanuse.tex	2008-05-25 14:59:53.000000000 +0200
+++ swanuse.tex	2008-10-15 13:02:09.000000000 +0200
@@ -32,7 +32,7 @@
 \end{center}
 \vfill
 \begin{center}
-{\Large\bf SWAN Cycle III version 40.72}
+{\Large\bf SWAN Cycle III version 40.72A}
 \end{center}
 
 \cleardoublepage
@@ -93,8 +93,9 @@
 the complete input and usage of the SWAN package. The Implementation Manual explains the installation procedure
 of SWAN on a single- or multi-processor machine with shared or distributed memory. The System documentation outlines
 the internals of the program and discusses program maintenance. The Programming rules is meant for programmers
-who want to develop SWAN. The Technical documentation discusses the mathematical details and the discretizations
-that are used in the SWAN program. The mapping of these numerical techniques in SWAN code is also discussed.
+who want to develop SWAN. The Scientific/Technical documentation discusses the physical and mathematical details
+and the discretizations that are used in the SWAN program. The mapping of these numerical techniques in SWAN code
+is also discussed.
 \nocite{Impman,Sysdoc,Progrul,Techdoc}
 \\[2ex]
 \noindent
@@ -189,19 +190,22 @@
 wave flume (long-crested waves).
 \\[2ex]
 \noindent
-As an option SWAN computes {\bf wave induced set-up}. In 1D cases the computations are
-based on exact equations. In 2D cases, the computations are based on approximate equations. The
-effects of wave-induced currents are always ignored.
+As an option SWAN computes {\bf wave-induced set-up}. In 1D cases the computations are
+based on exact equations. In 2D cases, the computations are based on approximate equations.
+This approximation in SWAN can \underline{only} be applied to open coast (unlimited supply of water from outside
+the domain, e.g. nearshore coasts and estuaries) in contrast to closed basin, e.g. lakes, where this option
+should not be used.
+The effects of wave-induced currents are always ignored.
 \\[2ex]
 \noindent
 SWAN does not calculate {\bf wave-induced currents}. If relevant, such currents should be provided as input
 to SWAN, e.g. from a circulation model which can be driven by waves from SWAN in an iteration procedure.
 \\[2ex]
 \noindent
-{\bf Diffraction} is modelled in a restrict sense, so the model should be used in areas where variations in
-wave height are large within a horizontal scale of a few wave lengths. However, the computation of diffraction
+In areas where variations in wave height are large within a horizontal scale of a few wave lengths,
+{\bf diffraction} should be used. However, the computation of diffraction
 in arbitrary geophysical conditions is rather complicated and requires considerable computing effort. To
-avoid this, a phase-decoupled approach is employed so that same qualitative behaviour of spatial redistribution
+avoid this, a phase-decoupled approach is employed in SWAN so that same qualitative behaviour of spatial redistribution
 and changes in wave direction is obtained.
 This approach, however, does not properly handle diffraction in harbours
 or in front of reflecting obstacles.
@@ -695,7 +699,7 @@
 always at computational times.
 
 \section{Activation of physical processes}
-SWAN contains a number of physical processes (see Technical documentation) that add or withdraw wave energy to or
+SWAN contains a number of physical processes (see Scientific/Technical documentation) that add or withdraw wave energy to or
 from the wave field. The processes included are: wind input, whitecapping, bottom friction, depth-induced
 wave breaking, obstacle transmission, nonlinear wave-wave interactions (quadruplets and triads) and
 wave-induced set-up. SWAN can run in several modes, indicating the level of parameterization. SWAN can operate
@@ -788,7 +792,7 @@
 SWAN can run for dates (i.e. nonstationary mode)
 \begin{itemize}
   \item between the years 0 and 9999, if ISO-notation is used in the input (recommended) or
-  \item between the years 1911 and 2010 if two-digit code for years is used (formats 2-6 in every
+  \item between the years 1931 and 2030 if two-digit code for years is used (formats 2-6 in every
         command that contains moments in time).
 \end{itemize}
 Be careful when nesting SWAN in WAM, since WAM does not use ISO-notation.
@@ -1396,7 +1400,8 @@
 than 143$^o$. If, at least, one of these two situations occur, SWAN will print an error message.
 \begin{tabbing}
 xxxxxxxxxxx\= \kill
-{\tt ADCIRC}   \> the necessary grid information is read from file {\tt fort.14} as used by ADCIRC.\\
+{\tt ADCIRC}   \> the necessary grid information is read from file {\tt fort.14} as used by ADCIRC.\+\\
+                  This file also contains the depth information that is read as well.\-\\
 {\tt TRIANGLE} \> the necessary grid information is read from two files as produced by Triangle.\+\\
                   The {\tt .node} and {\tt .ele} files are required. The basename of these files must be\\
                   indicated with parameter {\tt 'fname'}.\-\\
@@ -1477,7 +1482,12 @@
 Note that in case of option {\tt BOTTOM} only stationary input field is allowed.
 \\[2ex]
 \noindent
-If the computational grid is unstructured, the input grids can be either regular or identical to the used computational grid.
+If the computational grid is unstructured (generated by Triangle or Easymesh), the input grids can be either regular
+or identical to the used computational grid.
+\\[2ex]
+\noindent
+Do not use the command {\tt INP BOTTOM} when the unstructured grid of ADCIRC is employed!
+The file {\tt fort.14} contains the bottom levels and will be read by SWAN through the command {\tt READ UNSTRUC ADCIRC}.
 \\[2ex]
 \noindent
 If land points remain dry during the computation (no flooding!), then these points can be ignored.
@@ -1806,7 +1816,7 @@
 {\tt [dir]}   \> wind direction at 10 m elevation (in degrees, Cartesian or Nautical\+\\
                  convention, see command {\tt SET}).\-\\
 \end{tabbing}
-Both quantities are required if this command is used. Note that SWAN converts $U _{10}$ to $U _{*}$ (see Technical documentation).
+Both quantities are required if this command is used. Note that SWAN converts $U _{10}$ to $U _{*}$ (see Scientific/Technical documentation).
 
 \subsection{Boundary and initial conditions}
 
@@ -1929,8 +1939,8 @@
 {\tt [k]}            \> indicates on which side of the \underline{unstructured} grid the boundary condition is\+\\
                         applied. The value of {\tt [k]} corresponds to the boundary marker as indicated in\\
                         file(s) produced by a grid generator (such as in the last column of the Triangle\\
-                        {\tt .node} file and the Easymesh {\tt .n} file). Boundary markers are tags to identify\\
-                        which vertices occur on a boundary of the mesh.\\
+                        {\tt .node} file and the Easymesh {\tt .n} file or the last part of file {\tt fort.14}). Boundary\\
+                        markers are tags to identify which vertices occur on a boundary of the mesh.\\
                         ONLY MEANT FOR UNSTRUCTURED MESHES.\-\\
 {\tt CCW,}           \> see description of {\tt [len]} below; these option are only effective if the\\
 {\tt CLOCKWISE}      \> option {\tt VARIABLE} is used (see below).\\
@@ -2036,9 +2046,9 @@
                         files are ignored when SWAN reads this file (SWAN uses the geographical\\
                         information in this {\tt BOUNDSPEC} command instead).\-\\
 {\tt {'fname'}}      \> name of the file containing the boundary condition.\\
-{\tt [seq]}          \> identification number of geographic location in the file (see Appendix~\ref{app:spcform});\+\\
+{\tt [seq]}          \> sequence number of geographic location in the file (see Appendix~\ref{app:spcform});\+\\
                         useful for files which contain spectra for more than one location.\\
-                        Default: {\tt [seq]} = 1.\\
+                        Default: {\tt [seq]} = 1 (i.e. first location).\\
                         Note: a {\tt TPAR} file always contains only one location so in this case\\
                         {\tt [seq]} must always be 1.\-\\
 \end{tabbing}
@@ -2075,7 +2085,7 @@
 \\[2ex]
 \noindent
 A nested SWAN run must use the same coordinate system as the coarse grid SWAN run. For a curvi-linear grid,
-it is advised to use the commands {\tt CURVE} and {\tt SPECOUT} instead of {\tt NGRID} and {\tt NESTOUT}.
+it is advised to use the commands {\tt POINTS} or {\tt CURVE} and {\tt SPECOUT} instead of {\tt NGRID} and {\tt NESTOUT}.
 \begin{tabbing}
 xxxxxxxxxxxx\= \kill
 {\tt NEST}      \> with this option the user indicates that the boundary conditions (all four sides\+\\
@@ -2314,7 +2324,7 @@
 \linecmd
 
 \noindent
-With this command the user indicates that SWAN should run in first-generation mode (see Technical documentation).
+With this command the user indicates that SWAN should run in first-generation mode (see Scientific/Technical documentation).
 \begin{tabbing}
 xxxxxxxxxxxx\= \kill
 {\tt [cf10]}   \> controls the linear wave growth.\+\\
@@ -2346,7 +2356,7 @@
 \linecmd
 
 \noindent
-With this command the user indicates that SWAN should run in second-generation mode (see Technical documentation).
+With this command the user indicates that SWAN should run in second-generation mode (see Scientific/Technical documentation).
 The variables are identical to those in the {\tt GEN1} command except that {\tt [cf50]} and {\tt [cf60]} are added.
 \begin{tabbing}
 xxxxxxxxxxxx\= \kill
@@ -2369,7 +2379,7 @@
 
 \noindent
 With this command the user indicates that SWAN should run in third-generation mode for wind input, quadruplet interactions and whitecapping.
-Triads, bottom friction and depth-induced breaking are not activated by this command. See the Technical documentation for more information.
+Triads, bottom friction and depth-induced breaking are not activated by this command. See the Scientific/Technical documentation for more information.
 The option {\tt GEN3 KOMEN} is default.
 \begin{tabbing}
 xxxxxxxxxxxx\=xxxxxxxxxxxxxxxx\= \kill
@@ -2409,7 +2419,7 @@
 \linecmd
 
 \noindent
-With this command the user wants to choose the Cumulative Steepness Method (CSM) for approximating whitecapping (see Technical documentation)
+With this command the user wants to choose the Cumulative Steepness Method (CSM) for approximating whitecapping (see Scientific/Technical documentation)
 and {\bf not} the formulation of Komen {\it et al.} (1984) and {\bf not} Janssen (1991a).
 \begin{tabbing}
 xxxxxxxxxxxx\= \kill
@@ -2563,7 +2573,7 @@
 \linecmd
 
 \noindent
-With this command the user can de-activate permamently the quadruplets when the actual Ursell number
+With this command the user can de-activate permanently the quadruplets when the actual Ursell number
 exceeds {\tt [ursell]}. Moreover, as soon as the actual fraction of breaking waves exceeds {\tt [qb]} then the limiter
 will not be used in case of decreasing action density.
 \begin{tabbing}
@@ -2704,13 +2714,17 @@
 CANNOT BE USED IN CASE OF \underline{UNSTRUCTURED GRIDS}.
 \\[2ex]
 \noindent
-If this optional command is given, the wave induced set-up is computed and accounted for in the wave
+If this optional command is given, the wave-induced set-up is computed and accounted for in the wave
 computations (during the computation it is added to the depth that is obtained from the {\tt READ BOTTOM}
-and {\tt READ WLEVEL} commands). Note that set-up is not computed correctly with spherical coordinates.
+and {\tt READ WLEVEL} commands).
+This approximation in SWAN can \underline{only} be applied to open coast (unlimited supply of water from outside
+the domain, e.g. nearshore coasts and estuaries) in contrast to closed basin, e.g. lakes, where this option
+should not be used.
+Note that set-up is not computed correctly with spherical coordinates.
 Note that set-up is not supported in case of parallel runs using MPI and also not tested with OpenMP!
 \begin{tabbing}
 xxxxxxxxxxxx\= \kill
-{\tt [supcor]} \> by default the wave induced set-up is computed with a constant added such that the\+\\
+{\tt [supcor]} \> by default the wave-induced set-up is computed with a constant added such that the\+\\
                   set-up is zero in the deepest point in the computational grid. The user can modify\\
                   this constant by the value of {\tt [supcor]}. The user can thus impose a set-up in any\\
                   one point (and only one) in the computational grid by first running SWAN, then\\
@@ -2732,7 +2746,7 @@
 \noindent
 If this optional command is given, the diffraction is included in the wave computation.
 But the diffraction approximation in SWAN does not properly handle diffraction in harbours
-or in front of reflecting obstacles (see Technical documentation). Behind breakwaters with a
+or in front of reflecting obstacles (see Scientific/Technical documentation). Behind breakwaters with a
 down-wave beach, the SWAN results seem reasonable. The \underline{spatial resolution} near (the tip of)
 the diffraction obstacle should be 1/5 to 1/10 of the dominant wave length.
 \\[2ex]
@@ -2741,7 +2755,7 @@
 measures can be taken:
 \begin{enumerate}
   \item (RECOMMENDED) The user can request under-relaxation. See command {\tt NUMERIC} parameter {\tt [alpha]}
-        and Technical documentation (Eq. (3.31)). Very limited experience suggests {\tt [alpha]} = 0.01.
+        and Scientific/Technical documentation (Eq. (3.31)). Very limited experience suggests {\tt [alpha]} = 0.01.
   \item Alternatively, the user can request smoothing of the wave field for the computation of the diffraction
         parameter (the wave field remains intact for all other computations and output). This is done with a
         repeated convolution filtering. The mother filter is
@@ -2749,7 +2763,7 @@
            E^n_{i,j} = E^{n-1}_{i,j} - a \left[ E_{i-1,j} + E_{i,j-1} -4E_{i,j} + E_{i+1,j} + E_{i,j+1} \right]^{n-1}
         \end{displaymath}
         For $a = 0.2$ (recommended), the final width of the filter is $\varepsilon_x = \frac{1}{2} \sqrt{3n} \Delta x$
-        (in $x-$direction and similarly in $y-$direction) and $n$ is the number of repetitions (see Technical
+        (in $x-$direction and similarly in $y-$direction) and $n$ is the number of repetitions (see Scientific/Technical
         documentation, Eq. (2.100)).
 \end{enumerate}
 \begin{tabbing}
@@ -2830,8 +2844,8 @@
 {\tt BSBT}      \> the BSBT scheme will be used in the computations.\\
 {\tt GSE}       \> garden-sprinkler-effect is to be counteracted in the S\&L propagation scheme\+\\
                    (default for nonstationary computations) by adding a diffusion term to the basic\\
-                   equation. This may affect the numerical stability of SWAN (see Technical\\
-                   documentation).\-\\
+                   equation. This may affect the numerical stability of SWAN (see Scientific/\\
+                   Technical documentation).\-\\
 {\tt [waveage]} \> the time interval used to determine the diffusion which counteracts the so-called\+\\
                    garden-sprinkler effect. The default value of {\tt [waveage]} is zero, i.e. no added\\
                    diffusion. The value of {\tt [waveage]} should correspond to the travel time of\\
@@ -2843,7 +2857,7 @@
         higher order schemes (S\&L and SORDUP) it is important to use a gradually varying grid, otherwise there
         may be a severe loss of accuracy. If sharp transitions in the grid cannot be avoided it is safer to use
         the BSBT scheme.
-  \item In the computation with unstructured meshes, the so-called N-scheme will be employed. This compact
+  \item In the computation with unstructured meshes, a first order upwind scheme will be employed. This
         scheme is very robust but rather diffusive. This may only be significant for the case when swell
         waves propagate over relative large distances (in the order of thousands of kilometers) within the
         model domain.
@@ -2895,15 +2909,14 @@
                   DEFAULT IN CASE OF STRUCTURED GRIDS.\-\\
 {\tt STOPC}    \> With this alternative option the user can influence the criterion for terminating\+\\
                   the iterative procedure in the SWAN computations (both stationary and\\
-                  nonstationary). This criterion is solely based on the significant wave height.\\
-                  Furthermore, the criterion make use of the second derivative, or curvature, of\\
-                  the iteration curve of the significant wave height. As the solution of a simulation\\
-                  approaches full convergence the curvature of the iteration curve will tend to zero.\\
-                  SWAN stops the process {\bf if} the absolute change in the local significant wave height\\
-                  ($H_s$) from one iteration to the next is less than {\tt [dabs]} {\bf or} the relative\\
-                  change in the local significant wave height from one iteration to the next is less than\\
+                  nonstationary). The criterion make use of the second derivative, or curvature,\\
+                  of the iteration curve of both the significant wave height and the mean period.\\
+                  As the solution of a simulation approaches full convergence, the curvature of the\\
+                  iteration curve will tend to zero. SWAN stops the process {\bf if} the absolute change\\
+                  in both $H_s$ and $T_{m01}$ from one iteration to the next is less than {\tt [dabs]} {\bf or} the\\
+                  relative change in $H_s$ and $T_{m01}$ from one iteration to the next is less than\\
                   {\tt [drel]} {\bf and} the curvature of the iteration curve of $H_s$ normalized with $H_s$\\
-                  is less than {\tt [curvat]}.\\
+                  and that of $T_{m01}$ normalized with $T_{m01}$ is less than {\tt [curvat]}.\\
                   DEFAULT IN CASE OF UNSTRUCTURED GRIDS.\-\\
 {\tt [dabs]}   \> Default: {\tt [dabs]} = 0.00 [$-$] in case of structured grids; {\tt [dabs]} = 0.005 [$-$]\+\\
                   in case of unstructured grids.\-\\
@@ -2920,6 +2933,7 @@
                   Note that {\tt [mxitst]} can be set to 0 if one wants to check the input to the\\
                   model without making computations.\-\\
 {\tt [alfa]}   \> proportionality constant used in the frequency-dependent under-relaxation technique.\+\\
+                  Based on experiences, a suggestion for this parameter is {\tt [alfa]} = 0.01.\\
                   In case of diffraction computations, the use of this parameter is recommended.\\
                   Default: {\tt [alfa]} = 0.00.\\
                   NOT MEANINGFUL FOR NONSTATIONARY COMPUTATIONS.\-\\
@@ -2931,8 +2945,8 @@
                   model without making computations.\-\\
 {\tt [limiter]}\> determines, in both stationary and nonstationary runs, the maximum change per\+\\
                   iteration of the energy density per spectral ($\sigma$,$\theta$)-bin, given in\\
-                  terms of a fraction of the omni-directional Phillips level (see Technical\\
-                  documentation).\\
+                  terms of a fraction of the omni-directional Phillips level (see Scientific/\\
+                  Technical documentation).\\
                   Default: {\tt [limiter]} = 0.1.\-\\
 {\tt DIRIMPL}  \> this option is used to influence the numerical scheme for refraction.\\
 {\tt [cdd]}    \> A value of {\tt [cdd]}=0 corresponds to a central scheme and has the largest\+\\
@@ -3437,10 +3451,10 @@
                  Default: {\tt comment} = \%\-\\
 {\tt field}   \> length of one data field in a table. Minimum is 8 and maximum is 16.\+\\
                  Default: {\tt field} = 12\-\\
-{\tt ndec}    \> number of decimals in block (if appearing after keyword {\tt BLOCK}) or spectral\+\\
-                 output (if appearing after keyword {\tt SPEC}). Maximum is 9.\\
-                 Default: {\tt ndec} = 4 (in both cases)\-\\
-{\tt len}     \> number of data on one line of output. Maximum is 9999.\+\\
+{\tt ndec}    \> number of decimals in block (if appearing after keyword {\tt BLOCK}) or\+\\
+                 2D spectral output (if appearing after keyword {\tt SPEC}). Maximum is 9.\\
+                 Default: {\tt ndec} = 4 (in both block and spectral outputs)\-\\
+{\tt len}     \> number of data on one line of block output. Maximum is 9999.\+\\
                  Default: {\tt len} = 6\-\\
 \end{tabbing}
 
@@ -3495,16 +3509,36 @@
            |           |
            | FRCoef    |
            |           |
-           | WIND      |                                          | -> Sec  |
+           | WIND      |
+           |           |
+           | PROPAgat  |
+           |           |
+           | PROPXy    |
+           |           |
+           | PROPTheta |
+           |           |
+           | PROPSigma |
+           |           |
+           | GENErat   |                                          | -> Sec  |
      <    <             >  [unit] > (OUTput [tbegblk] [deltblk]) <     MIn   >
-           | DISSip    |                                          |    HR   |
+           | GENWind   |                                          |    HR   |
            |           |                                          |    DAy  |
+           | REDIst    |
+           |           |
+           | REDQuad   |
+           |           |
+           | REDTriad  |
+           |           |
+           | DISSip    |
+           |           |
            | DISBot    |
            |           |
            | DISSUrf   |
            |           |
            | DISWcap   |
            |           |
+           | RADStr    |
+           |           |
            | QB        |
            |           |
            | TRAnsp    |
@@ -3555,7 +3589,8 @@
 {\tt HEADER}    \> with this option the user indicates that the output should be written to a file\+\\
                    with header lines. The text of the header indicates run identification (see\\
                    command {\tt PROJECT}), time, frame name or group name ({\tt {'sname'}}), variable and\\
-                   unit. The number of header lines is 8.\-\\
+                   unit. The number of header lines is 8.\\
+                   Note: the numerical values in the file are in the units indicated in the header.\-\\
 {\tt NOHEADER}  \> with this option the user indicates that the output should be written to a file\+\\
                    without header lines.\-\\
 {\tt {'fname'}} \> name of the data file where the output is to be written to. Default for option\+\\
@@ -3572,7 +3607,8 @@
 {\tt [idla]}    \> see command {\tt READINP} (options are: {\tt [idla]}=1, 3, 4). Option 4 is recommended\+\\
                    for postprocessing by MATLAB, however, in case of a generated binary\\
                    MATLAB file option 3 is recommended.\\
-                   Default: {\tt [idla]} = 1.\-\\
+                   Default: {\tt [idla]} = 1.\\
+                   ONLY MEANT FOR STRUCTURED GRIDS.\-\\
 \end{tabbing}
 
 \noindent
@@ -3619,28 +3655,48 @@
                 Output is in both active and non-active points.\\
                 Note: exception value for bottom levels must be given!\\
                 (See command {\tt INPGRID BOTTOM EXCEPTION}).\-\\
-{\tt VEL}    \> current velocity (in m/s).\\
+{\tt VEL}    \> current velocity (vector; in m/s).\\
 {\tt FRCOEF} \> friction coefficient (equal to {\tt [cfw]} or {\tt [kn]} in command {\tt FRICTION}).\\
-{\tt WIND}   \> wind velocity (in m/s).\\
-{\tt DISSIP} \> energy dissipation due to bottom friction, wave breaking and whitecapping\+\\
+{\tt WIND}   \> wind velocity (vector; in m/s).\\
+{\tt PROPAGAT} \> total energy propagation\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt PROPXY} \> energy propagation in geographic space\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt PROPTHETA} \> energy propagation in theta space\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt PROPSIGMA} \> energy propagation in sigma space\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt GENERAT} \> total energy generation\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt GENWIND} \> energy generation due to wind\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt REDIST} \> total energy redistribution\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt REDQUAD} \> energy redistribution due to quadruplets\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt REDTRIAD} \> energy redistribution due to triads\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt DISSIP} \> total energy dissipation\+\\
                 (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
 {\tt DISBOT} \> energy dissipation due to bottom friction\+\\
                 (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
-{\tt DISSURF} \> energy dissipation due to wave breaking\+\\
+{\tt DISSURF} \> energy dissipation due to surf breaking\+\\
                 (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
 {\tt DISWCAP} \> energy dissipation due to whitecapping\+\\
                 (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
+{\tt RADSTR} \> radiation stress\+\\
+                (in W/m$^2$ or m$^2$/s, depending on command {\tt SET}).\-\\
 {\tt QB}     \> fraction of breaking waves due to depth-induced breaking.\\
-{\tt TRANSP} \> transport of energy (vector; W/m or m$^3$/s, depending on command {\tt SET}).\\
-{\tt FORCE}  \> wave induced force per unit surface area (vector; in N/m$^2$).\\
+{\tt TRANSP} \> transport of energy (vector; in W/m or m$^3$/s, depending on command {\tt SET}).\\
+{\tt FORCE}  \> wave-induced force per unit surface area (vector; in N/m$^2$).\\
 {\tt UBOT}   \> the rms-value of the \underline{maxima} of the orbital velocity near the bottom (in m/s).\+\\
                 Output only if command {\tt FRICTION} is used. If one wants to output {\tt UBOT} but\\
                 friction is ignored in the computation, then one should use the command\\
-                {\tt FRICTION} with the value of the friction set at zero ({\tt FRICTION COLLINS 0}).\-\\
+                {\tt FRICTION} with the value of the friction set to zero ({\tt FRICTION COLLINS 0}).\-\\
 {\tt URMS}   \> the rms-value of the of the orbital velocity near the bottom (in m/s).\+\\
                 If one wants to output {\tt URMS} but friction is ignored in the computation,\\
                 then one should use the command {\tt FRICTION} with the value of the friction\\
-                set at zero ({\tt FRICTION COLLINS 0}).\-\\
+                set to zero ({\tt FRICTION COLLINS 0}).\-\\
 {\tt TMBOT}  \> the bottom wave period (in s).\\
 {\tt WLEN}   \> average wavelength (in m).\\
 {\tt STEEPNESS} \> average wave steepness (dimensionless).\\
@@ -4212,10 +4268,21 @@
                         \end{table}
 \begin{tabbing}
 xxxxxxxxxxxxxxxxxx\= \kill
+PROPAGAT             \> Energy propagation per unit time in $\vec{x}-$, $\theta-$ and $\sigma-$space\+\\
+                        (in W/${\rm m}^2$ or ${\rm m}^2$/s, depending on the command {\tt SET}).\-\\
+GENERAT              \> Energy generation per unit time due to the wind input\+\\
+                        (in W/${\rm m}^2$ or ${\rm m}^2$/s, depending on the command {\tt SET}).\-\\
+REDIST               \> Energy redistribution per unit time due to the sum of quadruplets\+\\
+                        and triads (in W/${\rm m}^2$ or ${\rm m}^2$/s, depending on the command {\tt SET}).\-\\
 DISSIP               \> Energy dissipation per unit time due to the sum of bottom friction,\+\\
                         whitecapping and depth-induced
-                        wave breaking (in W/${\rm m}^2$ or ${\rm m}^2$/s,\\
+                        surf breaking (in W/${\rm m}^2$ or ${\rm m}^2$/s,\\
                         depending on the command {\tt SET}).\-\\
+RADSTR               \> Radiation stress per unit time, defined as\+\\
+                        \\
+$\int\limits_{0}\limits^{2\pi} \int\limits_{\sigma_{\mbox{\tiny low}}}\limits^{\sigma_{\mbox{\tiny high}}} |S_{\rm tot} - \frac{\partial E}{\partial t} - \nabla_{\vec{x}} \cdot [({\vec{c}}_g + \vec{U}) E] - \nabla_{(\sigma,\theta)} \cdot ({\vec{c}}_{(\sigma,\theta)} E)| d\sigma d\theta$ \\
+                        \\
+                        (in W/${\rm m}^2$ or ${\rm m}^2$/s, depending on the command {\tt SET}).\-\\
 WLEN                 \> The mean wavelength, defined as\+\\
                         \\
 ${\rm WLEN} = 2\pi \left( \frac{\int \int k^{p} E(\sigma,\theta)d\sigma d\theta}{\int \int k^{p-1} E(\sigma,\theta)d\sigma d\theta} \right)^{-1}$ \\
@@ -4235,12 +4302,12 @@
                         except in the case of output with {\tt BLOCK} command in combination\\
                         with command {\tt FRAME}, where $x$ and $y$ relate to the $x-$axis and $y-$axis\\
                         of the output frame.\-\\
-VEL                  \> Current velocity components in $x$ and $y$ direction of the problem\+\\
+VEL                  \> Current velocity components in $x-$ and $y-$direction of the problem\+\\
                         coordinate system,
                         except in the case of output with {\tt BLOCK} command in\\
                         combination with command {\tt FRAME}, where $x$ and $y$ relate to the $x-$axis\\
                         and $y-$axis of the output frame.\-\\
-WIND                 \> Wind velocity components in $x$ and $y$ direction of the problem coordinate\+\\
+WIND                 \> Wind velocity components in $x-$ and $y-$direction of the problem coordinate\+\\
                         sytem, except in the case of output with {\tt BLOCK} command in
                         combination\\
                         with command {\tt FRAME}, where $x$ and $y$ relate to the $x-$axis and $y-$axis of\\
@@ -4676,14 +4743,16 @@
 !          <  DSPR|HSIGN|DIR|PDIR|TDIR|TM01|RTM01|RTP|TM02|FSPR|DEPTH|VEL|  &
 !             FRCOEFF|WIND|DISSIP|QB|TRANSP|FORCE|UBOT|URMS|WLEN|STEEPNESS| &
 !             DHSIGN|DRTM01|LEAK|TSEC|XP|YP|DIST|SETUP|TMM10|RTMM10|        &
-!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP  >      &
+!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP|        &
+!             GENE|GENW|REDI|REDQ|REDT|PROPA|PROPX|PROPT|PROPS|RADS >       &
 !             ([unit]) (OUTPUT [tbegblk] [deltblk] SEC|MIN|HR|DAY)
 !
 !   TABLE   'sname'  HEADER | NOHEADER | INDEXED 'fname'                    &
 !          <  DSPR|HSIGN|DIR|PDIR|TDIR|TM01|RTM01|RTP|TM02|FSPR|DEPTH|VEL|  &
 !             FRCOEFF|WIND|DISSIP|QB|TRANSP|FORCE|UBOT|URMS|WLEN|STEEPNESS| &
 !             DHSIGN|DRTM01|LEAK|TIME|TSEC|XP|YP|DIST|SETUP|TMM10|RTMM10|   &
-!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP  >      &
+!             TMBOT|QP|BFI|WATLEV|BOTLEV|TPS|DISBOT|DISSURF|DISWCAP|        &
+!             GENE|GENW|REDI|REDQ|REDT|PROPA|PROPX|PROPT|PROPS|RADS >       &
 !             ([unit]) (OUTPUT [tbegtbl] [delttbl] SEC|MIN|HR|DAY)
 !
 !   SPECout 'sname'  SPEC1D|SPEC2D  ABS|REL   'fname'                       &
@@ -4732,7 +4801,7 @@
 
 \begin{verbatim}
 SWAN   1                                Swan standard spectral file, version
-$ Data produced by SWAN version 40.72
+$ Data produced by SWAN version 40.72A
 $ Project:'projname'     ;   run number:'runnum'
 TIME                                    time-dependent data
      1                                  time coding option
@@ -4838,7 +4907,7 @@
 
 \begin{verbatim}
 SWAN   1                                Swan standard spectral file, version
-$ Data produced by SWAN version 40.72
+$ Data produced by SWAN version 40.72A
 $ Project:'projname'     ;   run number:'runnum'
 LOCATIONS                               locations in x-y-space
      1                                  number of locations
@@ -5028,8 +5097,8 @@
 {SWAN -- System documentation}. Delft University of Technology, Environmental Fluid Mechanics Section, to be available.
 
 \bibitem{Techdoc}
-{SWAN -- Technical documentation}. Delft University of Technology, Environmental Fluid Mechanics Section, available from
-\hl{http://www.fluidmechanics.tudelft.nl/swan/index.htm} (Version 40.72, May 2008).
+{SWAN -- Scientific and Technical documentation}. Delft University of Technology, Environmental Fluid Mechanics Section, available from
+\hl{http://www.fluidmechanics.tudelft.nl/swan/index.htm} (Version 40.72A, October 2008).
 
 \end{thebibliography}
 
@@ -5040,57 +5109,56 @@
   \indexspace
 
   \item bathymetry, \hyperpage{5}, \hyperpage{10, 11}, \hyperpage{64}, 
-		\hyperpage{84}
+		\hyperpage{85}
   \item BLOCK, \hyperpage{74}
-  \item bottom, \hyperpage{3}, \hyperpage{8--11}, \hyperpage{13}, 
-		\hyperpage{16, 17}, \hyperpage{19}, \hyperpage{21, 22}, 
-		\hyperpage{24}, \hyperpage{34, 35}, \hyperpage{38, 39}, 
-		\hyperpage{53}, \hyperpage{55, 56}, \hyperpage{58}, 
-		\hyperpage{65}, \hyperpage{67}, \hyperpage{69}, 
-		\hyperpage{78, 79}, \hyperpage{84, 85}, 
-		\hyperpage{92, 93}
+  \item bottom, \hyperpage{3}, \hyperpage{8--13}, \hyperpage{16}, 
+		\hyperpage{18, 19}, \hyperpage{21, 22}, \hyperpage{24}, 
+		\hyperpage{34, 35}, \hyperpage{38--40}, \hyperpage{53}, 
+		\hyperpage{55, 56}, \hyperpage{58}, \hyperpage{66, 67}, 
+		\hyperpage{69}, \hyperpage{79, 80}, \hyperpage{85, 86}, 
+		\hyperpage{92}, \hyperpage{94}
   \item BOUND SHAPE, \hyperpage{41}
   \item boundary, \hyperpage{1}, \hyperpage{3}, \hyperpage{6--14}, 
 		\hyperpage{22}, \hyperpage{26}, \hyperpage{28}, 
-		\hyperpage{30}, \hyperpage{32}, \hyperpage{42--44}, 
-		\hyperpage{46--51}, \hyperpage{53}, \hyperpage{61}, 
-		\hyperpage{66}, \hyperpage{70--72}, \hyperpage{82, 83}, 
-		\hyperpage{86}
+		\hyperpage{30}, \hyperpage{32}, \hyperpage{42--51}, 
+		\hyperpage{53}, \hyperpage{61}, \hyperpage{66}, 
+		\hyperpage{70--72}, \hyperpage{83, 84}, \hyperpage{87}
   \item BOUNDNEST1, \hyperpage{46}
   \item BOUNDNEST2, \hyperpage{47}
   \item BOUNDNEST3, \hyperpage{49}
   \item BOUNDSPEC, \hyperpage{42}
-  \item BREAKING, \hyperpage{54}
-  \item breaking, \hyperpage{11}, \hyperpage{16, 17}, \hyperpage{22}, 
-		\hyperpage{53}, \hyperpage{55, 56}, \hyperpage{61}, 
-		\hyperpage{78}, \hyperpage{84, 85}, \hyperpage{92}
+  \item BREAKING, \hyperpage{55}
+  \item breaking, \hyperpage{11}, \hyperpage{16--18}, \hyperpage{22}, 
+		\hyperpage{53}, \hyperpage{55--57}, \hyperpage{61}, 
+		\hyperpage{79}, \hyperpage{85, 86}, \hyperpage{92}
 
   \indexspace
 
   \item Cartesian, \hyperpage{3}, \hyperpage{7, 8}, \hyperpage{21}, 
-		\hyperpage{26, 27}, \hyperpage{29}, \hyperpage{35, 36}, 
-		\hyperpage{41}, \hyperpage{44, 45}, \hyperpage{48--51}, 
-		\hyperpage{59}, \hyperpage{66--70}, \hyperpage{73}, 
-		\hyperpage{77, 78}, \hyperpage{84}, \hyperpage{90}, 
-		\hyperpage{94}, \hyperpage{106}, \hyperpage{108, 109}
+		\hyperpage{26, 27}, \hyperpage{29}, \hyperpage{36}, 
+		\hyperpage{41}, \hyperpage{44}, \hyperpage{46}, 
+		\hyperpage{48--51}, \hyperpage{59}, \hyperpage{67--71}, 
+		\hyperpage{73, 74}, \hyperpage{78}, \hyperpage{85}, 
+		\hyperpage{90}, \hyperpage{94}, \hyperpage{106}, 
+		\hyperpage{108, 109}
   \item CGRID, \hyperpage{28}
   \item co-ordinate, \hyperpage{32}
   \item coastal, \hyperpage{3--5}, \hyperpage{15}
-  \item COMPUTE, \hyperpage{85}
-  \item convergence, \hyperpage{6}, \hyperpage{63}
+  \item COMPUTE, \hyperpage{86}
+  \item convergence, \hyperpage{6, 7}, \hyperpage{63}
   \item COORDINATES, \hyperpage{27}
   \item Courant, \hyperpage{14}
-  \item current, \hyperpage{3, 4}, \hyperpage{6}, \hyperpage{9--11}, 
-		\hyperpage{13, 14}, \hyperpage{16}, \hyperpage{19--21}, 
+  \item current, \hyperpage{3}, \hyperpage{5, 6}, \hyperpage{9--12}, 
+		\hyperpage{14}, \hyperpage{16}, \hyperpage{19--21}, 
 		\hyperpage{26}, \hyperpage{32}, \hyperpage{34, 35}, 
 		\hyperpage{38}, \hyperpage{45}, \hyperpage{52}, 
-		\hyperpage{64, 65}, \hyperpage{67}, \hyperpage{78}, 
-		\hyperpage{82}, \hyperpage{90}
+		\hyperpage{64, 65}, \hyperpage{67}, \hyperpage{79}, 
+		\hyperpage{83}, \hyperpage{90}
   \item CURVE, \hyperpage{68}
   \item curvi-linear, \hyperpage{3}, \hyperpage{6}, \hyperpage{8, 9}, 
-		\hyperpage{13, 14}, \hyperpage{16}, \hyperpage{21, 22}, 
+		\hyperpage{12--14}, \hyperpage{16}, \hyperpage{21, 22}, 
 		\hyperpage{28, 29}, \hyperpage{32}, \hyperpage{34, 35}, 
-		\hyperpage{38}, \hyperpage{43}, \hyperpage{47, 48}, 
+		\hyperpage{38, 39}, \hyperpage{43}, \hyperpage{47, 48}, 
 		\hyperpage{50}, \hyperpage{62}, \hyperpage{65}, 
 		\hyperpage{67}
 
@@ -5098,56 +5166,54 @@
 
   \item dam, \hyperpage{4}, \hyperpage{7}, \hyperpage{98}
   \item DIFFRACTION, \hyperpage{60}
-  \item diffraction, \hyperpage{5}, \hyperpage{22}, \hyperpage{60}, 
+  \item diffraction, \hyperpage{5}, \hyperpage{22}, \hyperpage{60, 61}, 
 		\hyperpage{64}
-  \item diffusion, \hyperpage{62}, \hyperpage{64}
+  \item diffusion, \hyperpage{62}, \hyperpage{64, 65}
   \item dissipation, \hyperpage{22}, \hyperpage{52, 53}, \hyperpage{55}, 
-		\hyperpage{61}, \hyperpage{78}, \hyperpage{92}
+		\hyperpage{61}, \hyperpage{79}, \hyperpage{92}
 
   \indexspace
 
   \item filter, \hyperpage{13, 14}, \hyperpage{60}
   \item flow, \hyperpage{6}, \hyperpage{30, 31}, \hyperpage{34}, 
-		\hyperpage{36}, \hyperpage{64}
-  \item force, \hyperpage{78}, \hyperpage{93}
+		\hyperpage{36, 37}, \hyperpage{64}
+  \item force, \hyperpage{80}, \hyperpage{93}
   \item FRAME, \hyperpage{66}
   \item frequency, \hyperpage{4}, \hyperpage{6}, \hyperpage{8}, 
 		\hyperpage{14, 15}, \hyperpage{26}, \hyperpage{30, 31}, 
 		\hyperpage{42}, \hyperpage{45}, \hyperpage{51, 52}, 
 		\hyperpage{54}, \hyperpage{56}, \hyperpage{61}, 
-		\hyperpage{64}, \hyperpage{66}, \hyperpage{71}, 
-		\hyperpage{73, 74}, \hyperpage{78}, \hyperpage{82}, 
-		\hyperpage{84, 85}, \hyperpage{89}, \hyperpage{91}, 
-		\hyperpage{108, 109}
+		\hyperpage{64--66}, \hyperpage{72--74}, \hyperpage{78}, 
+		\hyperpage{83}, \hyperpage{85, 86}, \hyperpage{89}, 
+		\hyperpage{91}, \hyperpage{108, 109}
   \item FRICTION, \hyperpage{55}
-  \item friction, \hyperpage{9--11}, \hyperpage{13}, \hyperpage{16, 17}, 
-		\hyperpage{19}, \hyperpage{21, 22}, \hyperpage{24}, 
-		\hyperpage{34, 35}, \hyperpage{38}, \hyperpage{53}, 
-		\hyperpage{55, 56}, \hyperpage{78, 79}, 
-		\hyperpage{84, 85}, \hyperpage{92}
+  \item friction, \hyperpage{9--12}, \hyperpage{16--19}, 
+		\hyperpage{21, 22}, \hyperpage{24}, \hyperpage{34, 35}, 
+		\hyperpage{38}, \hyperpage{53}, \hyperpage{55, 56}, 
+		\hyperpage{79, 80}, \hyperpage{85, 86}, \hyperpage{92}
   \item Froude, \hyperpage{26}, \hyperpage{38}
 
   \indexspace
 
   \item garden-sprinkler, \hyperpage{62}
-  \item GEN1, \hyperpage{51}
+  \item GEN1, \hyperpage{52}
   \item GEN2, \hyperpage{52}
-  \item GEN3, \hyperpage{52}
+  \item GEN3, \hyperpage{53}
   \item GROUP, \hyperpage{67}
 
   \indexspace
 
   \item harbour, \hyperpage{5}, \hyperpage{60}
-  \item HOTFILE, \hyperpage{86}
+  \item HOTFILE, \hyperpage{87}
 
   \indexspace
 
   \item INITIAL, \hyperpage{50}
   \item initial, \hyperpage{8}, \hyperpage{10, 11}, \hyperpage{14}, 
-		\hyperpage{22}, \hyperpage{41}, \hyperpage{50, 51}, 
-		\hyperpage{85, 86}
+		\hyperpage{22}, \hyperpage{41}, \hyperpage{51}, 
+		\hyperpage{87}
   \item INPGRID, \hyperpage{33}
-  \item island, \hyperpage{4, 5}, \hyperpage{11}
+  \item island, \hyperpage{4}, \hyperpage{6}, \hyperpage{11}
   \item ISOLINE, \hyperpage{69}
 
   \indexspace
@@ -5156,13 +5222,13 @@
 
   \indexspace
 
-  \item latitude, \hyperpage{8}, \hyperpage{27}, \hyperpage{84}, 
+  \item latitude, \hyperpage{8}, \hyperpage{27}, \hyperpage{85}, 
 		\hyperpage{108}
   \item LIMITER, \hyperpage{56}
   \item limiter, \hyperpage{5}, \hyperpage{7}, \hyperpage{56}, 
 		\hyperpage{64}
-  \item longitude, \hyperpage{8}, \hyperpage{27}, \hyperpage{48--50}, 
-		\hyperpage{84}, \hyperpage{108}
+  \item longitude, \hyperpage{8}, \hyperpage{27}, \hyperpage{49, 50}, 
+		\hyperpage{85}, \hyperpage{108}
 
   \indexspace
 
@@ -5171,7 +5237,7 @@
   \indexspace
 
   \item nautical, \hyperpage{7, 8}, \hyperpage{108, 109}
-  \item NESTOUT, \hyperpage{82}
+  \item NESTOUT, \hyperpage{83}
   \item NGRID, \hyperpage{70}
   \item NUMERIC, \hyperpage{62}
 
@@ -5181,7 +5247,7 @@
   \item obstacle, \hyperpage{5}, \hyperpage{16}, \hyperpage{22}, 
 		\hyperpage{57--60}
   \item ocean, \hyperpage{4--6}, \hyperpage{28}
-  \item OFF, \hyperpage{60}
+  \item OFF, \hyperpage{61}
   \item OUTPUT, \hyperpage{74}
 
   \indexspace
@@ -5190,13 +5256,14 @@
   \item PROJECT, \hyperpage{24}
   \item PROP, \hyperpage{61}
   \item propagation, \hyperpage{6}, \hyperpage{12}, \hyperpage{22}, 
-		\hyperpage{57}, \hyperpage{60}, \hyperpage{62}
+		\hyperpage{57}, \hyperpage{61, 62}, \hyperpage{79}, 
+		\hyperpage{92}
 
   \indexspace
 
   \item QUADRUPL, \hyperpage{54}
   \item quadruplets, \hyperpage{15, 16}, \hyperpage{22}, \hyperpage{54}, 
-		\hyperpage{56}
+		\hyperpage{56}, \hyperpage{79}, \hyperpage{92}
   \item QUANTITY, \hyperpage{72}
 
   \indexspace
@@ -5208,78 +5275,80 @@
   \item recti-linear, \hyperpage{3}, \hyperpage{16}, \hyperpage{28, 29}, 
 		\hyperpage{38}, \hyperpage{67}
   \item reflection, \hyperpage{57--59}
-  \item refraction, \hyperpage{5, 6}, \hyperpage{11}, \hyperpage{61}, 
-		\hyperpage{64}, \hyperpage{68}
-  \item regular, \hyperpage{4}, \hyperpage{8, 9}, \hyperpage{13}, 
+  \item refraction, \hyperpage{6}, \hyperpage{11}, \hyperpage{61}, 
+		\hyperpage{64}, \hyperpage{69}
+  \item regular, \hyperpage{4}, \hyperpage{8, 9}, \hyperpage{12}, 
 		\hyperpage{16}, \hyperpage{22}, \hyperpage{28, 29}, 
-		\hyperpage{31, 32}, \hyperpage{34}, \hyperpage{65, 66}
+		\hyperpage{31, 32}, \hyperpage{34, 35}, 
+		\hyperpage{65, 66}
 
   \indexspace
 
   \item SET, \hyperpage{25}
   \item set-up, \hyperpage{4}, \hyperpage{6}, \hyperpage{16, 17}, 
-		\hyperpage{22}, \hyperpage{28}, \hyperpage{59}, 
-		\hyperpage{64, 65}
+		\hyperpage{22}, \hyperpage{28}, \hyperpage{59, 60}, 
+		\hyperpage{65}
   \item SETUP, \hyperpage{59}
   \item shoaling, \hyperpage{18}
   \item SORDUP, \hyperpage{62}
-  \item SPECOUT, \hyperpage{81}
+  \item SPECOUT, \hyperpage{82}
   \item specular, \hyperpage{59}
-  \item spherical, \hyperpage{3--5}, \hyperpage{7--9}, \hyperpage{21}, 
+  \item spherical, \hyperpage{3--5}, \hyperpage{8, 9}, \hyperpage{21}, 
 		\hyperpage{25}, \hyperpage{27--29}, \hyperpage{31}, 
-		\hyperpage{35, 36}, \hyperpage{45}, \hyperpage{48--50}, 
-		\hyperpage{59}, \hyperpage{66--70}, \hyperpage{79}, 
-		\hyperpage{84}, \hyperpage{103}, \hyperpage{108}
+		\hyperpage{36}, \hyperpage{45}, \hyperpage{48--50}, 
+		\hyperpage{59}, \hyperpage{67--71}, \hyperpage{80}, 
+		\hyperpage{85}, \hyperpage{103}, \hyperpage{108}
   \item stability, \hyperpage{14}, \hyperpage{62}
   \item stationary, \hyperpage{4}, \hyperpage{6}, \hyperpage{8}, 
 		\hyperpage{14}, \hyperpage{16}, \hyperpage{18}, 
 		\hyperpage{20, 21}, \hyperpage{26, 27}, \hyperpage{34}, 
-		\hyperpage{37--39}, \hyperpage{45, 46}, 
-		\hyperpage{50, 51}, \hyperpage{53}, \hyperpage{62--64}, 
-		\hyperpage{79}, \hyperpage{85, 86}, \hyperpage{103}, 
-		\hyperpage{106}, \hyperpage{108, 109}
-  \item steepness, \hyperpage{22}, \hyperpage{53}, \hyperpage{79}, 
-		\hyperpage{92}
-  \item STOP, \hyperpage{87}
+		\hyperpage{37--39}, \hyperpage{45, 46}, \hyperpage{51}, 
+		\hyperpage{53}, \hyperpage{62--64}, \hyperpage{80}, 
+		\hyperpage{86, 87}, \hyperpage{103}, \hyperpage{106}, 
+		\hyperpage{108, 109}
+  \item steepness, \hyperpage{22}, \hyperpage{53}, \hyperpage{80}, 
+		\hyperpage{93}
+  \item STOP, \hyperpage{88}
   \item swell, \hyperpage{12}, \hyperpage{15}, \hyperpage{55}, 
-		\hyperpage{62}, \hyperpage{73, 74}, \hyperpage{77}, 
+		\hyperpage{62}, \hyperpage{73, 74}, \hyperpage{78}, 
 		\hyperpage{89}
 
   \indexspace
 
-  \item TABLE, \hyperpage{80}
-  \item TEST, \hyperpage{83}
+  \item TABLE, \hyperpage{81}
+  \item TEST, \hyperpage{84}
   \item TRIAD, \hyperpage{56}
-  \item triads, \hyperpage{16}, \hyperpage{56}
+  \item triads, \hyperpage{16}, \hyperpage{56}, \hyperpage{79}, 
+		\hyperpage{92}
   \item triangular, \hyperpage{3}, \hyperpage{16}, \hyperpage{71}
 
   \indexspace
 
   \item unstructured, \hyperpage{3, 4}, \hyperpage{8, 9}, 
-		\hyperpage{13}, \hyperpage{21}, \hyperpage{28, 29}, 
+		\hyperpage{12, 13}, \hyperpage{21}, \hyperpage{28, 29}, 
 		\hyperpage{32}, \hyperpage{34, 35}, \hyperpage{44}, 
-		\hyperpage{58}, \hyperpage{62, 63}, \hyperpage{66}, 
-		\hyperpage{71}, \hyperpage{77}
+		\hyperpage{58}, \hyperpage{62--64}, \hyperpage{66}, 
+		\hyperpage{71}, \hyperpage{78}
 
   \indexspace
 
   \item WAM, \hyperpage{4--7}, \hyperpage{9, 10}, \hyperpage{15}, 
 		\hyperpage{18}, \hyperpage{22}, \hyperpage{37}, 
-		\hyperpage{46--50}, \hyperpage{54}, \hyperpage{80--83}, 
-		\hyperpage{86}
+		\hyperpage{46}, \hyperpage{48--50}, \hyperpage{54}, 
+		\hyperpage{81--84}, \hyperpage{87}
   \item WAVEWATCH, \hyperpage{4--7}, \hyperpage{9, 10}, \hyperpage{15}, 
 		\hyperpage{22}, \hyperpage{46}, \hyperpage{49, 50}
   \item WCAPPING, \hyperpage{53}
   \item whitecapping, \hyperpage{7}, \hyperpage{16}, \hyperpage{22}, 
-		\hyperpage{53}, \hyperpage{61}, \hyperpage{78}, 
-		\hyperpage{84, 85}, \hyperpage{92}
+		\hyperpage{53, 54}, \hyperpage{61}, \hyperpage{79}, 
+		\hyperpage{85, 86}, \hyperpage{92}
   \item WIND, \hyperpage{41}
-  \item wind, \hyperpage{3}, \hyperpage{5}, \hyperpage{7--17}, 
-		\hyperpage{19}, \hyperpage{21}, \hyperpage{26}, 
-		\hyperpage{34, 35}, \hyperpage{38}, \hyperpage{41}, 
-		\hyperpage{51--53}, \hyperpage{55}, \hyperpage{61}, 
-		\hyperpage{64, 65}, \hyperpage{78}, \hyperpage{84, 85}, 
-		\hyperpage{94}
+  \item wind, \hyperpage{3}, \hyperpage{5}, \hyperpage{7--12}, 
+		\hyperpage{14--19}, \hyperpage{21}, \hyperpage{26}, 
+		\hyperpage{34, 35}, \hyperpage{39}, \hyperpage{41}, 
+		\hyperpage{51--53}, \hyperpage{55}, \hyperpage{61, 62}, 
+		\hyperpage{64, 65}, \hyperpage{79}, \hyperpage{85, 86}, 
+		\hyperpage{92}, \hyperpage{94}
 
 \end{theindex}
 
--- swmod1.ftn	2008-05-25 14:59:50.000000000 +0200
+++ swmod1.ftn	2008-10-15 11:57:48.000000000 +0200
@@ -591,6 +591,8 @@
 !     40.61, Sep. 06: NMOVAR increased by 3 (quantities DISBOT,
 !                     DISSRF and DISWCP added)
 !     40.64, Apr. 07: NMOVAR increased by 2 (quantities QP and BFI added)
+!     40.85, Aug. 08: NMOVAR increased by 10 (quantities GENE, GENW, REDI, REDQ, REDT,
+!                                             PROPA, PROPX, PROPT, PROPS and RADS added)
 !
 !  2. Purpose
 !
@@ -612,11 +614,11 @@
 !
 !  6. Parameter variables
 !
-!     NMOVAR [  59]  maximum number of output variables                   40.64 40.61 40.51 40.21 40.41
+!     NMOVAR [  69]  maximum number of output variables                   40.85 40.64 40.61 40.51 40.21 40.41
 !     MOUTPA [  50]  number of output parameters                          40.87
 !
       INTEGER NMOVAR, MOUTPA
-      PARAMETER (NMOVAR = 59, MOUTPA=50)                                  40.87 40.64 40.61 40.51 40.21 40.41
+      PARAMETER (NMOVAR = 69, MOUTPA=50)                                  40.85 40.87 40.64 40.61 40.51 40.21 40.41
 !
 !  7. Local variables
 !
@@ -678,6 +680,16 @@
 !  (56) [  'DISW']
 !  (58) [    'QP']
 !  (59) [   'BFI']
+!  (60) [  'GENE']
+!  (61) [  'GENW']
+!  (62) [  'REDI']
+!  (63) [  'REDQ']
+!  (64) [  'REDT']
+!  (65) [ 'PROPA']
+!  (66) [ 'PROPX']
+!  (67) [ 'PROPT']
+!  (68) [ 'PROPS']
+!  (69) [  'RADS']
 ! OVSNAM(NMOVAR)   short name of output quantity
 !  ( 1) [    'Xp']
 !  ( 2) [    'Yp']
@@ -727,11 +739,21 @@
 !  (51) ['Watlev']
 !  (52) ['Botlev']
 !  (53) ['TPsmoo']
-!  (54) ['Disbot']
-!  (55) ['Dissrf']
-!  (56) ['Diswcp']
+!  (54) [ 'Sfric']
+!  (55) [ 'Ssurf']
+!  (56) [ 'Swcap']
 !  (58) [    'Qp']
 !  (59) [   'BFI']
+!  (60) ['Genera']
+!  (61) [ 'Swind']
+!  (62) ['Redist']
+!  (63) [  'Snl4']
+!  (64) [  'Snl3']
+!  (65) ['Propag']
+!  (66) ['Propxy']
+!  (67) ['Propth']
+!  (68) ['Propsi']
+!  (69) ['Radstr']
 ! OVLNAM(NMOVAR)   long name of output quantity
 !  ( 1) [                        'X user coordinate']
 !  ( 2) [                        'Y user coordinate']
@@ -782,10 +804,20 @@
 !  (52) [                             'Bottom level']
 !  (53) [            'Relative peak period (smooth)']
 !  (54) [              'Bottom friction dissipation']
-!  (55) [                'Wave breaking dissipation']
+!  (55) [                'Surf breaking dissipation']
 !  (56) [                 'Whitecapping dissipation']
 !  (58) [                               'Peakedness']
 !  (59) [                      'Benjamin-Feir index']
+!  (60) [                        'Energy generation']
+!  (61) [                         'Wind source term']
+!  (62) [                    'Energy redistribution']
+!  (63) [        'Total absolute 4-wave interaction']
+!  (64) [        'Total absolute 3-wave interaction']
+!  (65) [                       'Energy propagation']
+!  (66) [                           'xy-propagation']
+!  (67) [                        'theta-propagation']
+!  (68) [                        'sigma-propagation']
+!  (69) [                         'Radiation stress']
 ! OVUNIT(NMOVAR)   unit of of output quantity
 !  ( 1) [CALCULAT] =UL
 !  ( 2) [CALCULAT] =UL
@@ -840,6 +872,16 @@
 !  (56) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
 !  (58) [     ' ']
 !  (59) [     ' ']
+!  (60) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (61) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (62) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (63) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (64) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (65) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (66) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (67) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (68) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
+!  (69) [  'm2/s'] change to UDL ???, changed to 'W/m2', if INRHOG=1
 ! SNAME [        ] name of output point set
 ! UAP   [  'W/m2'] unit of dissipation
 ! UD    [        ] not used
@@ -934,11 +976,21 @@
 !  (51)  [  1]   Watlev
 !  (52)  [  1]   Botlev
 !  (53)  [  1]   TPSmoo
-!  (54)  [  1]   Disbot
-!  (55)  [  1]   Dissrf
-!  (56)  [  1]   Diswcp
+!  (54)  [  1]   Sfric
+!  (55)  [  1]   Ssurf
+!  (56)  [  1]   Swcap
 !  (58)  [  1]   Qp
 !  (59)  [  1]   BFI
+!  (60)  [  1]   Genera
+!  (61)  [  1]   Swind
+!  (62)  [  1]   Redist
+!  (63)  [  1]   Snl4
+!  (64)  [  1]   Snl3
+!  (65)  [  1]   Propag
+!  (66)  [  1]   Propxy
+!  (67)  [  1]   Propth
+!  (68)  [  1]   Propsi
+!  (69)  [  1]   Radstr
 ! OVEXCV(NMOVAR)   exception value for output quantity
 !  ( 1)  [ -1.E10] Xp
 !  ( 2)  [ -1.E10] Yp
@@ -986,11 +1038,21 @@
 !  (51)  [   -99.] Watlev
 !  (52)  [   -99.] Botlev
 !  (53)  [   -10.] TPSmoo
-!  (54)  [   -10.] Disbot
-!  (55)  [   -10.] Dissrf
-!  (56)  [   -10.] Diswcp
+!  (54)  [    -9.] Sfric
+!  (55)  [    -9.] Ssurf
+!  (56)  [    -9.] Swcap
 !  (58)  [    -9.] Qp
 !  (59)  [    -9.] BFI
+!  (60)  [    -9.] Genera
+!  (61)  [    -9.] Swind
+!  (62)  [    -9.] Redist
+!  (63)  [    -9.] Snl4
+!  (64)  [    -9.] Snl3
+!  (65)  [    -9.] Propag
+!  (66)  [    -9.] Propxy
+!  (67)  [    -9.] Propth
+!  (68)  [    -9.] Propsi
+!  (69)  [    -9.] Radstr
 ! OVLEXP(NMOVAR)   lower expected limit of output quantity
 !  ( 1)  [ -1.E10] Xp
 !  ( 2)  [ -1.E10] Yp
@@ -1038,11 +1100,21 @@
 !  (51)  [  -100.] Watlev
 !  (52)  [  -100.] Botlev
 !  (53)  [     0.] TPSmoo
-!  (54)  [     0.] Disbot
-!  (55)  [     0.] Dissrf
-!  (56)  [     0.] Diswcp
+!  (54)  [     0.] Sfric
+!  (55)  [     0.] Ssurf
+!  (56)  [     0.] Swcap
 !  (58)  [     0.] Qp
 !  (59)  [     0.] BFI
+!  (60)  [     0.] Genera
+!  (61)  [     0.] Swind
+!  (62)  [     0.] Redist
+!  (63)  [     0.] Snl4
+!  (64)  [     0.] Snl3
+!  (65)  [     0.] Propag
+!  (66)  [     0.] Propxy
+!  (67)  [     0.] Propth
+!  (68)  [     0.] Propsi
+!  (69)  [     0.] Radstr
 ! OVLLIM(NMOVAR)   lower limit of validity of output quantity
 !  ( 1)  [ -1.E10] Xp
 !  ( 2)  [ -1.E10] Yp
@@ -1090,11 +1162,21 @@
 !  (51)  [  -1.E4] Watlev
 !  (52)  [  -1.E4] Botlev
 !  (53)  [     0.] TPSmoo
-!  (54)  [     0.] Disbot
-!  (55)  [     0.] Dissrf
-!  (56)  [     0.] Diswcp
+!  (54)  [     0.] Sfric
+!  (55)  [     0.] Ssurf
+!  (56)  [     0.] Swcap
 !  (58)  [     0.] Qp
 !  (59)  [     0.] BFI
+!  (60)  [     0.] Genera
+!  (61)  [     0.] Swind
+!  (62)  [     0.] Redist
+!  (63)  [     0.] Snl4
+!  (64)  [     0.] Snl3
+!  (65)  [     0.] Propag
+!  (66)  [     0.] Propxy
+!  (67)  [     0.] Propth
+!  (68)  [     0.] Propsi
+!  (69)  [     0.] Radstr
 ! OVHEXP(NMOVAR)   upper expected limit of output quantity
 !  ( 1)  [  1.E10] Xp
 !  ( 2)  [  1.E10] Yp
@@ -1142,11 +1224,21 @@
 !  (51)  [   100.] Watlev
 !  (52)  [   100.] Botlev
 !  (53)  [   100.] TPSmoo
-!  (54)  [   100.] Disbot
-!  (55)  [   100.] Dissrf
-!  (56)  [   100.] Diswcp
+!  (54)  [    0.1] Sfric
+!  (55)  [    0.1] Ssurf
+!  (56)  [    0.1] Swcap
 !  (58)  [     1.] Qp
 !  (59)  [  1000.] BFI
+!  (60)  [    0.1] Genera
+!  (61)  [    0.1] Swind
+!  (62)  [    0.1] Redist
+!  (63)  [    0.1] Snl4
+!  (64)  [    0.1] Snl3
+!  (65)  [    0.1] Propag
+!  (66)  [    0.1] Propxy
+!  (67)  [    0.1] Propth
+!  (68)  [    0.1] Propsi
+!  (69)  [    0.1] Radstr
 ! OVULIM(NMOVAR)   upper limit of validity
 !  ( 1)  [  1.E10] Xp
 !  ( 2)  [  1.E10] Yp
@@ -1194,11 +1286,21 @@
 !  (51)  [   1.E4] Watlev
 !  (52)  [   1.E4] Botlev
 !  (53)  [  1000.] TPSmoo
-!  (54)  [  1000.] Disbot
-!  (55)  [  1000.] Dissrf
-!  (56)  [  1000.] Diswcp
+!  (54)  [  1000.] Sfric
+!  (55)  [  1000.] Ssurf
+!  (56)  [  1000.] Swcap
 !  (58)  [     1.] Qp
 !  (59)  [  1000.] BFI
+!  (60)  [  1000.] Genera
+!  (61)  [  1000.] Swind
+!  (62)  [  1000.] Redist
+!  (63)  [  1000.] Snl4
+!  (64)  [  1000.] Snl3
+!  (65)  [  1000.] Propag
+!  (66)  [  1000.] Propxy
+!  (67)  [  1000.] Propth
+!  (68)  [  1000.] Propsi
+!  (69)  [  1000.] Radstr
 ! SINCQ  [       ] sin of ALCQ
 ! SINPQ  [       ] sin of ALPQ
 ! SPCPOW [      1] power in expression for computation of average frequency
@@ -1504,13 +1606,16 @@
 !     MBOT   [  10] dimension of array PBOT
 !     MDIFFR [  10] dimension of array PDIFFR                             40.21
 !     MDISP  [   3] dimension for dissipation arrays                      40.67
+!     MGENR  [   1] dimension for generation arrays                       40.85
 !     MICMAX [  10] max. number of points in comput. stencil
 !     MNUMS  [  30] dimension of array PNUMS
 !     MQUAD  [  10] dimension of array PQUAD
+!     MREDS  [   2] dimension for redistribution arrays                   40.85
 !     MSETUP [   2] dimension of array PSETUP
 !     MSHAPE [   5] dimension of array PSHAPE
 !     MSPPAR [   5] dimension of array SPPARM
 !     MSURF  [  10] dimension of array PSURF
+!     MTRNP  [   3] dimension for propagation arrays                      40.85
 !     MTRIAD [  10] dimension of array PTRIAD
 !     MWCAP  [  15] dimension of array PWCAP
 !     MWIND  [  40] dimension of array PWIND
@@ -1521,10 +1626,14 @@
       INTEGER             MICMAX
       INTEGER             MDIFFR                                          40.21
       INTEGER             MDISP                                           40.67
+      INTEGER             MGENR, MREDS, MTRNP                             40.85
 !
       PARAMETER           (MBOT   = 10)
       PARAMETER           (MDIFFR = 10)                                   40.21
       PARAMETER           (MDISP  =  3)                                   40.67
+      PARAMETER           (MGENR  =  1)                                   40.85
+      PARAMETER           (MREDS  =  2)                                   40.85
+      PARAMETER           (MTRNP  =  3)                                   40.85
       PARAMETER           (MICMAX = 10)
       PARAMETER           (MNUMS  = 30)
       PARAMETER           (MQUAD  = 10)
@@ -1553,7 +1662,7 @@
 !              (difference in Hs between last two iterations)
 ! JDIS0  [  7] within array SWMATR
 ! JDIS1  [  7+MDISP] within array SWMATR
-! JDISS  [  2] dissipation within array COMPDA
+! JDISS  [  2] total dissipation within array COMPDA
 ! JDPSAV [  1] saved depth (for setup) within array COMPDA
 ! JDP1   [  7] old depth within array COMPDA
 ! JDP2   [  8] new depth within array COMPDA
@@ -1570,6 +1679,12 @@
 !              set by command READ FR ...
 ! JFRC3  [  1] friction coefficient within array COMPDA
 !              set by command READ FR ...
+! JGEN0  [   ] within array SWMATR
+! JGEN1  [   ] within array SWMATR
+! JGENR  [  1] total generation within array COMPDA
+!              set by command TABLE/BLOCK
+! JGSXW  [  1] wind input within array COMPDA
+!              set by command TABLE/BLOCK
 ! JHS    [  1] significant wave height Hs within array COMPDA
 ! JHSIBC [ 25] significant wave height from boundary condition in array COMPDA
 ! JLEAK  [ 21] "leak" within array COMPDA
@@ -1592,10 +1707,30 @@
 ! JPWNDA [  1] within array SWTSDA, wind source term part A
 ! JPWNDB [  2] within array SWTSDA, wind source term part B
 ! JQB    [  4] fraction of breaking waves within array COMPDA
+! JRADS  [  1] radiation stress within array COMPDA
+!              set by command TABLE/BLOCK
+! JRED0  [   ] within array SWMATR
+! JRED1  [   ] within array SWMATR
+! JREDS  [  1] total redistribution within array COMPDA
+!              set by command TABLE/BLOCK
+! JRSXQ  [  1] quadruplets within array COMPDA
+!              set by command TABLE/BLOCK
+! JRSXT  [  1] triads within array COMPDA
+!              set by command TABLE/BLOCK
 ! JSETUP [  1] setup values within array COMPDA
 ! JSTP   [  5] steepness within array COMPDA
 ! JTAUW  [  1] TauW within array COMPDA,
 !              set by command WCAP JANS ...
+! JTRA0  [   ] within array SWMATR
+! JTRA1  [   ] within array SWMATR
+! JTRAN  [  1] total propagation within array COMPDA
+!              set by command TABLE/BLOCK
+! JTSXG  [  1] xy-propagation within array COMPDA
+!              set by command TABLE/BLOCK
+! JTSXT  [  1] theta-propagation within array COMPDA
+!              set by command TABLE/BLOCK
+! JTSXS  [  1] sigma-propagation within array COMPDA
+!              set by command TABLE/BLOCK
 ! JUBOT  [  3] bottom orbital velocity within array COMPDA
 ! JURSEL [ 27] Ursell number as used in Triad computation
 ! JUSTAR [  1] friction velocity within array COMPDA,
@@ -1624,6 +1759,16 @@
 !              =MCMVAR+1, for command TABLE/BLOCK DISB (add JDSXB)
 !              =MCMVAR+1, for command TABLE/BLOCK DISSU (add JDSXS)
 !              =MCMVAR+1, for command TABLE/BLOCK DISW (add JDSXW)
+!              =MCMVAR+1, for command TABLE/BLOCK GENE (add JGENR)
+!              =MCMVAR+1, for command TABLE/BLOCK GENW (add JGSXW)
+!              =MCMVAR+1, for command TABLE/BLOCK REDI (add JREDS)
+!              =MCMVAR+1, for command TABLE/BLOCK REDQ (add JRSXQ)
+!              =MCMVAR+1, for command TABLE/BLOCK REDT (add JRSXT)
+!              =MCMVAR+1, for command TABLE/BLOCK PROPA (add JTRAN)
+!              =MCMVAR+1, for command TABLE/BLOCK PROPX (add JTSXG)
+!              =MCMVAR+1, for command TABLE/BLOCK PROPT (add JTSXT)
+!              =MCMVAR+1, for command TABLE/BLOCK PROPS (add JTSXS)
+!              =MCMVAR+1, for command TABLE/BLOCK RADST (add JRADS)
 ! MLSWMAT [  2] within array LSWMAT
 ! MSWMATR [ 13] within array SWMATR
 ! MTSVAR [  8] within array TESTDA
@@ -1634,9 +1779,14 @@
       INTEGER             JDIS1,       JDISS,       JDPSAV,      JDP1
       INTEGER             JDP2
       INTEGER             JDP3,        JDTM,        JFRC2,       JFRC3
+      INTEGER             JGEN0,       JGEN1,       JRED0,       JRED1
+      INTEGER             JTRA0,       JTRA1
       INTEGER             JDSXB
       INTEGER             JDSXS
       INTEGER             JDSXW
+      INTEGER             JGSXW,       JGENR
+      INTEGER             JRSXQ,       JRSXT,       JREDS,       JRADS
+      INTEGER             JTSXG,       JTSXT,       JTSXS,       JTRAN
       INTEGER             JHS,         JHSIBC,      JLEAK
       INTEGER             JLEK1,       JMAT5,       JMAT6,       JMATD
       INTEGER             JMATL,       JMATR,       JMATU
--- triangul.eps	1970-01-01 01:00:00.000000000 +0100
+++ triangul.eps	2008-10-15 11:57:40.000000000 +0200
@@ -0,0 +1,221 @@
+%!PS-Adobe-2.0 EPSF-2.0
+%%Title: triangul.fig
+%%Creator: fig2dev Version 3.2 Patchlevel 4
+%%CreationDate: Thu Aug  7 11:19:02 2008
+%%For: marcel@linux-7i9b (marcel zijlema)
+%%BoundingBox: 0 0 422 439
+%%Magnification: 1.0000
+%%EndComments
+/$F2psDict 200 dict def
+$F2psDict begin
+$F2psDict /mtrx matrix put
+/col-1 {0 setgray} bind def
+/col0 {0.000 0.000 0.000 srgb} bind def
+/col1 {0.000 0.000 1.000 srgb} bind def
+/col2 {0.000 1.000 0.000 srgb} bind def
+/col3 {0.000 1.000 1.000 srgb} bind def
+/col4 {1.000 0.000 0.000 srgb} bind def
+/col5 {1.000 0.000 1.000 srgb} bind def
+/col6 {1.000 1.000 0.000 srgb} bind def
+/col7 {1.000 1.000 1.000 srgb} bind def
+/col8 {0.000 0.000 0.560 srgb} bind def
+/col9 {0.000 0.000 0.690 srgb} bind def
+/col10 {0.000 0.000 0.820 srgb} bind def
+/col11 {0.530 0.810 1.000 srgb} bind def
+/col12 {0.000 0.560 0.000 srgb} bind def
+/col13 {0.000 0.690 0.000 srgb} bind def
+/col14 {0.000 0.820 0.000 srgb} bind def
+/col15 {0.000 0.560 0.560 srgb} bind def
+/col16 {0.000 0.690 0.690 srgb} bind def
+/col17 {0.000 0.820 0.820 srgb} bind def
+/col18 {0.560 0.000 0.000 srgb} bind def
+/col19 {0.690 0.000 0.000 srgb} bind def
+/col20 {0.820 0.000 0.000 srgb} bind def
+/col21 {0.560 0.000 0.560 srgb} bind def
+/col22 {0.690 0.000 0.690 srgb} bind def
+/col23 {0.820 0.000 0.820 srgb} bind def
+/col24 {0.500 0.190 0.000 srgb} bind def
+/col25 {0.630 0.250 0.000 srgb} bind def
+/col26 {0.750 0.380 0.000 srgb} bind def
+/col27 {1.000 0.500 0.500 srgb} bind def
+/col28 {1.000 0.630 0.630 srgb} bind def
+/col29 {1.000 0.750 0.750 srgb} bind def
+/col30 {1.000 0.880 0.880 srgb} bind def
+/col31 {1.000 0.840 0.000 srgb} bind def
+
+end
+save
+newpath 0 439 moveto 0 0 lineto 422 0 lineto 422 439 lineto closepath clip newpath
+-146.6 519.7 translate
+1 -1 scale
+
+/cp {closepath} bind def
+/ef {eofill} bind def
+/gr {grestore} bind def
+/gs {gsave} bind def
+/sa {save} bind def
+/rs {restore} bind def
+/l {lineto} bind def
+/m {moveto} bind def
+/rm {rmoveto} bind def
+/n {newpath} bind def
+/s {stroke} bind def
+/sh {show} bind def
+/slc {setlinecap} bind def
+/slj {setlinejoin} bind def
+/slw {setlinewidth} bind def
+/srgb {setrgbcolor} bind def
+/rot {rotate} bind def
+/sc {scale} bind def
+/sd {setdash} bind def
+/ff {findfont} bind def
+/sf {setfont} bind def
+/scf {scalefont} bind def
+/sw {stringwidth} bind def
+/tr {translate} bind def
+/tnt {dup dup currentrgbcolor
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add
+  4 -2 roll dup 1 exch sub 3 -1 roll mul add srgb}
+  bind def
+/shd {dup dup currentrgbcolor 4 -2 roll mul 4 -2 roll mul
+  4 -2 roll mul srgb} bind def
+ /DrawEllipse {
+	/endangle exch def
+	/startangle exch def
+	/yrad exch def
+	/xrad exch def
+	/y exch def
+	/x exch def
+	/savematrix mtrx currentmatrix def
+	x y tr xrad yrad sc 0 0 1 startangle endangle arc
+	closepath
+	savematrix setmatrix
+	} def
+
+/$F2psBegin {$F2psDict begin /$F2psEnteredState save def} def
+/$F2psEnd {$F2psEnteredState restore end} def
+
+$F2psBegin
+10 setmiterlimit
+0 slj 0 slc
+ 0.06299 0.06299 sc
+%
+% Fig objects follow
+%
+% 
+% here starts figure with depth 50
+% Ellipse
+7.500 slw
+n 6135 4590 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 7350 6255 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 4419 6560 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 2817 4771 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 8505 3600 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 6960 1575 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Ellipse
+n 4155 2385 95 95 0 360 DrawEllipse gs 0.00 setgray ef gr gs col0 s gr
+
+% Polyline
+n 6135 4590 m 4395 6540 l 2820 4740 l 6135 4575 l 4155 2400 l 6990 1575 l
+ 6120 4605 l 8505 3600 l 7365 6255 l
+ 6120 4590 l gs col0 s gr 
+% Polyline
+n 7380 6255 m
+ 4395 6540 l gs col0 s gr 
+% Polyline
+n 2835 4740 m
+ 4155 2400 l gs col0 s gr 
+% Polyline
+n 7005 1605 m
+ 8475 3585 l gs col0 s gr 
+% Polyline
+n 4185 2400 m
+ 3885 2010 l gs col0 s gr 
+% Polyline
+n 4170 2400 m
+ 3555 2340 l gs col0 s gr 
+% Polyline
+n 4185 2415 m
+ 4500 1890 l gs col0 s gr 
+% Polyline
+n 7020 1590 m
+ 7665 1710 l gs col0 s gr 
+% Polyline
+n 6990 1590 m
+ 7410 1395 l gs col0 s gr 
+% Polyline
+n 7005 1605 m
+ 6660 1305 l gs col0 s gr 
+% Polyline
+n 8520 3615 m
+ 8700 3120 l gs col0 s gr 
+% Polyline
+n 8535 3600 m
+ 9015 3585 l gs col0 s gr 
+% Polyline
+n 8505 3630 m
+ 8790 4020 l gs col0 s gr 
+% Polyline
+n 7410 6255 m
+ 7890 6270 l gs col0 s gr 
+% Polyline
+n 7365 6285 m
+ 7680 6675 l gs col0 s gr 
+% Polyline
+n 7350 6300 m
+ 7125 6645 l gs col0 s gr 
+% Polyline
+n 4410 6540 m
+ 4830 6900 l gs col0 s gr 
+% Polyline
+n 4395 6570 m
+ 3885 6630 l gs col0 s gr 
+% Polyline
+n 2835 4755 m
+ 2610 5130 l gs col0 s gr 
+% Polyline
+n 2820 4740 m
+ 2565 4290 l gs col0 s gr 
+% Polyline
+n 2805 4770 m
+ 2460 4770 l gs col0 s gr 
+% Polyline
+gs  clippath
+2400 7530 m 2340 7530 l 2340 7682 l 2370 7562 l 2400 7682 l cp
+eoclip
+n 2370 8160 m
+ 2370 7545 l gs col0 s gr gr
+
+% arrowhead
+n 2400 7682 m 2370 7562 l 2340 7682 l  col0 s
+% Polyline
+gs  clippath
+3000 8205 m 3000 8145 l 2848 8145 l 2968 8175 l 2848 8205 l cp
+eoclip
+n 2370 8175 m
+ 2985 8175 l gs col0 s gr gr
+
+% arrowhead
+n 2848 8205 m 2968 8175 l 2848 8145 l  col0 s
+/Times-Roman ff 300.00 scf sf
+3045 8250 m
+gs 1 -1 sc (x) col0 sh gr
+/Times-Roman ff 300.00 scf sf
+2340 7470 m
+gs 1 -1 sc (y) col0 sh gr
+% here ends figure;
+$F2psEnd
+rs
+showpage
--- wavefronts.eps	1970-01-01 01:00:00.000000000 +0100
+++ wavefronts.eps	2008-10-15 11:57:40.000000000 +0200
@@ -0,0 +1,533 @@
+%!PS-Adobe-2.0 EPSF-1.2
+%%Creator: MATLAB, The Mathworks, Inc. Version 7.5.0.342 (R2007b). Operating System: Microsoft Windows XP x64.
+%%Title: .\wavefronts3.eps
+%%CreationDate: 08/14/2008  11:57:36
+%%DocumentNeededFonts: Helvetica
+%%DocumentProcessColors: Cyan Magenta Yellow Black
+%%Extensions: CMYK
+%%Pages: 1
+%%BoundingBox:    89   270   543   540
+%%EndComments
+
+%%BeginProlog
+% MathWorks dictionary
+/MathWorks 160 dict begin
+% definition operators
+/bdef {bind def} bind def
+/ldef {load def} bind def
+/xdef {exch def} bdef
+/xstore {exch store} bdef
+% operator abbreviations
+/c  /clip ldef
+/cc /concat ldef
+/cp /closepath ldef
+/gr /grestore ldef
+/gs /gsave ldef
+/mt /moveto ldef
+/np /newpath ldef
+/cm /currentmatrix ldef
+/sm /setmatrix ldef
+/rm /rmoveto ldef
+/rl /rlineto ldef
+/s {show newpath} bdef
+/sc {setcmykcolor} bdef
+/sr /setrgbcolor ldef
+/sg /setgray ldef
+/w /setlinewidth ldef
+/j /setlinejoin ldef
+/cap /setlinecap ldef
+/rc {rectclip} bdef
+/rf {rectfill} bdef
+% page state control
+/pgsv () def
+/bpage {/pgsv save def} bdef
+/epage {pgsv restore} bdef
+/bplot /gsave ldef
+/eplot {stroke grestore} bdef
+% orientation switch
+/portraitMode 0 def /landscapeMode 1 def /rotateMode 2 def
+% coordinate system mappings
+/dpi2point 0 def
+% font control
+/FontSize 0 def
+/FMS {/FontSize xstore findfont [FontSize 0 0 FontSize neg 0 0]
+  makefont setfont} bdef
+/ISOLatin1Encoding where {pop /WindowsLatin1Encoding 256 array bdef
+ISOLatin1Encoding WindowsLatin1Encoding copy pop
+/.notdef/.notdef/quotesinglbase/florin/quotedblbase/ellipsis/dagger
+/daggerdbl/circumflex/perthousand/Scaron/guilsinglleft/OE/.notdef/.notdef
+/.notdef/.notdef/quoteleft/quoteright/quotedblleft/quotedblright/bullet
+/endash/emdash/tilde/trademark/scaron/guilsinglright/oe/.notdef/.notdef
+/Ydieresis WindowsLatin1Encoding 128 32 getinterval astore pop}
+{/WindowsLatin1Encoding StandardEncoding bdef} ifelse
+/reencode {exch dup where {pop load} {pop StandardEncoding} ifelse
+  exch dup 3 1 roll findfont dup length dict begin
+  { 1 index /FID ne {def}{pop pop} ifelse } forall
+  /Encoding exch def currentdict end definefont pop} bdef
+/isroman {findfont /CharStrings get /Agrave known} bdef
+/FMSR {3 1 roll 1 index dup isroman {reencode} {pop pop} ifelse
+  exch FMS} bdef
+/csm {1 dpi2point div -1 dpi2point div scale neg translate
+ dup landscapeMode eq {pop -90 rotate}
+  {rotateMode eq {90 rotate} if} ifelse} bdef
+% line types: solid, dotted, dashed, dotdash
+/SO { [] 0 setdash } bdef
+/DO { [.5 dpi2point mul 4 dpi2point mul] 0 setdash } bdef
+/DA { [6 dpi2point mul] 0 setdash } bdef
+/DD { [.5 dpi2point mul 4 dpi2point mul 6 dpi2point mul 4
+  dpi2point mul] 0 setdash } bdef
+% macros for lines and objects
+/L {lineto stroke} bdef
+/MP {3 1 roll moveto 1 sub {rlineto} repeat} bdef
+/AP {{rlineto} repeat} bdef
+/PDlw -1 def
+/W {/PDlw currentlinewidth def setlinewidth} def
+/PP {closepath eofill} bdef
+/DP {closepath stroke} bdef
+/MR {4 -2 roll moveto dup  0 exch rlineto exch 0 rlineto
+  neg 0 exch rlineto closepath} bdef
+/FR {MR stroke} bdef
+/PR {MR fill} bdef
+/L1i {{currentfile picstr readhexstring pop} image} bdef
+/tMatrix matrix def
+/MakeOval {newpath tMatrix currentmatrix pop translate scale
+0 0 1 0 360 arc tMatrix setmatrix} bdef
+/FO {MakeOval stroke} bdef
+/PO {MakeOval fill} bdef
+/PD {currentlinewidth 2 div 0 360 arc fill
+   PDlw -1 eq not {PDlw w /PDlw -1 def} if} def
+/FA {newpath tMatrix currentmatrix pop translate scale
+  0 0 1 5 -2 roll arc tMatrix setmatrix stroke} bdef
+/PA {newpath tMatrix currentmatrix pop	translate 0 0 moveto scale
+  0 0 1 5 -2 roll arc closepath tMatrix setmatrix fill} bdef
+/FAn {newpath tMatrix currentmatrix pop translate scale
+  0 0 1 5 -2 roll arcn tMatrix setmatrix stroke} bdef
+/PAn {newpath tMatrix currentmatrix pop translate 0 0 moveto scale
+  0 0 1 5 -2 roll arcn closepath tMatrix setmatrix fill} bdef
+/vradius 0 def /hradius 0 def /lry 0 def
+/lrx 0 def /uly 0 def /ulx 0 def /rad 0 def
+/MRR {/vradius xdef /hradius xdef /lry xdef /lrx xdef /uly xdef
+  /ulx xdef newpath tMatrix currentmatrix pop ulx hradius add uly
+  vradius add translate hradius vradius scale 0 0 1 180 270 arc 
+  tMatrix setmatrix lrx hradius sub uly vradius add translate
+  hradius vradius scale 0 0 1 270 360 arc tMatrix setmatrix
+  lrx hradius sub lry vradius sub translate hradius vradius scale
+  0 0 1 0 90 arc tMatrix setmatrix ulx hradius add lry vradius sub
+  translate hradius vradius scale 0 0 1 90 180 arc tMatrix setmatrix
+  closepath} bdef
+/FRR {MRR stroke } bdef
+/PRR {MRR fill } bdef
+/MlrRR {/lry xdef /lrx xdef /uly xdef /ulx xdef /rad lry uly sub 2 div def
+  newpath tMatrix currentmatrix pop ulx rad add uly rad add translate
+  rad rad scale 0 0 1 90 270 arc tMatrix setmatrix lrx rad sub lry rad
+  sub translate rad rad scale 0 0 1 270 90 arc tMatrix setmatrix
+  closepath} bdef
+/FlrRR {MlrRR stroke } bdef
+/PlrRR {MlrRR fill } bdef
+/MtbRR {/lry xdef /lrx xdef /uly xdef /ulx xdef /rad lrx ulx sub 2 div def
+  newpath tMatrix currentmatrix pop ulx rad add uly rad add translate
+  rad rad scale 0 0 1 180 360 arc tMatrix setmatrix lrx rad sub lry rad
+  sub translate rad rad scale 0 0 1 0 180 arc tMatrix setmatrix
+  closepath} bdef
+/FtbRR {MtbRR stroke } bdef
+/PtbRR {MtbRR fill } bdef
+/stri 6 array def /dtri 6 array def
+/smat 6 array def /dmat 6 array def
+/tmat1 6 array def /tmat2 6 array def /dif 3 array def
+/asub {/ind2 exch def /ind1 exch def dup dup
+  ind1 get exch ind2 get sub exch } bdef
+/tri_to_matrix {
+  2 0 asub 3 1 asub 4 0 asub 5 1 asub
+  dup 0 get exch 1 get 7 -1 roll astore } bdef
+/compute_transform {
+  dmat dtri tri_to_matrix tmat1 invertmatrix 
+  smat stri tri_to_matrix tmat2 concatmatrix } bdef
+/ds {stri astore pop} bdef
+/dt {dtri astore pop} bdef
+/db {2 copy /cols xdef /rows xdef mul dup 3 mul string
+  currentfile exch readhexstring pop
+  dup 0 3 index getinterval /rbmap xdef
+  dup 2 index dup getinterval /gbmap xdef
+  1 index dup 2 mul exch getinterval /bbmap xdef pop pop}bdef
+/it {gs np dtri aload pop moveto lineto lineto cp c
+  cols rows 8 compute_transform 
+  rbmap gbmap bbmap true 3 colorimage gr}bdef
+/il {newpath moveto lineto stroke}bdef
+currentdict end def
+%%EndProlog
+
+%%BeginSetup
+MathWorks begin
+
+0 cap
+
+end
+%%EndSetup
+
+%%Page: 1 1
+%%BeginPageSetup
+%%PageBoundingBox:    89   270   543   540
+MathWorks begin
+bpage
+%%EndPageSetup
+
+%%BeginObject: obj1
+bplot
+
+/dpi2point 12 def
+portraitMode 0216 7344 csm
+
+  859   862  5451  3233 MR c np
+88 dict begin %Colortable dictionary
+/c0 { 0.000000 0.000000 0.000000 sr} bdef
+/c1 { 1.000000 1.000000 1.000000 sr} bdef
+/c2 { 0.900000 0.000000 0.000000 sr} bdef
+/c3 { 0.000000 0.820000 0.000000 sr} bdef
+/c4 { 0.000000 0.000000 0.800000 sr} bdef
+/c5 { 0.910000 0.820000 0.320000 sr} bdef
+/c6 { 1.000000 0.260000 0.820000 sr} bdef
+/c7 { 0.000000 0.820000 0.820000 sr} bdef
+c0
+1 j
+1 sg
+   0    0 6919 5187 PR
+6 w
+gs 899 950 5363 3105 MR c np
+24 w
+0 sg
+580 -869 164 852 -744 17 10968 2465 4 MP stroke
+93 618 -898 -180 805 -438 7838 2431 4 MP stroke
+-785 676 212 -899 573 223 3099 3105 4 MP stroke
+854 -431 -302 894 -552 -463 5068 2607 4 MP stroke
+352 -875 190 585 -542 290 4214 3038 4 MP stroke
+-346 -513 618 25 -272 488 6276 2083 4 MP stroke
+334 -902 548 902 -882 0 8977 1091 4 MP stroke
+224 -686 630 255 -854 431 5068 2607 4 MP stroke
+973 200 -441 522 -532 -722 7745 1813 4 MP stroke
+271 -613 399 641 -670 -28 6955 3300 4 MP stroke
+-106 658 -708 -521 814 -137 8820 3256 4 MP stroke
+-882 0 441 -522 441 522 6331 1091 4 MP stroke
+-406 508 -146 -971 552 463 4516 2144 4 MP stroke
+705 0 -240 739 -465 -739 5978 3913 4 MP stroke
+532 722 -882 0 350 -722 7745 1813 4 MP stroke
+-55 992 -441 -522 496 -470 6276 2083 4 MP stroke
+-696 315 565 -1067 131 752 7611 3161 4 MP stroke
+-93 -618 625 17 -532 601 7745 1813 4 MP stroke
+696 -315 -227 730 -469 -415 8307 2846 4 MP stroke
+-160 732 -794 -801 954 69 10581 1823 4 MP stroke
+-805 438 336 -853 469 415 7838 2431 4 MP stroke
+-131 -752 787 613 -656 139 7611 3161 4 MP stroke
+-903 53 620 -658 283 605 8643 1993 4 MP stroke
+333 704 -591 182 258 -886 6955 3300 4 MP stroke
+20 -657 1058 0 -1078 657 8820 3256 4 MP stroke
+-304 794 -225 -794 529 0 9330 3913 4 MP stroke
+-350 722 -548 -902 898 180 7745 1813 4 MP stroke
+-337 676 -333 -704 670 28 6285 3272 4 MP stroke
+799 -772 83 772 -882 0 6331 1091 4 MP stroke
+227 -730 398 747 -625 -17 7838 2431 4 MP stroke
+346 513 -496 470 150 -983 6622 2596 4 MP stroke
+532 -601 441 801 -973 -200 7745 1813 4 MP stroke
+-387 -642 744 -17 -357 659 10581 1823 4 MP stroke
+591 -182 -150 983 -441 -801 7213 2414 4 MP stroke
+-619 248 106 -658 513 410 8307 2846 4 MP stroke
+55 -992 744 220 -799 772 6331 1091 4 MP stroke
+355 545 -882 0 527 -545 4922 1636 4 MP stroke
+-882 0 616 -644 266 644 3685 1091 4 MP stroke
+-491 603 -281 -701 772 98 5513 3174 4 MP stroke
+-744 -220 272 -488 472 708 5532 1863 4 MP stroke
+281 701 -618 -25 337 -676 6285 3272 4 MP stroke
+-307 641 -399 -641 706 0 5978 3913 4 MP stroke
+1058 0 -271 613 -787 -613 7742 3913 4 MP stroke
+-258 886 -398 -747 656 -139 6955 3300 4 MP stroke
+-464 744 -472 -708 936 -36 5068 2607 4 MP stroke
+240 -739 429 620 -669 119 5513 3174 4 MP stroke
+353 875 -630 -255 277 -620 4567 3913 4 MP stroke
+-772 -98 307 -641 465 739 5513 3174 4 MP stroke
+785 -676 -183 1020 -602 -344 3884 2429 4 MP stroke
+-336 853 -283 -605 619 -248 8307 2846 4 MP stroke
+-20 657 -510 -657 530 0 8800 3913 4 MP stroke
+-565 1067 -513 -410 1078 -657 7742 3913 4 MP stroke
+1058 0 -529 579 -529 -579 10917 3913 4 MP stroke
+-620 658 -88 -1179 708 521 8926 2598 4 MP stroke
+-678 -542 590 -637 88 1179 9546 1940 4 MP stroke
+784 -549 98 549 -882 0 9859 1091 4 MP stroke
+-754 -215 529 -579 225 794 9634 3119 4 MP stroke
+-70 -632 624 126 -554 506 11678 2686 4 MP stroke
+-814 137 304 -794 510 657 8820 3256 4 MP stroke
+-590 637 -164 -852 754 215 9634 3119 4 MP stroke
+118 -780 777 137 -895 643 13386 1091 4 MP stroke
+-591 -150 384 -462 207 612 12056 2208 4 MP stroke
+-736 142 207 -721 529 579 10388 3334 4 MP stroke
+736 -142 -580 869 -156 -727 11124 3192 4 MP stroke
+529 -543 227 595 -756 -52 12504 3370 4 MP stroke
+-515 498 -241 -550 756 52 11748 3318 4 MP stroke
+156 727 -710 -221 554 -506 11124 3192 4 MP stroke
+710 221 -567 573 -143 -794 11678 2686 4 MP stroke
+-831 595 -227 -595 1058 0 10917 3913 4 MP stroke
+357 -659 188 844 -545 -185 10581 1823 4 MP stroke
+-207 721 -624 -126 831 -595 10917 3913 4 MP stroke
+-530 -543 1059 0 -529 543 12504 3370 4 MP stroke
+530 543 -708 160 178 -703 13034 3913 4 MP stroke
+378 -478 143 794 -521 -316 12056 2208 4 MP stroke
+949 390 -384 462 -565 -852 13212 3210 4 MP stroke
+490 -302 -313 849 -177 -547 10036 1638 4 MP stroke
+794 801 -881 0 87 -801 11535 1892 4 MP stroke
+567 -573 387 642 -954 -69 11535 1892 4 MP stroke
+0 -706 619 686 -619 20 15150 2502 4 MP stroke
+435 -474 521 316 -956 158 12491 1734 4 MP stroke
+538 228 -903 229 365 -457 13750 3438 4 MP stroke
+-721 363 -101 -801 822 438 13293 2543 4 MP stroke
+-869 -643 956 -158 -87 801 11622 1091 4 MP stroke
+-716 475 -342 -475 1058 0 13034 3913 4 MP stroke
+585 134 -378 478 -207 -612 12263 2820 4 MP stroke
+895 -643 -13 643 -882 0 13386 1091 4 MP stroke
+-156 -624 591 150 -435 474 12491 1734 4 MP stroke
+-777 -137 621 -487 156 624 12491 1734 4 MP stroke
+869 643 -882 0 13 -643 12491 1734 4 MP stroke
+565 852 -646 -185 81 -667 13212 3210 4 MP stroke
+-621 487 -25 -672 646 185 12647 2358 4 MP stroke
+-597 250 0 -705 597 455 14553 3458 4 MP stroke
+101 801 -517 -342 416 -459 14115 2981 4 MP stroke
+-447 -473 565 -307 -118 780 13386 1091 4 MP stroke
+903 -229 -81 667 -822 -438 14115 2981 4 MP stroke
+25 672 -746 -309 721 -363 13293 2543 4 MP stroke
+-181 -616 746 309 -565 307 13833 1564 4 MP stroke
+619 -726 63 810 -682 -84 15150 1796 4 MP stroke
+-365 457 -438 -477 803 20 13750 3438 4 MP stroke
+682 -621 200 621 -882 0 15150 1091 4 MP stroke
+454 -468 181 616 -635 -148 14468 1712 4 MP stroke
+438 477 -416 459 -22 -936 14553 3458 4 MP stroke
+-619 726 0 -706 619 -20 14531 2522 4 MP stroke
+-200 -621 635 148 -435 473 14268 1091 4 MP stroke
+-882 0 435 -473 447 473 13386 1091 4 MP stroke
+517 342 -454 468 -63 -810 14531 2522 4 MP stroke
+0 -705 682 84 -682 621 15150 1091 4 MP stroke
+-352 875 -353 -875 705 0 3862 3913 4 MP stroke
+177 547 -882 0 705 -547 10036 1638 4 MP stroke
+-178 703 -538 -228 716 -475 13034 3913 4 MP stroke
+461 -455 342 475 -803 -20 14553 3458 4 MP stroke
+1058 0 -461 455 -597 -455 15150 3913 4 MP stroke
+-619 -686 597 -250 22 936 14531 2522 4 MP stroke
+706 0 -277 620 -429 -620 5273 3913 4 MP stroke
+-224 686 -445 -567 669 -119 4844 3293 4 MP stroke
+491 -603 445 567 -936 36 6004 2571 4 MP stroke
+-610 -227 464 -744 146 971 4922 1636 4 MP stroke
+-851 59 9 -647 842 588 1040 1796 4 MP stroke
+-669 350 67 -694 602 344 3282 2085 4 MP stroke
+376 594 -559 426 183 -1020 3099 3105 4 MP stroke
+678 542 -490 302 -188 -844 10224 2482 4 MP stroke
+160 -732 545 185 -705 547 10741 1091 4 MP stroke
+-632 285 302 -894 330 609 3884 2429 4 MP stroke
+-971 99 406 -508 565 409 3951 1735 4 MP stroke
+-753 60 648 -808 105 748 2346 3165 4 MP stroke
+632 -285 -67 694 -565 -409 4516 2144 4 MP stroke
+-882 0 441 -400 441 400 2803 1091 4 MP stroke
+751 250 -713 344 -38 -594 3282 2085 4 MP stroke
+-190 -585 706 0 -516 585 3672 3328 4 MP stroke
+-330 -609 542 -290 -212 899 3884 2429 4 MP stroke
+707 244 -441 400 -266 -644 3951 1735 4 MP stroke
+705 0 -648 808 -57 -808 3156 3913 4 MP stroke
+-272 744 -441 -400 713 -344 2531 1835 4 MP stroke
+-573 -223 516 -585 57 808 3099 3105 4 MP stroke
+669 -350 38 594 -707 -244 3951 1735 4 MP stroke
+-601 748 -105 -748 706 0 1745 3913 4 MP stroke
+559 -426 192 676 -751 -250 3282 2085 4 MP stroke
+841 127 -649 549 -192 -676 2723 2511 4 MP stroke
+609 744 -881 0 272 -744 2531 1835 4 MP stroke
+753 -60 -377 654 -376 -594 3099 3105 4 MP stroke
+-841 -127 377 -654 464 781 1882 2384 4 MP stroke
+649 -549 -9 647 -640 -98 2531 1835 4 MP stroke
+-50 -656 705 0 -655 656 1695 3257 4 MP stroke
+-31 646 -609 -744 640 98 1891 1737 4 MP stroke
+-655 -755 655 49 0 706 1040 2502 4 MP stroke
+601 -748 50 656 -651 92 2346 3165 4 MP stroke
+-842 118 187 -873 655 755 1040 2502 4 MP stroke
+31 -646 851 646 -882 0 1922 1091 4 MP stroke
+842 -118 0 706 -842 -588 1882 2384 4 MP stroke
+-464 -781 651 -92 -187 873 1882 2384 4 MP stroke
+0 705 -655 -49 655 -656 1040 3913 4 MP stroke
+-83 -772 610 227 -527 545 5449 1091 4 MP stroke
+-616 644 -355 -545 971 -99 3951 1735 4 MP stroke
+313 -849 471 300 -784 549 9859 1091 4 MP stroke
+903 -53 -432 353 -471 -300 9546 1940 4 MP stroke
+-98 -549 432 -353 -334 902 8977 1091 4 MP stroke
+70 632 -585 -134 515 -498 11748 3318 4 MP stroke
+708 -160 241 550 -949 -390 13212 3210 4 MP stroke
+851 -59 0 705 -851 -646 1891 1737 4 MP stroke
+6 w
+gr
+
+0 sg
+  90   90 1040 3913 PO
+  90   90 1040 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+/c8 { 1.000000 0.000000 0.000000 sr} bdef
+c8
+  90   90 1745 3913 PO
+  90   90 1745 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1040 3208 PO
+  90   90 1040 3208 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1695 3257 PO
+  90   90 1695 3257 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+/c9 { 0.000000 1.000000 0.000000 sr} bdef
+c9
+  90   90 2451 3913 PO
+  90   90 2451 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1040 2502 PO
+  90   90 1040 2502 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 2346 3165 PO
+  90   90 2346 3165 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1882 2384 PO
+  90   90 1882 2384 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+/c10 { 1.000000 0.000000 1.000000 sr} bdef
+c10
+  90   90 1040 1796 PO
+  90   90 1040 1796 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3156 3913 PO
+  90   90 3156 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 2723 2511 PO
+  90   90 2723 2511 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3099 3105 PO
+  90   90 3099 3105 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1891 1737 PO
+  90   90 1891 1737 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 2531 1835 PO
+  90   90 2531 1835 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+/c11 { 0.870588 0.490196 0.000000 sr} bdef
+c11
+  90   90 3672 3328 PO
+  90   90 3672 3328 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1040 1091 PO
+  90   90 1040 1091 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3862 3913 PO
+  90   90 3862 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3282 2085 PO
+  90   90 3282 2085 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 1922 1091 PO
+  90   90 1922 1091 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3884 2429 PO
+  90   90 3884 2429 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3244 1491 PO
+  90   90 3244 1491 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 4214 3038 PO
+  90   90 4214 3038 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 2803 1091 PO
+  90   90 2803 1091 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+/c12 { 0.000000 0.000000 1.000000 sr} bdef
+c12
+  90   90 4567 3913 PO
+  90   90 4567 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3951 1735 PO
+  90   90 3951 1735 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 4844 3293 PO
+  90   90 4844 3293 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 3685 1091 PO
+  90   90 3685 1091 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 4516 2144 PO
+  90   90 4516 2144 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 5273 3913 PO
+  90   90 5273 3913 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+  90   90 5068 2607 PO
+  90   90 5068 2607 FO
+gs 899 950 5363 3105 MR c np
+gr
+
+
+end %%Color Dict
+
+eplot
+%%EndObject
+
+epage
+end
+
+showpage
+
+%%Trailer
+%%EOF
