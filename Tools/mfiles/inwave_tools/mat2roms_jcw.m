function mat2roms_jcw(theMatFile, theROMSFile)% mat2roms -- Convert from Mat-file to ROMS file.%  mat2roms('theMatFile', 'theROMSFile') ... % Copyright (C) 2002 Dr. Charles R. Denham, ZYDECO.%  All Rights Reserved.%   Disclosure without explicit written consent from the%    copyright owner does not constitute publication. % Version of 22-May-2002 16:25:10.% Updated    23-May-2002 14:35:09.if nargin < 1, theMatFile = '*.mat'; endif nargin < 2, theROMSFile = 'roms_model_grid.nc'; end% Get the file names.if any(theMatFile == '*')	help(mfilename)	theFilterSpec = theMatFile;	thePrompt = 'Select a Mat-File';	[theFile, thePath] = uigetfile(theFilterSpec, thePrompt);	if ~any(theFile), return, end	if thePath(end) ~= filesep, thePath(end+1) = filesep; end	theMatFile = [thePath theFile];endif any(theROMSFile == '*')	theFilterSpec = theROMSFile;	thePrompt = 'Save As ROMS File';	[theFile, thePath] = uiputfile(theFilterSpec, thePrompt);	if ~any(theFile), return, end	if thePath(end) ~= filesep, thePath(end+1) = filesep; end	theROMSFile = [thePath theFile];endif isequal(theMatFile, theROMSFile)	disp([' ## Must not select same file for input and output.'])	returnend% Load the Mat-File.s = load(theMatFile);if isempty(s)	disp([' ## Mat-File is empty.'])	returnend% WetCDF on.if any(findstr(lower(computer), 'mac'))	eval('wetcdf on')end% Open the ROMS File.nc = netcdf(theROMSFile, 'clobber');if isempty(nc)	disp([' ## Unable to open ROMS NetCDF output file.'])	returnend% Populate the ROMS File.%% Global attributes:disp(' ## Defining Global Attributes...') nc.type = ncchar('ROMS GRID file');nc.gridid = ncchar('theGridTitle');nc.history = ncchar(['Created by "' mfilename '" on ' datestr(now)]);nc.title = ncchar(['ROMS Application']);% Dimensions:[m, n] = size(s.rho.x)% The xi direction (left-right):LP = n;   % The rho dimension.L = LP-1; % The psi dimension.% The eta direction (up-down):MP = m;   % The rho dimension.M = MP-1; % The psi dimension.disp(' ## Defining Dimensions...') nc('xi_psi') = L;nc('xi_rho') = LP;nc('xi_u') = L;nc('xi_v') = LP;nc('eta_psi') = M;nc('eta_rho') = MP;nc('eta_u') = MP;nc('eta_v') = M;nc('one') = 1;nc('two') = 2;nc('bath') = 0; %% (record dimension) %% Variables and attributes:disp(' ## Defining Variables and Attributes...') nc{'xl'} = ncdouble('one'); %% 1 element.nc{'xl'}.long_name = ncchar('domain length in the XI-direction');nc{'xl'}.units = ncchar('meter'); nc{'el'} = ncdouble('one'); %% 1 element.nc{'el'}.long_name = ncchar('domain length in the ETA-direction');nc{'el'}.units = ncchar('meter'); nc{'JPRJ'} = ncchar('two'); %% 2 elements.nc{'JPRJ'}.long_name = ncchar('Map projection type');nc{'JPRJ'}.option_ME_ = ncchar('Mercator');nc{'JPRJ'}.option_ST_ = ncchar('Stereographic');nc{'JPRJ'}.option_LC_ = ncchar('Lambert conformal conic');%name(nc{'JPRJ'}.option_ME_, 'option(ME)')%name(nc{'JPRJ'}.option_ST_, 'option(ST)')%name(nc{'JPRJ'}.option_LC_, 'option(LC)') nc{'depthmin'} = ncshort('one'); %% 1 element.nc{'depthmin'}.long_name = ncchar('Shallow bathymetry clipping depth');nc{'depthmin'}.units = ncchar('meter'); nc{'depthmax'} = ncshort('one'); %% 1 element.nc{'depthmax'}.long_name = ncchar('Deep bathymetry clipping depth');nc{'depthmax'}.units = ncchar('meter'); nc{'spherical'} = ncchar('one'); %% 1 element.nc{'spherical'}.long_name = ncchar('Grid type logical switch');nc{'spherical'}.option_T_ = ncchar('spherical');nc{'spherical'}.option_F_ = ncchar('Cartesian');%name(nc{'spherical'}.option_T_, 'option(T)')%name(nc{'spherical'}.option_F_, 'option(F)') nc{'hraw'} = ncdouble('bath', 'eta_rho', 'xi_rho'); %% 0 elements.nc{'hraw'}.long_name = ncchar('Working bathymetry at RHO-points');nc{'hraw'}.units = ncchar('meter');nc{'hraw'}.field = ncchar('bath, scalar'); nc{'h'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'h'}.long_name = ncchar('Final bathymetry at RHO-points');nc{'h'}.units = ncchar('meter');nc{'h'}.field = ncchar('bath, scalar'); nc{'f'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'f'}.long_name = ncchar('Coriolis parameter at RHO-points');nc{'f'}.units = ncchar('second-1');nc{'f'}.field = ncchar('Coriolis, scalar'); nc{'pm'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'pm'}.long_name = ncchar('curvilinear coordinate metric in XI');nc{'pm'}.units = ncchar('meter-1');nc{'pm'}.field = ncchar('pm, scalar'); nc{'pn'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'pn'}.long_name = ncchar('curvilinear coordinate metric in ETA');nc{'pn'}.units = ncchar('meter-1');nc{'pn'}.field = ncchar('pn, scalar'); nc{'dndx'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'dndx'}.long_name = ncchar('xi derivative of inverse metric factor pn');nc{'dndx'}.units = ncchar('meter');nc{'dndx'}.field = ncchar('dndx, scalar'); nc{'dmde'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'dmde'}.long_name = ncchar('eta derivative of inverse metric factor pm');nc{'dmde'}.units = ncchar('meter');nc{'dmde'}.field = ncchar('dmde, scalar'); nc{'x_rho'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'x_rho'}.long_name = ncchar('x location of RHO-points');nc{'x_rho'}.units = ncchar('meter'); nc{'y_rho'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'y_rho'}.long_name = ncchar('y location of RHO-points');nc{'y_rho'}.units = ncchar('meter'); nc{'x_psi'} = ncdouble('eta_psi', 'xi_psi'); %% 16641 elements.nc{'x_psi'}.long_name = ncchar('x location of PSI-points');nc{'x_psi'}.units = ncchar('meter'); nc{'y_psi'} = ncdouble('eta_psi', 'xi_psi'); %% 16641 elements.nc{'y_psi'}.long_name = ncchar('y location of PSI-points');nc{'y_psi'}.units = ncchar('meter'); nc{'x_u'} = ncdouble('eta_u', 'xi_u'); %% 16770 elements.nc{'x_u'}.long_name = ncchar('x location of U-points');nc{'x_u'}.units = ncchar('meter'); nc{'y_u'} = ncdouble('eta_u', 'xi_u'); %% 16770 elements.nc{'y_u'}.long_name = ncchar('y location of U-points');nc{'y_u'}.units = ncchar('meter'); nc{'x_v'} = ncdouble('eta_v', 'xi_v'); %% 16770 elements.nc{'x_v'}.long_name = ncchar('x location of V-points');nc{'x_v'}.units = ncchar('meter'); nc{'y_v'} = ncdouble('eta_v', 'xi_v'); %% 16770 elements.nc{'y_v'}.long_name = ncchar('y location of V-points');nc{'y_v'}.units = ncchar('meter'); nc{'lat_rho'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'lat_rho'}.long_name = ncchar('latitude of RHO-points');nc{'lat_rho'}.units = ncchar('degree_north'); nc{'lon_rho'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'lon_rho'}.long_name = ncchar('longitude of RHO-points');nc{'lon_rho'}.units = ncchar('degree_east'); nc{'lat_psi'} = ncdouble('eta_psi', 'xi_psi'); %% 16641 elements.nc{'lat_psi'}.long_name = ncchar('latitude of PSI-points');nc{'lat_psi'}.units = ncchar('degree_north'); nc{'lon_psi'} = ncdouble('eta_psi', 'xi_psi'); %% 16641 elements.nc{'lon_psi'}.long_name = ncchar('longitude of PSI-points');nc{'lon_psi'}.units = ncchar('degree_east'); nc{'lat_u'} = ncdouble('eta_u', 'xi_u'); %% 16770 elements.nc{'lat_u'}.long_name = ncchar('latitude of U-points');nc{'lat_u'}.units = ncchar('degree_north'); nc{'lon_u'} = ncdouble('eta_u', 'xi_u'); %% 16770 elements.nc{'lon_u'}.long_name = ncchar('longitude of U-points');nc{'lon_u'}.units = ncchar('degree_east'); nc{'lat_v'} = ncdouble('eta_v', 'xi_v'); %% 16770 elements.nc{'lat_v'}.long_name = ncchar('latitude of V-points');nc{'lat_v'}.units = ncchar('degree_north'); nc{'lon_v'} = ncdouble('eta_v', 'xi_v'); %% 16770 elements.nc{'lon_v'}.long_name = ncchar('longitude of V-points');nc{'lon_v'}.units = ncchar('degree_east'); nc{'mask_rho'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'mask_rho'}.long_name = ncchar('mask on RHO-points');nc{'mask_rho'}.option_0_ = ncchar('land');nc{'mask_rho'}.option_1_ = ncchar('water'); nc{'mask_u'} = ncdouble('eta_u', 'xi_u'); %% 16770 elements.nc{'mask_u'}.long_name = ncchar('mask on U-points');nc{'mask_u'}.option_0_ = ncchar('land');nc{'mask_u'}.option_1_ = ncchar('water'); nc{'mask_v'} = ncdouble('eta_v', 'xi_v'); %% 16770 elements.nc{'mask_v'}.long_name = ncchar('mask on V-points');nc{'mask_v'}.option_0_ = ncchar('land');nc{'mask_v'}.option_1_ = ncchar('water'); nc{'mask_psi'} = ncdouble('eta_psi', 'xi_psi'); %% 16641 elements.nc{'mask_psi'}.long_name = ncchar('mask on PSI-points');nc{'mask_psi'}.option_0_ = ncchar('land');nc{'mask_psi'}.option_1_ = ncchar('water');nc{'angle'} = ncdouble('eta_rho', 'xi_rho'); %% 16900 elements.nc{'angle'}.long_name = ncchar('angle between xi axis and east');nc{'angle'}.units = ncchar('degree');% Variables.% Fill the variables with data.disp(' ## Filling Variables...')projection = s.projection;switch lower(projection)case 'mercator'	theProjection = 'ME';case 'stereographic'	theProjection = 'ST';case 'lambert conformal conic'	theProjection = 'LC';otherwise	theProjection = '??';endnc{'JPRJ'}(1:2) = theProjection;nc{'spherical'}(:) = 'F';% Cartesian coordinates.x = s.rho.x;y = s.rho.y;dx = s.rho.dx;dy = s.rho.dy;angle = s.rho.angle;bathymetry = s.rho.depth;grid_x = interp2(x, 'bilinear');grid_y = interp2(y, 'bilinear');% Geographic coordinates.% commented by maitane%m_proj(s.projection)% %[lon, lat] = m_xy2ll(x, y);% [geogrid_lon, geogrid_lat] = m_xy2ll(grid_x, grid_y);   % Degrees.% [geogrid_lon, geogrid_lat] = m_xy2ll(grid_x/6371000, grid_y/6371000);   % Degrees.xl = max(grid_x(:)) - min(grid_x(:));el = max(grid_y(:)) - min(grid_y(:));nc{'xl'}(:) = xl;nc{'el'}(:) = el;nc{'f'}(:,:) = s.rho.f(:,:);% Handy indices.[m, n] = size(grid_x);i_rho = 1:2:n;j_rho = 1:2:m;i_psi = 2:2:n;j_psi = 2:2:m;i_u = 2:2:n;j_u = 1:2:m;i_v = 1:2:n;j_v = 2:2:m;% Locations.nc{'x_rho'}(:,:) = x;nc{'y_rho'}(:,:) = y;nc{'x_psi'}(:,:) = grid_x(j_psi, i_psi);nc{'y_psi'}(:,:) = grid_y(j_psi, i_psi);nc{'x_u'}(:,:) = grid_x(j_u, i_u);nc{'y_u'}(:,:) = grid_y(j_u, i_u);nc{'x_v'}(:,:) = grid_x(j_v, i_v);nc{'y_v'}(:,:) = grid_y(j_v, i_v);% commented by maitane% nc{'lon_rho'}(:) = geogrid_lon(j_rho, i_rho);% nc{'lat_rho'}(:) = geogrid_lat(j_rho, i_rho);% % nc{'lon_psi'}(:) = geogrid_lon(j_psi, i_psi);% nc{'lat_psi'}(:) = geogrid_lat(j_psi, i_psi);% % nc{'lon_u'}(:) = geogrid_lon(j_u, i_u);% nc{'lat_u'}(:) = geogrid_lat(j_u, i_u);% % nc{'lon_v'}(:) = geogrid_lon(j_v, i_v);% nc{'lat_v'}(:) = geogrid_lat(j_v, i_v);% Metric factors.% dmde = zeros(size(dx));% dndx = zeros(size(dy));dmde = zeros(size(x));dndx = zeros(size(y));dmde(2:end-1, :) = 0.5*(dx(3:end, :) - dx(1:end-2, :));dndx(:, 2:end-1) = 0.5*(dy(:, 3:end) - dy(:, 1:end-2));nc{'dmde'}(:,:) = dmde(:,:);nc{'dndx'}(:,:) = dndx(:,:);pm = 1 ./ dx;pn = 1 ./ dy;nc{'pm'}(:) = pm;nc{'pn'}(:) = pn;% Angle.nc{'angle'}(:,:) = s.rho.angle;   % Degrees.% Depths at RHO points.if ~isempty(bathymetry)  nc{'h'}(:,:) = bathymetry;   % ROMS depths are positive.  nc{'depthmin'}(:) = min(bathymetry(:));  nc{'depthmax'}(:) = max(bathymetry(:));end% Maksing.mask = s.rho.mask;water = mask;   % ROMS requires water = 1, land= 0.nc{'mask_rho'}(:,:) = water;nc{'mask_u'}(:,:) = water(:, 1:end-1) & water(:, 2:end);nc{'mask_v'}(:,:) = water(1:end-1, :) & water(2:end, :);nc{'mask_psi'}(:,:) = water(1:end-1, 1:end-1) &...									water(1:end-1, 2:end) & ...									water(2:end, 1:end-1) & ...									water(2:end, 2:end);% Close the ROMS File.if ~isempty(close(nc))	disp(' ## Unable too close the ROMS output file.')end% WetCDF off.if any(findstr(lower(computer), 'mac'))	eval('wetcdf off')endncclose('nc')